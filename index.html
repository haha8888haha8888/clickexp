
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>EQ P99 XP & Mob Tracker</title>
    <style>
        body {
            background-color: #101820;
            color: #f0e6c8;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
        }
        h1 {
            text-align: center;
            color: #ffd700;
            margin-bottom: 10px;
        }
        .section {
            border: 1px solid #444;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #1b2430;
        }
        .section-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffcc66;
        }
        label {
            margin-right: 5px;
        }
        select, input[type="number"], input[type="text"], textarea {
            margin-right: 10px;
            margin-bottom: 5px;
        }
        textarea {
            width: 100%;
            height: 60px;
            resize: vertical;
        }
        button {
            margin: 3px;
            padding: 5px 10px;
            background-color: #2f3b4f;
            color: #f0e6c8;
            border: 1px solid #555;
            cursor: pointer;
        }
        button:disabled {
            background-color: #444;
            cursor: not-allowed;
        }
        #xpBarContainer {
            margin-top: 5px;
            width: 100%;
            background-color: #333;
            border: 1px solid #555;
            height: 20px;
            position: relative;
        }
        #xpBarFill {
            background-color: #3cb371;
            height: 100%;
            width: 0%;
        }
        #xpBarText {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 12px;
            top: 2px;
        }
#log {
    background-color: #000;
    color: #0f0;
    font-family: "Courier New", monospace;
    font-size: 11px;
    height: 220px;
    overflow-y: auto;
    padding: 5px;
    border: 1px solid #555;
    white-space: pre-line;
}

        .timer-display {
            font-size: 16px;
            font-weight: bold;
            margin: 5px 0;
        }
        .flash {
            animation: flash 0.7s infinite alternate;
        }
        @keyframes flash {
            from { background-color: #8b0000; }
            to   { background-color: #ff4500; }
        }
        .group-row {
            margin-left: 10px;
            margin-bottom: 3px;
            font-size: 12px;
        }
        .small-label {
            font-size: 11px;
            color: #ccc;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            margin-top: 5px;
        }
        th, td {
            border: 1px solid #555;
            padding: 3px 4px;
            text-align: center;
        }
        th {
            background-color: #2a3445;
        }
        .subtimer {
            border: 1px solid #555;
            padding: 5px;
            margin-top: 5px;
            background-color: #151d28;
        }
        .xp-edit-input {
            width: 60px;
        }
        .xp-note-input {
            width: 140px;
        }
        .pet-slider-wrapper {
            margin-top: 5px;
            font-size: 12px;
        }
        .pet-slider-wrapper input[type="range"] {
            width: 200px;
        }
        .timer-restart-area {
            margin-top: 5px;
            font-size: 12px;
            border-top: 1px solid #333;
            padding-top: 5px;
        }
        .timer-restart-area label {
            margin-right: 5px;
        }
        .timer-restart-buttons {
            margin-top: 5px;
        }
.button-flash {
    animation: flashPulse 120ms ease-out;
}

@keyframes flashPulse {
    0%   { transform: scale(1);     filter: brightness(1); }
    50%  { transform: scale(0.96);  filter: brightness(1.4); }
    100% { transform: scale(1);     filter: brightness(1); }
}

    </style>
</head>
<body>
    <h1>EverQuest P99 XP & Mob Tracker</h1>

    <!-- SESSION NOTES -->
    <div class="section">
        <div class="section-title">Session Notes</div>
        <textarea id="sessionNotes" placeholder="Anything about this camp, group, loot, patterns, etc."></textarea>
        <button id="sessionNotesUpdateBtn">Update Session Notes</button>
    </div>

    <!-- HEADER: CHARACTER / GROUP / SESSION -->
    <div class="section">
        <div class="section-title">Character & Group Setup</div>
        <div>
            <label for="charNameInput">Name:</label>
            <input id="charNameInput" type="text" placeholder="Optional" style="width:120px;">

            <label for="classSelect">Class:</label>
            <select id="classSelect">
                <option value="NEC">Necromancer (NEC)</option>
                <option value="ENC">Enchanter (ENC)</option>
                <option value="MAG">Magician (MAG)</option>
                <option value="WIZ">Wizard (WIZ)</option>
                <option value="CLR">Cleric (CLR)</option>
                <option value="DRU">Druid (DRU)</option>
                <option value="SHM">Shaman (SHM)</option>
                <option value="BRD">Bard (BRD)</option>
                <option value="MNK">Monk (MNK)</option>
                <option value="RNG">Ranger (RNG)</option>
                <option value="ROG">Rogue (ROG)</option>
                <option value="PAL">Paladin (PAL)</option>
                <option value="SHD">Shadow Knight (SHD)</option>
                <option value="WAR">Warrior (WAR)</option>
                <option value="DELETE">DELETE MEMBER</option>
            </select>

            <label for="raceSelect">Race:</label>
            <select id="raceSelect">
                <option>Human</option>
                <option>Erudite</option>
                <option>Barbarian</option>
                <option>Halfling</option>
                <option>Dwarf</option>
                <option>Gnome</option>
                <option>Half-Elf</option>
                <option>Wood Elf</option>
                <option>High Elf</option>
                <option>Dark Elf</option>
                <option>Ogre</option>
                <option>Troll</option>
                <option>Iksar</option>
            </select>

            <label for="levelInput">Level:</label>
            <input id="levelInput" type="number" min="1" max="60" value="51" style="width:60px;">

            <label for="xpInput">Current XP %:</label>
            <input id="xpInput" type="number" min="0" max="100" value="0" style="width:60px;">
        </div>

        <div style="margin-top:5px;">
            <label for="charNotes">Character Notes:</label>
            <input id="charNotes" type="text" placeholder="Root spots, charm targets, etc." style="width:260px;">
            <button id="charNotesUpdateBtn">Update Character Notes</button>
        </div>

        <div style="margin-top:5px;">
            <label>In Group?</label>
            <button id="groupYesBtn">YES</button>
            <button id="groupNoBtn">NO</button>

            <span id="groupSizeWrapper" style="margin-left:10px; display:none;">
                <label for="groupSizeInput">Total Members (1‚Äì6):</label>
                <input id="groupSizeInput" type="number" min="1" max="6" value="1" style="width:50px;">
                <button id="addMemberBtn">Add Member</button>
                <button id="removeMemberBtn">Remove Member</button>
            </span>
        </div>

        <div id="groupMembersContainer" style="margin-top:5px; display:none;">
            <div style="font-size:12px; margin-bottom:3px;">You are Member 1 (set above). Configure Members 2‚Äì6 below:</div>
            <div id="groupMemberRows"></div>
        </div>

        <div style="margin-top:5px;">
            <button id="startSessionBtn">Start Session Log</button>
            <button id="pauseSessionBtn" disabled>Pause Session</button>
            <button id="exportLogBtn">Export Log</button>
        </div>

        <div id="charTitleDisplay" style="margin-top:5px; font-size:13px; color:#ccc;">
            No session active.
        </div>

        <div id="xpBarContainer">
            <div id="xpBarFill"></div>
            <div id="xpBarText">XP: 0%</div>
        </div>
    </div>

    <!-- XP TRACKING SECTION -->
    <div class="section">
        <div class="section-title">XP Tracking</div>

        <button id="xpTimerToggleBtn">Track XP Timer: OFF</button>
        <div class="timer-display">
            XP Timer: <span id="xpTimerDisplay">0s</span>
        </div>

        <div style="margin-top:5px;">
            <label><input type="checkbox" id="usingPetCheckbox"> Using a pet?</label>
        </div>
        <div id="petSliderWrapper" class="pet-slider-wrapper" style="display:none;">
            <div>Did YOU do more damage than your pet?</div>
            <div>
                <span>YOU</span>
                <input type="range" id="petDamageSlider" min="0" max="100" value="100">
                <span>PET</span>
            </div>
            <div id="petSliderState" style="margin-top:2px;">Current: YOU get full XP</div>
        </div>

        <div class="timer-restart-area">
            <label><input type="checkbox" id="masterRestartCheckbox"> Restart selected timers when MOB EXP +1 is clicked?</label>
            <div id="timerRestartList" style="margin-top:3px; font-size:11px;">
                <!-- checkboxes for main + extra timers will appear here -->
            </div>
            <div id="timerRestartButtons" class="timer-restart-buttons">
                <!-- +1 Mob (TimerName) buttons appear here when master is checked -->
            </div>
        </div>

        <div style="margin-top:5px;">
            <button id="xpGainBtn" disabled>1% EXP GAIN RECORD</button>
            <button id="xpGainLateBtn" disabled>1% GAINED (IGNORE TIMER, INPUT LATE)</button>
        </div>

        <div style="margin-top:5px;">
            <button id="mobXpBtn" disabled>MOB EXP GAINED TRACKER +1</button>
        </div>

        <div style="font-size:12px; margin-top:5px;">
            Last 1% gap: <span id="lastGapDisplay">N/A</span><br>
            Mobs this 1%: <span id="mobsThisCycleDisplay">0</span>
        </div>

        <div style="margin-top:8px;">
            <span class="small-label">1% XP History (max 100 rows)</span>
            <table id="xpHistoryTable">
                <thead>
                    <tr>
                        <th>Current % Level</th>
                        <th>Gap</th>
                        <th>Mobs</th>
                        <th>Notes</th>
                        <th>Update</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <button id="printXpTableBtn" style="margin-top:5px;">Print XP Table to Log</button>
        </div>
    </div>

    <!-- MOB CYCLE TIMER SECTION -->
    <div class="section">
        <div class="section-title">Mob Cycle Timer</div>
        <label for="mobMinutes">Minutes:</label>
        <input id="mobMinutes" type="number" min="0" value="22" style="width:60px;">
        <label for="mobSeconds">Seconds:</label>
        <input id="mobSeconds" type="number" min="0" max="59" value="0" style="width:60px;">

        <button id="mobStartBtn">Start</button>
        <button id="mobResetBtn">Reset</button>
        <button id="mobSoundToggleBtn">Sound Alarm: ON</button>

        <div style="margin-top:5px;">
            <label for="mobNotes">Mob Timer Notes:</label>
            <input id="mobNotes" type="text" placeholder="Named PH, spawn window, etc." style="width:260px;">
            <button id="mobNotesUpdateBtn">Update Mob Timer Notes</button>
        </div>

        <div class="timer-display">
            Mob Timer: <span id="mobTimerDisplay">00:00</span>
        </div>

        <div style="margin-top:8px;">
            <button id="addCycleTimerBtn">Add Another Cycle Timer</button>
            <button id="addStopwatchBtn">Add Reverse Timer (Stopwatch)</button>
        </div>

        <div id="extraTimersContainer" style="margin-top:5px;"></div>
    </div>

    <!-- LOG PANEL -->
    <div class="section">
        <div class="section-title">Session Log</div>
        <div id="log"></div>
    </div>

    <script>
        // ---------- UTILITIES ----------
	const CloneUIMap = new Map();

	const SWOOSH_START = "&#&&#&#&#&#&##&#&#& === SWOOSH START ===";
	const SWOOSH_END   = "finfinfin*$*$*$*$*$*$*$*$$*$* === SWOOSH END ===";

let DEBUG_ENABLED = true;
let LOG_UNLOCKED = true;   // true = normal logging allowed, false = locked

let CALL_A = 1;
let CALL_B = 0;

let INSTRUMENTATION_ENABLED = false;

let SpellRegistry = {};
let UserOverrides = {};
let UserCustomSpells = [];
let SpellClassAvailable = {};

//letmesee

// ===============================
// MEGA DEBUG CONSOLE (CLICK TO OPEN)
// ===============================

(function createMegaDebugConsole() {

    // Main console window
    const dbg = document.createElement("div");
    dbg.id = "megaDebugConsole";
    dbg.style.position = "fixed";
    dbg.style.top = "0";
    dbg.style.left = "0";
    dbg.style.right = "0";
    dbg.style.height = "40vh";
    dbg.style.background = "rgba(0,0,0,0.95)";
    dbg.style.color = "#00ff00";
    dbg.style.fontFamily = "monospace";
    dbg.style.fontSize = "14px";
    dbg.style.padding = "10px";
    dbg.style.zIndex = "999999";
    dbg.style.whiteSpace = "pre-wrap";
    dbg.style.overflowY = "scroll";
    dbg.style.borderBottom = "3px solid #0f0";
    dbg.style.display = "none"; // stays hidden unless clicked

    document.body.appendChild(dbg);

    // Toggle button
    const toggle = document.createElement("div");
    toggle.textContent = "[DEBUG]";
    toggle.style.position = "fixed";
    toggle.style.top = "0";
    toggle.style.right = "0";
    toggle.style.background = "#111";
    toggle.style.color = "#0f0";
    toggle.style.padding = "6px 10px";
    toggle.style.cursor = "pointer";
    toggle.style.zIndex = "1000000";
    toggle.style.fontFamily = "monospace";
    toggle.style.fontSize = "14px";
    toggle.style.border = "1px solid #0f0";

    // Track whether user manually opened it
    let debugEnabled = false;

    toggle.onclick = () => {
        debugEnabled = !debugEnabled;
        dbg.style.display = debugEnabled ? "block" : "none";
        if (debugEnabled) dbg.scrollTop = dbg.scrollHeight;
    };

    document.body.appendChild(toggle);

    // Global debug writer (NO auto-open)
    window.__DBG = function(msg) {
        dbg.textContent += msg + "\n";
        if (debugEnabled) dbg.scrollTop = dbg.scrollHeight;
    };

    // Crash catcher (writes to log, but does NOT auto-open)
    window.onerror = function(message, source, lineno, colno, error) {
        __DBG("üî•üî•üî• SCRIPT CRASHED üî•üî•üî•");
        __DBG("Message: " + message);
        __DBG("Source: " + source + ":" + lineno);
        if (error && error.stack) __DBG("Stack:\n" + error.stack);
    };

})();


__DBG("BOOT: script started.1337");
__DBG(" GLOBAL LOG LOCK (Exclusive Write Control).");
// =======================================
// GLOBAL LOG LOCK (Exclusive Write Control)
// =======================================



        function nowStamp() {
            return new Date().toLocaleTimeString();
        }

function flipCallState(funcName) {
    // flip the booleans
    CALL_A = CALL_A === 1 ? 0 : 1;
    CALL_B = CALL_B === 1 ? 0 : 1;

    // log the function that fired
    console.log(`[TRACE] ${funcName} fired | A=${CALL_A} B=${CALL_B}`);
}

function wrapFunction(obj, fnName) {
    if (!INSTRUMENTATION_ENABLED) return;   // <-- HARD STOP

    const original = obj[fnName];

    if (typeof original !== "function") return;

    // Skip the wrapper and the instrumentation function
    if (fnName === "wrapFunction" || fnName === "instrumentAllFunctions") return;

    obj[fnName] = function(...args) {
        flipCallState(fnName);
        return original.apply(this, args);
    };
}

__DBG("past (function wrapFunction)133.");


function instrumentAllFunctions(root) {
    if (!INSTRUMENTATION_ENABLED) {
        __DBG("Instrumentation disabled ‚Äî skipping instrumentAllFunctions()");
        return;
    }

    for (const key in root) {
        try {
            if (typeof root[key] === "function") {
                wrapFunction(root, key);
            }
        } catch (e) {
            __DBG("Instrumentation skip for key: " + key);
        }
    }
}

__DBG("past (function instrumentAllFunctions(root))1122.");

function debugLog(msg) {
    if (!DEBUG_ENABLED) return;

    // Write to console only, never to the UI log
    console.log("[DEBUG " + nowStamp() + "] " + msg);
}

function logLine(text) {
    if (!LOG_UNLOCKED) {
        debugLog("logLine blocked (LOCKED): " + text);
        return;
    }

    const log = document.getElementById("log");
    log.textContent += "[" + nowStamp() + "] " + text + "\n";
    log.scrollTop = log.scrollHeight;
}
__DBG("past (function logLine(text)).1111333");

// Raw logger: bypasses LOG_UNLOCKED lock (used only by Swoosh Save)
function logRaw(text) {
    const log = document.getElementById("log");
    if (!log) {
        __DBG("logRaw: #log element NOT FOUND.");
        return;
    }
    log.textContent += text + "\n";
    log.scrollTop = log.scrollHeight;
}


document.addEventListener("DOMContentLoaded", () => {
    const log = document.getElementById("log");
    if (log) {
        __DBG("CHECK: #log element FOUND on DOMContentLoaded.");
    } else {
        __DBG("CHECK: #log element MISSING on DOMContentLoaded.");
    }
});


function freezeLogForSwoosh() {
    LOG_UNLOCKED = false;
    return new Promise(resolve => setTimeout(resolve, 2000)); // 2 sec quiet time
}

async function swooshSave() {
    await freezeLogForSwoosh();
    __DBG("ENTER: swooshSave() Step 1: lock and wait");

    const fullDatabase = {
        timestamp: new Date().toISOString(),
        registry: SpellRegistry,
        overrides: UserOverrides,
        custom: UserCustomSpells,
        classes: SpellClassAvailable,

        // ‚≠ê NEW: Save Long Term Timers
        longTermTimers: LongTermTimersAPI.getAll()
    };

    logRaw(SWOOSH_START);
    __DBG("ENTER: swooshSave Step 2: write swoosh block (SWOOSH_START)");

    logRaw(JSON.stringify(fullDatabase, null, 2));

    logRaw(SWOOSH_END);
    __DBG("ENTER: swooshSave Step 3: write swoosh block (SWOOSH_END)");

    LOG_UNLOCKED = true;
    __DBG("ENTER: swooshSave Step 4: unlock");

    logLine("Swoosh Save Complete.");
    __DBG("ENTER: swooshSave() COMPLETE");
}

__DBG("past (function swooshSave()).1111333");


        function logUnloggedMembers() {
            if (!inGroup || groupSize <= 1) return;
            const rows = groupMemberRows.querySelectorAll(".group-row");
            rows.forEach(row => {
                if (row.dataset.logged === "true") return;
                const idx = row.dataset.memberIndex;
                const clsSel = row.querySelector(".gm-class");
                const lvlInp = row.querySelector(".gm-level");
                const raceSel = row.querySelector(".gm-race");
                const nameInp = row.querySelector(".gm-name");
                if (!clsSel || !lvlInp || !raceSel || !nameInp) return;
                const cls = clsSel.value;
                const lvl = parseInt(lvlInp.value, 10) || 1;
                const race = raceSel.value;
                const name = nameInp.value.trim();
                if (!cls && !race && !name) return;
                let line = `Member ${idx} info: Class: ${cls}, Race: ${race}, Level: ${lvl}`;
                if (name) line += `, Name: ${name}`;
                logLine(line);
                row.dataset.logged = "true";
            });
        }

        function logLineWithRoster(text) {
            logUnloggedMembers();
            logLine(text);
        }

        function getClassTitle(cls, lvl) {
            lvl = parseInt(lvl, 10);
            if (isNaN(lvl)) return "";

            const map = {
                "BRD": ["Minstrel", "Troubadour", "Virtuoso"],
                "CLR": ["Vicar", "Templar", "High Priest"],
                "DRU": ["Wanderer", "Preserver", "Hierophant"],
                "ENC": ["Illusionist", "Beguiler", "Phantasmist"],
                "MAG": ["Elementalist", "Conjurer", "Arch Mage"],
                "MNK": ["Disciple", "Master", "Grandmaster"],
                "NEC": ["Heretic", "Defiler", "Warlock"],
                "PAL": ["Cavalier", "Knight", "Crusader"],
                "RNG": ["Pathfinder", "Outrider", "Warder"],
                "ROG": ["Rake", "Blackguard", "Assassin"],
                "SHD": ["Reaver", "Revenant", "Grave Lord"],
                "SHM": ["Mystic", "Luminary", "Oracle"],
                "WAR": ["Champion", "Myrmidon", "Warlord"],
                "WIZ": ["Channeler", "Evoker", "Sorcerer"]
            };

            if (lvl < 51) return "";
            if (lvl >= 51 && lvl <= 54) return map[cls]?.[0] || "";
            if (lvl >= 55 && lvl <= 59) return map[cls]?.[1] || "";
            if (lvl === 60) return map[cls]?.[2] || "";
            return "";
        }
__DBG("past (getClassTitle(cls, lvl)2211333");
        function updateXpBar(percent) {
            percent = Math.max(0, Math.min(100, percent));
            const fill = document.getElementById("xpBarFill");
            const text = document.getElementById("xpBarText");
            fill.style.width = percent + "%";
            text.textContent = "XP: " + percent + "%";
        }

        function formatMs(ms) {
            const totalSec = Math.max(0, Math.floor(ms / 1000));
            const m = Math.floor(totalSec / 60);
            const s = totalSec % 60;
            return (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
        }

        function makeBeep() {
            try {
                if (!window._audioCtx) {
                    window._audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const duration = 0.3;
                const osc = window._audioCtx.createOscillator();
                const gain = window._audioCtx.createGain();
                osc.type = "square";
                osc.frequency.value = 880;
                osc.connect(gain);
                gain.connect(window._audioCtx.destination);
                gain.gain.setValueAtTime(0.2, window._audioCtx.currentTime);
                osc.start();
                osc.stop(window._audioCtx.currentTime + duration);
            } catch (e) {}
        }
__DBG("past function makeBeep()22221111333");
        function downloadLog() {
            const logText = document.getElementById("log").textContent || "";
            const now = new Date();
            const pad = n => (n < 10 ? "0" + n : "" + n);
            const yyyy = now.getFullYear();
            const mm = pad(now.getMonth() + 1);
            const dd = pad(now.getDate());
            const hh = pad(now.getHours());
            const mi = pad(now.getMinutes());
            const ss = pad(now.getSeconds());
            const filename = `eq_session_log_${yyyy}-${mm}-${dd}_${hh}-${mi}-${ss}.txt`;

            const blob = new Blob([logText], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logLine(`Log exported as ${filename}`);
        }

        // ---------- STATE ----------
        let sessionActive = false;
        let sessionPaused = false;
        let xpPercent = 0;
        let xpTimerRunning = false;
        let xpTimerStartMs = null;
        let xpTimerInterval = null;
        let xpElapsedOffsetMs = 0;
        let last1pTimeMs = null;
        let lastGapText = "N/A";
        let mobsThisCycle = 0;
        let xpHistory = [];
        let xpTablePrinted = false;

        let mobTimerInterval = null;
        let mobRemainingMs = 0;
        let mobSoundOn = true;
        let mobTimerRunning = false;
        let mobTimerStartMs = null;
        let mobTimerOriginalMs = 0;

        let inGroup = false;
        let groupSize = 1;

        let extraTimerIdCounter = 1;
        const timerRegistry = {}; // id -> {type, labelFn, restartFn, checkboxEl, buttonEl}

        // ---------- ELEMENTS ----------
        const sessionNotes = document.getElementById("sessionNotes");
        const sessionNotesUpdateBtn = document.getElementById("sessionNotesUpdateBtn");

        const charNameInput = document.getElementById("charNameInput");
        const classSelect = document.getElementById("classSelect");
        const raceSelect = document.getElementById("raceSelect");
        const levelInput = document.getElementById("levelInput");
        const xpInput = document.getElementById("xpInput");
        const charNotes = document.getElementById("charNotes");
        const charNotesUpdateBtn = document.getElementById("charNotesUpdateBtn");
        const startSessionBtn = document.getElementById("startSessionBtn");
        const pauseSessionBtn = document.getElementById("pauseSessionBtn");
        const exportLogBtn = document.getElementById("exportLogBtn");
        const charTitleDisplay = document.getElementById("charTitleDisplay");

        const groupYesBtn = document.getElementById("groupYesBtn");
        const groupNoBtn = document.getElementById("groupNoBtn");
        const groupSizeWrapper = document.getElementById("groupSizeWrapper");
        const groupSizeInput = document.getElementById("groupSizeInput");
        const addMemberBtn = document.getElementById("addMemberBtn");
        const removeMemberBtn = document.getElementById("removeMemberBtn");
        const groupMembersContainer = document.getElementById("groupMembersContainer");
        const groupMemberRows = document.getElementById("groupMemberRows");

        const xpTimerToggleBtn = document.getElementById("xpTimerToggleBtn");
        const xpTimerDisplay = document.getElementById("xpTimerDisplay");
        const xpGainBtn = document.getElementById("xpGainBtn");
        const xpGainLateBtn = document.getElementById("xpGainLateBtn");
        const mobXpBtn = document.getElementById("mobXpBtn");
        const lastGapDisplay = document.getElementById("lastGapDisplay");
        const mobsThisCycleDisplay = document.getElementById("mobsThisCycleDisplay");
        const xpHistoryTableBody = document.querySelector("#xpHistoryTable tbody");
        const printXpTableBtn = document.getElementById("printXpTableBtn");

        const usingPetCheckbox = document.getElementById("usingPetCheckbox");
        const petSliderWrapper = document.getElementById("petSliderWrapper");
        const petDamageSlider = document.getElementById("petDamageSlider");
        const petSliderState = document.getElementById("petSliderState");

        const masterRestartCheckbox = document.getElementById("masterRestartCheckbox");
        const timerRestartList = document.getElementById("timerRestartList");
        const timerRestartButtons = document.getElementById("timerRestartButtons");

        const mobMinutes = document.getElementById("mobMinutes");
        const mobSeconds = document.getElementById("mobSeconds");
        const mobStartBtn = document.getElementById("mobStartBtn");
        const mobResetBtn = document.getElementById("mobResetBtn");
        const mobSoundToggleBtn = document.getElementById("mobSoundToggleBtn");
        const mobTimerDisplay = document.getElementById("mobTimerDisplay");
        const mobNotes = document.getElementById("mobNotes");
        const mobNotesUpdateBtn = document.getElementById("mobNotesUpdateBtn");

        const addCycleTimerBtn = document.getElementById("addCycleTimerBtn");
        const addStopwatchBtn = document.getElementById("addStopwatchBtn");
        const extraTimersContainer = document.getElementById("extraTimersContainer");
__DBG("past ---------- ELEMENTS ----------33331111333");
        // ---------- NOTES BUTTONS ----------
        sessionNotesUpdateBtn.addEventListener("click", () => {
            const txt = sessionNotes.value.trim();
            if (!txt) {
                logLineWithRoster("Session notes cleared.");
            } else {
                logLineWithRoster(`Session notes updated: "${txt}"`);
            }
        });

        charNotesUpdateBtn.addEventListener("click", () => {
            const txt = charNotes.value.trim();
            if (!txt) {
                logLineWithRoster("Character notes cleared.");
            } else {
                logLineWithRoster(`Character notes updated: "${txt}"`);
            }
        });

        mobNotesUpdateBtn.addEventListener("click", () => {
            const txt = mobNotes.value.trim();
            if (!txt) {
                logLineWithRoster("Main mob timer notes cleared.");
            } else {
                logLineWithRoster(`Main mob timer notes updated: "${txt}"`);
            }
        });

        // ---------- GROUP UI ----------
        function updateGroupButtons() {
            groupSizeInput.value = groupSize;
            addMemberBtn.disabled = (groupSize >= 6);
            removeMemberBtn.disabled = (groupSize <= 1);
            groupYesBtn.disabled = inGroup;
            groupNoBtn.disabled = !inGroup;
        }

        function rebuildGroupMemberRows() {
            groupMemberRows.innerHTML = "";
            for (let i = 2; i <= groupSize; i++) {
                const row = document.createElement("div");
                row.className = "group-row";
                row.dataset.memberIndex = i;
                row.dataset.logged = "false";

                const label = document.createElement("span");
                label.textContent = `Member ${i}: `;

                const nameInput = document.createElement("input");
                nameInput.type = "text";
                nameInput.placeholder = "Name (optional)";
                nameInput.style.width = "110px";
                nameInput.className = "gm-name";

                const noteInput = document.createElement("input");
                noteInput.type = "text";
                noteInput.placeholder = "Note";
                noteInput.style.width = "120px";
                noteInput.className = "gm-note";

                const noteBtn = document.createElement("button");
                noteBtn.textContent = "Update Notes";
                noteBtn.className = "gm-note-update";

                const clsSel = document.createElement("select");
                clsSel.innerHTML = classSelect.innerHTML;
                clsSel.className = "gm-class";

                const lvlInput = document.createElement("input");
                lvlInput.type = "number";
                lvlInput.min = "1";
                lvlInput.max = "60";
                lvlInput.value = "50";
                lvlInput.style.width = "50px";
                lvlInput.className = "gm-level";

                const raceSel = document.createElement("select");
                raceSel.innerHTML = raceSelect.innerHTML;
                raceSel.className = "gm-race";

                row.appendChild(label);
                row.appendChild(document.createTextNode("Class: "));
                row.appendChild(clsSel);
                row.appendChild(document.createTextNode(" Level: "));
                row.appendChild(lvlInput);
                row.appendChild(document.createTextNode(" Race: "));
                row.appendChild(raceSel);
                row.appendChild(document.createTextNode(" Name: "));
                row.appendChild(nameInput);
                row.appendChild(document.createTextNode(" Note: "));
                row.appendChild(noteInput);
                row.appendChild(noteBtn);

                noteBtn.addEventListener("click", () => {
                    const idx = row.dataset.memberIndex;
                    const noteTxt = noteInput.value.trim();
                    if (!noteTxt) {
                        logLineWithRoster(`Member ${idx} notes cleared.`);
                    } else {
                        logLineWithRoster(`Member ${idx} notes updated: "${noteTxt}"`);
                    }
                });

                groupMemberRows.appendChild(row);
            }
        }
__DBG("past rebuildGroupMemberRows()44431111333");
        function pauseXpTimerForGroupChange(newStateText) {
            if (!xpTimerRunning) {
                logLineWithRoster(`Group state changed: ${newStateText} (XP timer idle).`);
                return;
            }
            const now = Date.now();
            const elapsed = now - xpTimerStartMs + xpElapsedOffsetMs;
            xpElapsedOffsetMs = elapsed;
            if (xpTimerInterval) clearInterval(xpTimerInterval);
            xpTimerInterval = null;
            xpTimerDisplay.textContent = Math.floor(elapsed / 1000) + "s";
            logLineWithRoster(`Group state changed: ${newStateText} (XP timer paused briefly).`);
            xpTimerStartMs = Date.now();
            xpTimerInterval = setInterval(() => {
                const elapsedSec = Math.floor((Date.now() - xpTimerStartMs + xpElapsedOffsetMs) / 1000);
                xpTimerDisplay.textContent = elapsedSec + "s";
            }, 500);
            logLineWithRoster("Group time tracking updated.");
        }

        groupYesBtn.addEventListener("click", () => {
            if (inGroup) return;
            inGroup = true;
            groupSizeWrapper.style.display = "inline";
            groupMembersContainer.style.display = "block";
            groupSize = Math.max(1, Math.min(6, parseInt(groupSizeInput.value, 10) || 1));
            updateGroupButtons();
            rebuildGroupMemberRows();
            pauseXpTimerForGroupChange("JOINED GROUP");
        });

        groupNoBtn.addEventListener("click", () => {
            if (!inGroup) return;
            inGroup = false;
            groupSize = 1;
            groupSizeWrapper.style.display = "none";
            groupMembersContainer.style.display = "none";
            updateGroupButtons();
            rebuildGroupMemberRows();
            pauseXpTimerForGroupChange("LEFT GROUP (SOLO)");
        });

        groupSizeInput.addEventListener("change", () => {
            let val = parseInt(groupSizeInput.value, 10) || 1;
            val = Math.max(1, Math.min(6, val));
            groupSize = val;
            updateGroupButtons();
            rebuildGroupMemberRows();
        });

        addMemberBtn.addEventListener("click", () => {
    if (groupSize >= 6) return;

    groupSize++;
    updateGroupButtons();

    const idx = groupSize;

    // Create a new row WITHOUT rebuilding the others
    const row = document.createElement("div");
    row.className = "group-row";
    row.dataset.memberIndex = idx;
    row.dataset.logged = "false";

    const label = document.createElement("span");
    label.textContent = `Member ${idx}: `;

    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.placeholder = "Name (optional)";
    nameInput.style.width = "110px";
    nameInput.className = "gm-name";

    const noteInput = document.createElement("input");
    noteInput.type = "text";
    noteInput.placeholder = "Note";
    noteInput.style.width = "120px";
    noteInput.className = "gm-note";

    const noteBtn = document.createElement("button");
    noteBtn.textContent = "Update Notes";
    noteBtn.className = "gm-note-update";

    const clsSel = document.createElement("select");
    clsSel.innerHTML = classSelect.innerHTML;
    clsSel.className = "gm-class";

    const lvlInput = document.createElement("input");
    lvlInput.type = "number";
    lvlInput.min = "1";
    lvlInput.max = "60";
    lvlInput.value = "50";
    lvlInput.style.width = "50px";
    lvlInput.className = "gm-level";

    const raceSel = document.createElement("select");
    raceSel.innerHTML = raceSelect.innerHTML;
    raceSel.className = "gm-race";

    row.appendChild(label);
    row.appendChild(document.createTextNode("Class: "));
    row.appendChild(clsSel);
    row.appendChild(document.createTextNode(" Level: "));
    row.appendChild(lvlInput);
    row.appendChild(document.createTextNode(" Race: "));
    row.appendChild(raceSel);
    row.appendChild(document.createTextNode(" Name: "));
    row.appendChild(nameInput);
    row.appendChild(document.createTextNode(" Note: "));
    row.appendChild(noteInput);
    row.appendChild(noteBtn);

    noteBtn.addEventListener("click", () => {
        const noteTxt = noteInput.value.trim();
        if (!noteTxt) {
            logLineWithRoster(`Member ${idx} notes cleared.`);
        } else {
            logLineWithRoster(`Member ${idx} notes updated: "${noteTxt}"`);
        }
    });

    groupMemberRows.appendChild(row);

    logLineWithRoster(`Member ${idx} added (empty fields).`);
});


        removeMemberBtn.addEventListener("click", () => {
    if (groupSize <= 1) return;

    const rows = Array.from(groupMemberRows.querySelectorAll(".group-row"));
    let removed = false;

    for (const row of rows) {
        const clsSel = row.querySelector(".gm-class");
        if (clsSel && clsSel.value === "DELETE") {
            const idx = row.dataset.memberIndex;

            const lvlInp = row.querySelector(".gm-level");
            const raceSel = row.querySelector(".gm-race");
            const nameInp = row.querySelector(".gm-name");

            const cls = clsSel.value;
            const lvl = parseInt(lvlInp.value, 10) || 1;
            const race = raceSel.value;
            const name = nameInp.value.trim();

            if (confirm(`Remove Member ${idx}?`)) {
                let line = `Member ${idx} removed (Class: ${cls}, Race: ${race}, Level: ${lvl}`;
                if (name) line += `, Name: ${name}`;
                line += ")";
                logLineWithRoster(line);

                // Remove ONLY this row
                row.remove();
                groupSize--;

                // Reindex remaining rows WITHOUT resetting their values
                const remaining = Array.from(groupMemberRows.querySelectorAll(".group-row"));
                remaining.forEach((r, i) => {
                    const newIndex = i + 2; // Member 2‚Äì6
                    r.dataset.memberIndex = newIndex;
                    r.querySelector("span").textContent = `Member ${newIndex}: `;
                });

                updateGroupButtons();
                removed = true;
            }
            break;
        }
    }

    if (!removed) {
        logLineWithRoster("No member marked as DELETE. Set a member's class to DELETE MEMBER, then press Remove.");
    }
});


        // ---------- XP HISTORY TABLE ----------
        function renderXpHistory() {
            xpHistoryTableBody.innerHTML = "";
            xpHistory.slice(0, 100).forEach((entry, index) => {
                const tr = document.createElement("tr");

                const tdLvl = document.createElement("td");
                const tdGap = document.createElement("td");
                const tdMobs = document.createElement("td");
                const tdNotes = document.createElement("td");
                const tdUpdate = document.createElement("td");

                tdLvl.textContent = entry.levelPercent + "%";

                const gapInput = document.createElement("input");
                gapInput.type = "text";
                gapInput.value = entry.gap;
                gapInput.className = "xp-edit-input";
                tdGap.appendChild(gapInput);

                const mobsInput = document.createElement("input");
                mobsInput.type = "number";
                mobsInput.value = entry.mobs;
                mobsInput.className = "xp-edit-input";
                tdMobs.appendChild(mobsInput);

                const noteInput = document.createElement("input");
                noteInput.type = "text";
                noteInput.value = entry.note || "";
                noteInput.className = "xp-note-input";
                tdNotes.appendChild(noteInput);

                const updateBtn = document.createElement("button");
                updateBtn.textContent = "Update";
                updateBtn.style.fontSize = "10px";
                tdUpdate.appendChild(updateBtn);

                updateBtn.addEventListener("click", () => {
                    const oldGap = entry.gap;
                    const oldMobs = entry.mobs;
                    const oldNote = entry.note || "";
                    entry.gap = gapInput.value.trim() || oldGap;
                    entry.mobs = parseInt(mobsInput.value, 10) || oldMobs;
                    entry.note = noteInput.value.trim();
                    logLineWithRoster(
                        `XP Table Row ${index + 1} updated: Gap="${entry.gap}", Mobs=${entry.mobs}, Notes="${entry.note || ""}"`
                    );
                    renderXpHistory();
                });

                tr.appendChild(tdLvl);
                tr.appendChild(tdGap);
                tr.appendChild(tdMobs);
                tr.appendChild(tdNotes);
                tr.appendChild(tdUpdate);
                xpHistoryTableBody.appendChild(tr);
            });
        }

        function printXpTableToLog() {
            if (!xpHistory.length) {
                logLineWithRoster("XP Table is empty, nothing to print.");
                return;
            }
            logLineWithRoster("XP Table Dump:");
            xpHistory.forEach((entry, idx) => {
                logLine(
                    `Row ${idx + 1}: ${entry.levelPercent}% ‚Äî Gap="${entry.gap}", Mobs=${entry.mobs}, Notes="${entry.note || ""}"`
                );
            });
            xpTablePrinted = true;
        }

        printXpTableBtn.addEventListener("click", () => {
            printXpTableToLog();
        });

        // ---------- PET LOGIC ----------
        usingPetCheckbox.addEventListener("change", () => {
            if (usingPetCheckbox.checked) {
                petSliderWrapper.style.display = "block";
            } else {
                petSliderWrapper.style.display = "none";
            }
        });

        petDamageSlider.addEventListener("input", () => {
            const val = parseInt(petDamageSlider.value, 10);
            if (val >= 50) {
                petSliderState.textContent = "Current: YOU get full XP";
            } else {
                petSliderState.textContent = "Current: PET did more damage (XP penalty)";
            }
        });

        function describePetXpSplit() {
            if (!usingPetCheckbox.checked) return "No pet";
            const val = parseInt(petDamageSlider.value, 10);
            if (val >= 50) return "Full XP (you outdamaged pet)";
            return "Pet penalty applied (50% XP)";
        }

        // ---------- SESSION ----------
        startSessionBtn.addEventListener("click", () => {
            if (sessionActive) {
                logLineWithRoster("Session already active. Start Session is locked.");
                return;
            }

            const cls = classSelect.value;
            const race = raceSelect.value;
            const lvl = parseInt(levelInput.value, 10) || 1;
            const xp = parseInt(xpInput.value, 10) || 0;
            const name = charNameInput.value.trim();

            sessionActive = true;
            sessionPaused = false;
            pauseSessionBtn.disabled = false;
            pauseSessionBtn.textContent = "Pause Session";
            startSessionBtn.disabled = true;

            xpPercent = Math.max(0, Math.min(100, xp));
            updateXpBar(xpPercent);

            const title = getClassTitle(cls, lvl);
            const baseClassText = title ? `Level ${lvl} ${title} (${cls})` : `Level ${lvl} ${cls}`;
            const namePart = name ? `${name} ‚Äî ` : "";
            charTitleDisplay.textContent = `${namePart}${baseClassText} ‚Äî Race: ${race}`;
            logLineWithRoster(`Session started ‚Äî ${namePart}${baseClassText}, Race: ${race}, XP: ${xpPercent}%`);

            if (!inGroup || groupSize === 1) {
                logLineWithRoster("Group: NO (solo)");
            } else {
                logLineWithRoster(`Group: YES ‚Äî ${groupSize} total members`);
                const youLine = `Member 1: ${cls} ${lvl} ${race} (you${name ? ", " + name : ""})`;
                logLineWithRoster(youLine);

                const rows = groupMemberRows.querySelectorAll(".group-row");
                rows.forEach(row => {
                    const idx = row.dataset.memberIndex;
                    const cSel = row.querySelector(".gm-class");
                    const lInp = row.querySelector(".gm-level");
                    const rSel = row.querySelector(".gm-race");
                    const nInp = row.querySelector(".gm-name");
                    const noteInp = row.querySelector(".gm-note");
                    const cVal = cSel.value;
                    const lVal = parseInt(lInp.value, 10) || 1;
                    const rVal = rSel.value;
                    const nVal = nInp.value.trim();
                    const noteVal = noteInp.value.trim();
                    let line = `Member ${idx}: ${cVal} ${lVal} ${rVal}`;
                    if (nVal) line += `, Name: ${nVal}`;
                    if (noteVal) line += `, Note: ${noteVal}`;
                    logLine(line);
                    row.dataset.logged = "true";
                });
            }

            xpTimerRunning = false;
            xpTimerStartMs = null;
            xpElapsedOffsetMs = 0;
            last1pTimeMs = null;
            lastGapText = "N/A";
            lastGapDisplay.textContent = lastGapText;
            xpTimerDisplay.textContent = "0s";
            xpTimerToggleBtn.textContent = "Track XP Timer: OFF";
            xpGainBtn.disabled = true;
            xpGainLateBtn.disabled = true;
            mobXpBtn.disabled = true;

            mobsThisCycle = 0;
            mobsThisCycleDisplay.textContent = "0";
            xpHistory = [];
            xpTablePrinted = false;
            renderXpHistory();
        });

        pauseSessionBtn.addEventListener("click", () => {
            if (!sessionActive) return;

            if (!sessionPaused) {
                sessionPaused = true;
                pauseSessionBtn.textContent = "Resume Session";

                if (xpTimerRunning) {
                    const now = Date.now();
                    const elapsed = now - xpTimerStartMs + xpElapsedOffsetMs;
                    xpElapsedOffsetMs = elapsed;
                    if (xpTimerInterval) clearInterval(xpTimerInterval);
                    xpTimerInterval = null;
                    xpTimerDisplay.textContent = Math.floor(elapsed / 1000) + "s";
                }

                xpTimerRunning = false;
                xpTimerToggleBtn.textContent = "Track XP Timer: OFF";
                xpGainBtn.disabled = true;
                xpGainLateBtn.disabled = true;
                mobXpBtn.disabled = true;

                logLineWithRoster("Session paused (XP tracking halted, mob timers continue).");

                // auto-print XP table once when session is paused for the first time
                if (!xpTablePrinted && xpHistory.length > 0) {
                    printXpTableToLog();
                }
            } else {
                sessionPaused = false;
                pauseSessionBtn.textContent = "Pause Session";
                logLineWithRoster("Session resumed.");

                if (xpElapsedOffsetMs > 0) {
                    xpTimerStartMs = Date.now();
                    xpTimerInterval = setInterval(() => {
                        const elapsedSec = Math.floor((Date.now() - xpTimerStartMs + xpElapsedOffsetMs) / 1000);
                        xpTimerDisplay.textContent = elapsedSec + "s";
                    }, 500);
                    xpTimerRunning = true;
                    xpTimerToggleBtn.textContent = "Track XP Timer: ON";
                    xpGainBtn.disabled = false;
                    xpGainLateBtn.disabled = false;
                    mobXpBtn.disabled = false;
                }
            }
        });

        exportLogBtn.addEventListener("click", downloadLog);

        // ---------- XP TIMER ----------
        xpTimerToggleBtn.addEventListener("click", () => {
            if (!sessionActive) {
                logLineWithRoster("Cannot start XP timer ‚Äî no active session.");
                return;
            }
            if (sessionPaused) {
                logLineWithRoster("Cannot change XP timer while session is paused.");
                return;
            }

            if (!xpTimerRunning) {
                xpTimerRunning = true;
                xpTimerToggleBtn.textContent = "Track XP Timer: ON";
                xpGainBtn.disabled = false;
                xpGainLateBtn.disabled = false;
                mobXpBtn.disabled = false;

                xpTimerStartMs = Date.now();
                if (!last1pTimeMs) {
                    last1pTimeMs = Date.now();
                }

                if (xpTimerInterval) clearInterval(xpTimerInterval);
                xpTimerInterval = setInterval(() => {
                    const elapsedSec = Math.floor((Date.now() - xpTimerStartMs + xpElapsedOffsetMs) / 1000);
                    xpTimerDisplay.textContent = elapsedSec + "s";
                }, 500);

                logLineWithRoster("XP timer started.");
            } else {
                xpTimerRunning = false;
                xpTimerToggleBtn.textContent = "Track XP Timer: OFF";
                xpGainBtn.disabled = true;
                xpGainLateBtn.disabled = true;
                mobXpBtn.disabled = true;

                if (xpTimerInterval) clearInterval(xpTimerInterval);
                xpTimerInterval = null;

                const now = Date.now();
                const elapsed = now - xpTimerStartMs + xpElapsedOffsetMs;
                xpElapsedOffsetMs = elapsed;
                xpTimerDisplay.textContent = Math.floor(elapsed / 1000) + "s";

                logLineWithRoster("XP timer stopped.");
            }
        });

        function handleXpGain(isLate) {
            if (!sessionActive || !xpTimerRunning || sessionPaused) return;

            const now = Date.now();
            if (last1pTimeMs) {
                const gapSec = Math.floor((now - last1pTimeMs) / 1000);
                lastGapText = gapSec + "s";
            } else {
                lastGapText = "First 1% this session";
            }
            last1pTimeMs = now;
            lastGapDisplay.textContent = lastGapText;

            const mobsForThis = mobsThisCycle;
            xpPercent = Math.min(100, xpPercent + 1);
            updateXpBar(xpPercent);

            const petSplit = describePetXpSplit();
            const mobsText = `Mobs this 1%: ${mobsForThis}`;
            if (!isLate) {
                logLineWithRoster(`XP +1% ‚Äî Gap: ${lastGapText} ‚Äî ${mobsText} ‚Äî ${petSplit}`);
            } else {
                logLineWithRoster(`XP +1% (late input) ‚Äî Gap: ${lastGapText} ‚Äî ${mobsText} ‚Äî ${petSplit}`);
            }

            if (xpHistory.length < 100) {
                xpHistory.push({
                    levelPercent: xpPercent,
                    gap: lastGapText,
                    mobs: mobsForThis,
                    note: ""
                });
                renderXpHistory();
            }

            mobsThisCycle = 0;
            mobsThisCycleDisplay.textContent = "0";
        }

        xpGainBtn.addEventListener("click", () => handleXpGain(false));
        xpGainLateBtn.addEventListener("click", () => handleXpGain(true));

        function restartSelectedTimersFromMobXp(sourceLabel) {
            const restarted = [];
            Object.values(timerRegistry).forEach(entry => {
                if (entry.checkboxEl && entry.checkboxEl.checked) {
                    entry.restartFn();
                    restarted.push(entry.labelFn());
                }
            });
            if (restarted.length) {
                logLineWithRoster(`Mob XP +1 (${sourceLabel}) ‚Äî Restarted: ${restarted.join(", ")}`);
            } else {
                logLineWithRoster(`Mob XP +1 (${sourceLabel}) ‚Äî No timers restarted.`);
            }
        }

        mobXpBtn.addEventListener("click", () => {
            if (!sessionActive || !xpTimerRunning || sessionPaused) return;
            mobsThisCycle++;
            mobsThisCycleDisplay.textContent = String(mobsThisCycle);
            const petSplit = describePetXpSplit();
            logLineWithRoster(`Mob XP +1 ‚Äî Total this cycle: ${mobsThisCycle} ‚Äî ${petSplit}`);
            if (masterRestartCheckbox.checked) {
                restartSelectedTimersFromMobXp("Global");
            }
        });

        // ---------- MAIN MOB TIMER ----------
        function registerMainMobTimer() {
            timerRegistry["mainMob"] = {
                type: "cycle",
                labelFn: () => "Main Mob Timer",
                restartFn: () => {
                    const mins = parseInt(mobMinutes.value, 10) || 0;
                    const secs = parseInt(mobSeconds.value, 10) || 0;
                    const totalMs = (mins * 60 + secs) * 1000;
                    if (totalMs <= 0) return;
                    if (mobTimerInterval) clearInterval(mobTimerInterval);
                    mobTimerOriginalMs = totalMs;
                    mobRemainingMs = totalMs;
                    mobTimerDisplay.textContent = formatMs(mobRemainingMs);
                    mobStartBtn.classList.remove("flash");
                    mobTimerRunning = true;
                    mobStartBtn.textContent = "Pause";
                    mobTimerStartMs = Date.now();
                    mobTimerInterval = setInterval(() => {
                        const elapsed = Date.now() - mobTimerStartMs;
                        mobRemainingMs = mobTimerOriginalMs - elapsed;
                        if (mobRemainingMs <= 0) {
                            mobRemainingMs = 0;
                            mobTimerDisplay.textContent = "00:00";
                            clearInterval(mobTimerInterval);
                            mobTimerInterval = null;
                            mobTimerRunning = false;
                            mobStartBtn.textContent = "Start";
                            mobStartBtn.classList.add("flash");
                            logLineWithRoster("Mob cycle timer finished.");
                            if (mobSoundOn) makeBeep();
                        } else {
                            mobTimerDisplay.textContent = formatMs(mobRemainingMs);
                        }
                    }, 500);
                },
                checkboxEl: null,
                buttonEl: null
            };
            rebuildTimerRestartUI();
        }

        mobSoundToggleBtn.addEventListener("click", () => {
            mobSoundOn = !mobSoundOn;
            mobSoundToggleBtn.textContent = "Sound Alarm: " + (mobSoundOn ? "ON" : "OFF");
            logLineWithRoster("Mob timer sound alarm turned " + (mobSoundOn ? "ON" : "OFF") + ".");
        });

        mobStartBtn.addEventListener("click", () => {
            const mins = parseInt(mobMinutes.value, 10) || 0;
            const secs = parseInt(mobSeconds.value, 10) || 0;
            const totalMs = (mins * 60 + secs) * 1000;

            if (!mobTimerRunning) {
                if (totalMs <= 0 && mobRemainingMs <= 0) {
                    logLineWithRoster("Mob timer not started ‚Äî duration must be > 0.");
                    return;
                }
                if (mobRemainingMs <= 0) {
                    mobTimerOriginalMs = totalMs;
                    mobRemainingMs = totalMs;
                }
                mobStartBtn.classList.remove("flash");
                mobTimerRunning = true;
                mobStartBtn.textContent = "Pause";
                mobTimerStartMs = Date.now();
                if (mobTimerInterval) clearInterval(mobTimerInterval);
                mobTimerInterval = setInterval(() => {
                    const elapsed = Date.now() - mobTimerStartMs;
                    mobRemainingMs = mobTimerOriginalMs - elapsed;
                    if (mobRemainingMs <= 0) {
                        mobRemainingMs = 0;
                        mobTimerDisplay.textContent = "00:00";
                        clearInterval(mobTimerInterval);
                        mobTimerInterval = null;
                        mobTimerRunning = false;
                        mobStartBtn.textContent = "Start";
                        mobStartBtn.classList.add("flash");
                        logLineWithRoster("Mob cycle timer finished.");
                        if (mobSoundOn) makeBeep();
                    } else {
                        mobTimerDisplay.textContent = formatMs(mobRemainingMs);
                    }
                }, 500);
                logLineWithRoster(`Mob cycle timer started/resumed: ${mins}m ${secs}s.`);
            } else {
                mobTimerRunning = false;
                mobStartBtn.textContent = "Continue";
                if (mobTimerInterval) clearInterval(mobTimerInterval);
                mobTimerInterval = null;
                mobTimerOriginalMs = mobRemainingMs;
                logLineWithRoster(`Mob cycle timer paused at ${formatMs(mobRemainingMs)}.`);
            }
        });

        mobResetBtn.addEventListener("click", () => {
            if (mobTimerInterval) clearInterval(mobTimerInterval);
            mobTimerInterval = null;
            mobTimerRunning = false;
            mobStartBtn.textContent = "Start";
            mobStartBtn.classList.remove("flash");
            const mins = parseInt(mobMinutes.value, 10) || 0;
            const secs = parseInt(mobSeconds.value, 10) || 0;
            mobRemainingMs = (mins * 60 + secs) * 1000;
            mobTimerOriginalMs = mobRemainingMs;
            mobTimerDisplay.textContent = formatMs(mobRemainingMs);
            logLineWithRoster("Mob cycle timer reset.");
        });

        // ---------- EXTRA TIMERS (CYCLE + STOPWATCH) ----------
        function rebuildTimerRestartUI() {
            timerRestartList.innerHTML = "";
            timerRestartButtons.innerHTML = "";

            Object.entries(timerRegistry).forEach(([id, entry]) => {
                const label = entry.labelFn();

                const cbLabel = document.createElement("label");
                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.dataset.timerId = id;
                cbLabel.appendChild(cb);
                cbLabel.appendChild(document.createTextNode(" " + label + " "));
                timerRestartList.appendChild(cbLabel);

                entry.checkboxEl = cb;

                if (masterRestartCheckbox.checked) {
                    const btn = document.createElement("button");
                    btn.textContent = `+1 Mob (${label})`;
                    btn.style.fontSize = "10px";
                    btn.addEventListener("click", () => {
                        if (!sessionActive || !xpTimerRunning || sessionPaused) return;
                        mobsThisCycle++;
                        mobsThisCycleDisplay.textContent = String(mobsThisCycle);
                        const petSplit = describePetXpSplit();
                        entry.restartFn();
                        logLineWithRoster(`Mob XP +1 (${label}) ‚Äî Timer restarted ‚Äî ${petSplit}`);
                    });
                    timerRestartButtons.appendChild(btn);
                    entry.buttonEl = btn;
                } else {
                    entry.buttonEl = null;
                }
            });
        }

        masterRestartCheckbox.addEventListener("change", () => {
            rebuildTimerRestartUI();
        });

        function createCycleTimer() {
            const id = "cycle_" + (extraTimerIdCounter++);
            const wrapper = document.createElement("div");
            wrapper.className = "subtimer";
            wrapper.dataset.timerId = id;
            wrapper.dataset.type = "cycle";

            const labelInput = document.createElement("input");
            labelInput.type = "text";
            labelInput.placeholder = "Label (optional)";
            labelInput.style.width = "140px";

            const noteInput = document.createElement("input");
            noteInput.type = "text";
            noteInput.placeholder = "Notes";
            noteInput.style.width = "140px";

            const noteBtn = document.createElement("button");
            noteBtn.textContent = "Update Notes";

            const minInput = document.createElement("input");
            minInput.type = "number";
            minInput.min = "0";
            minInput.value = "22";
            minInput.style.width = "50px";

            const secInput = document.createElement("input");
            secInput.type = "number";
            secInput.min = "0";
            secInput.max = "59";
            secInput.value = "0";
            secInput.style.width = "50px";

            const startPauseBtn = document.createElement("button");
            startPauseBtn.textContent = "Start";

            const resetBtn = document.createElement("button");
            resetBtn.textContent = "Reset";

            const alarmBtn = document.createElement("button");
            alarmBtn.textContent = "Alarm: ON";

            const deleteBtn = document.createElement("button");
            deleteBtn.textContent = "Delete";

            const display = document.createElement("span");
            display.style.marginLeft = "10px";
            display.textContent = "00:00";

            wrapper.appendChild(document.createTextNode("Cycle Timer ‚Äî "));
            wrapper.appendChild(labelInput);
            wrapper.appendChild(document.createTextNode("  M:"));
            wrapper.appendChild(minInput);
            wrapper.appendChild(document.createTextNode(" S:"));
            wrapper.appendChild(secInput);
            wrapper.appendChild(startPauseBtn);
            wrapper.appendChild(resetBtn);
            wrapper.appendChild(alarmBtn);
            wrapper.appendChild(deleteBtn);
            wrapper.appendChild(display);
            wrapper.appendChild(document.createElement("br"));
            wrapper.appendChild(document.createTextNode("Notes: "));
            wrapper.appendChild(noteInput);
            wrapper.appendChild(noteBtn);

            let interval = null;
            let remainingMs = 0;
            let running = false;
            let alarmOn = true;
            let originalMs = 0;

            function labelOrDefault() {
                return labelInput.value.trim() || `CycleTimer#${id.split("_")[1]}`;
            }

            function startTimer() {
                const mins = parseInt(minInput.value, 10) || 0;
                const secs = parseInt(secInput.value, 10) || 0;
                const totalMs = (mins * 60 + secs) * 1000;
                if (totalMs <= 0) {
                    logLineWithRoster("Extra cycle timer not started ‚Äî duration must be > 0.");
                    return;
                }
                originalMs = totalMs;
                remainingMs = totalMs;
                display.textContent = formatMs(remainingMs);
                wrapper.classList.remove("flash");

                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' started: ${mins}m ${secs}s.`);

                interval = setInterval(() => {
                    remainingMs -= 500;
                    if (remainingMs <= 0) {
                        remainingMs = 0;
                        display.textContent = "00:00";
                        clearInterval(interval);
                        interval = null;
                        running = false;
                        startPauseBtn.textContent = "Start";
                        wrapper.classList.add("flash");
                        const lbl = labelOrDefault();
                        logLineWithRoster(`Extra cycle timer '${lbl}' finished.`);
                        if (alarmOn) makeBeep();
                    } else {
                        display.textContent = formatMs(remainingMs);
                    }
                }, 500);
                running = true;
                startPauseBtn.textContent = "Pause";
            }

            function pauseTimer() {
                if (interval) {
                    clearInterval(interval);
                    interval = null;
                }
                running = false;
                startPauseBtn.textContent = "Continue";
                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' paused at ${formatMs(remainingMs)}.`);
            }

            function continueTimer() {
                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' continued.`);
                interval = setInterval(() => {
                    remainingMs -= 500;
                    if (remainingMs <= 0) {
                        remainingMs = 0;
                        display.textContent = "00:00";
                        clearInterval(interval);
                        interval = null;
                        running = false;
                        startPauseBtn.textContent = "Start";
                        wrapper.classList.add("flash");
                        const lbl = labelOrDefault();
                        logLineWithRoster(`Extra cycle timer '${lbl}' finished.`);
                        if (alarmOn) makeBeep();
                    } else {
                        display.textContent = formatMs(remainingMs);
                    }
                }, 500);
                running = true;
                startPauseBtn.textContent = "Pause";
            }

            startPauseBtn.addEventListener("click", () => {
                if (!running && remainingMs === 0) {
                    startTimer();
                } else if (running) {
                    pauseTimer();
                } else {
                    continueTimer();
                }
            });

            resetBtn.addEventListener("click", () => {
                if (interval) {
                    clearInterval(interval);
                    interval = null;
                }
                running = false;
                const mins = parseInt(minInput.value, 10) || 0;
                const secs = parseInt(secInput.value, 10) || 0;
                remainingMs = (mins * 60 + secs) * 1000;
                originalMs = remainingMs;
                display.textContent = formatMs(remainingMs);
                wrapper.classList.remove("flash");
                startPauseBtn.textContent = "Start";
                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' reset.`);
            });

            alarmBtn.addEventListener("click", () => {
                alarmOn = !alarmOn;
                alarmBtn.textContent = "Alarm: " + (alarmOn ? "ON" : "OFF");
                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' alarm turned ${alarmOn ? "ON" : "OFF"}.`);
            });

            deleteBtn.addEventListener("click", () => {
                const label = labelOrDefault();
                if (confirm(`Delete extra cycle timer '${label}'?`)) {
                    if (interval) clearInterval(interval);
                    delete timerRegistry[id];
                    wrapper.remove();
                    logLineWithRoster(`Extra cycle timer '${label}' deleted.`);
                    rebuildTimerRestartUI();
                }
            });

            noteBtn.addEventListener("click", () => {
                const label = labelOrDefault();
                const txt = noteInput.value.trim();
                if (!txt) {
                    logLineWithRoster(`Extra cycle timer '${label}' notes cleared.`);
                } else {
                    logLineWithRoster(`Extra cycle timer '${label}' notes updated: "${txt}"`);
                }
            });

            extraTimersContainer.appendChild(wrapper);

            timerRegistry[id] = {
                type: "cycle",
                labelFn: labelOrDefault,
                restartFn: () => {
                    if (interval) clearInterval(interval);
                    remainingMs = originalMs || ((parseInt(minInput.value, 10) || 0) * 60 + (parseInt(secInput.value, 10) || 0)) * 1000;
                    if (remainingMs <= 0) return;
                    display.textContent = formatMs(remainingMs);
                    wrapper.classList.remove("flash");
                    const label = labelOrDefault();
                    logLineWithRoster(`Extra cycle timer '${label}' restarted.`);
                    interval = setInterval(() => {
                        remainingMs -= 500;
                        if (remainingMs <= 0) {
                            remainingMs = 0;
                            display.textContent = "00:00";
                            clearInterval(interval);
                            interval = null;
                            running = false;
                            startPauseBtn.textContent = "Start";
                            wrapper.classList.add("flash");
                            const lbl = labelOrDefault();
                            logLineWithRoster(`Extra cycle timer '${lbl}' finished.`);
                            if (alarmOn) makeBeep();
                        } else {
                            display.textContent = formatMs(remainingMs);
                        }
                    }, 500);
                    running = true;
                    startPauseBtn.textContent = "Pause";
                },
                checkboxEl: null,
                buttonEl: null
            };
            rebuildTimerRestartUI();
        }

        function createStopwatchTimer() {
            const id = "stopwatch_" + (extraTimerIdCounter++);
            const wrapper = document.createElement("div");
            wrapper.className = "subtimer";
            wrapper.dataset.timerId = id;
            wrapper.dataset.type = "stopwatch";

            const labelInput = document.createElement("input");
            labelInput.type = "text";
            labelInput.placeholder = "Label (optional)";
            labelInput.style.width = "140px";

            const noteInput = document.createElement("input");
            noteInput.type = "text";
            noteInput.placeholder = "Notes";
            noteInput.style.width = "140px";

            const noteBtn = document.createElement("button");
            noteBtn.textContent = "Update Notes";

            const startBtn = document.createElement("button");
            startBtn.textContent = "Start";
            const stopBtn = document.createElement("button");
            stopBtn.textContent = "Stop";
            stopBtn.disabled = true;

            const deleteBtn = document.createElement("button");
            deleteBtn.textContent = "Delete";

            const display = document.createElement("span");
            display.style.marginLeft = "10px";
            display.textContent = "00:00";

            wrapper.appendChild(document.createTextNode("Stopwatch ‚Äî "));
            wrapper.appendChild(labelInput);
            wrapper.appendChild(startBtn);
            wrapper.appendChild(stopBtn);
            wrapper.appendChild(deleteBtn);
            wrapper.appendChild(display);
            wrapper.appendChild(document.createElement("br"));
            wrapper.appendChild(document.createTextNode("Notes: "));
            wrapper.appendChild(noteInput);
            wrapper.appendChild(noteBtn);

            let interval = null;
            let elapsedMs = 0;
            let startMs = null;

            function labelOrDefault() {
                return labelInput.value.trim() || `Stopwatch#${id.split("_")[1]}`;
            }

            startBtn.addEventListener("click", () => {
                if (interval) return;
                startMs = Date.now();
                startBtn.disabled = true;
                stopBtn.disabled = false;
                const label = labelOrDefault();
                logLineWithRoster(`Stopwatch '${label}' started.`);
                interval = setInterval(() => {
                    elapsedMs = Date.now() - startMs;
                    display.textContent = formatMs(elapsedMs);
                }, 500);
            });

            stopBtn.addEventListener("click", () => {
                if (!interval) return;
                clearInterval(interval);
                interval = null;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                const label = labelOrDefault();
                logLineWithRoster(`Stopwatch '${label}' stopped at ${formatMs(elapsedMs)}.`);
            });

            deleteBtn.addEventListener("click", () => {
                const label = labelOrDefault();
                if (confirm(`Delete stopwatch '${label}'?`)) {
                    if (interval) clearInterval(interval);
                    delete timerRegistry[id];
                    wrapper.remove();
                    logLineWithRoster(`Stopwatch '${label}' deleted.`);
                    rebuildTimerRestartUI();
                }
            });

            noteBtn.addEventListener("click", () => {
                const label = labelOrDefault();
                const txt = noteInput.value.trim();
                if (!txt) {
                    logLineWithRoster(`Stopwatch '${label}' notes cleared.`);
                } else {
                    logLineWithRoster(`Stopwatch '${label}' notes updated: "${txt}"`);
                }
            });

            extraTimersContainer.appendChild(wrapper);

            timerRegistry[id] = {
                type: "stopwatch",
                labelFn: labelOrDefault,
                restartFn: () => {
                    // stopwatches don't auto-restart on mob XP; no-op
                },
                checkboxEl: null,
                buttonEl: null
            };
            rebuildTimerRestartUI();
        }

        addCycleTimerBtn.addEventListener("click", createCycleTimer);
        addStopwatchBtn.addEventListener("click", createStopwatchTimer);

        // ---------- INIT ----------
        updateXpBar(0);
        updateGroupButtons();
        rebuildGroupMemberRows();
        registerMainMobTimer();

<!-- === SPELL TIMER SYSTEM: CLASS SELECTOR (BLOCK #1) === -->

// ===============================
// 1. CLASS AVAILABILITY FLAGS
// ===============================
// All classes start as unavailable (faded + disabled)
// When we add a class's spell list later, we will set SpellClassAvailable[CLASS] = true
SpellClassAvailable = {
    CLR: false,
    DRU: false,
    SHM: false,
    ENC: false,
    NEC: false,
    MAG: false,
    WIZ: false,
    BRD: false,
    RNG: false,
    ROG: false,
    PAL: false,
    SHD: false,
    WAR: false,
    MNK: false
};

// ===============================
// 2. CLASS SELECTION FLAGS
// ===============================
const SpellClassFlags = {
    CLR: false,
    DRU: false,
    SHM: false,
    ENC: false,
    NEC: false,
    MAG: false,
    WIZ: false,
    BRD: false,
    RNG: false,
    ROG: false,
    PAL: false,
    SHD: false,
    WAR: false,
    MNK: false
};
__DBG("past CLASS SELECTION FLAGS()544431111333");
// ===============================
// 3. CREATE SPELL TIMER SECTION UI
// ===============================
(function createSpellTimerClassSelector() {
    const container = document.createElement("div");
    container.id = "spellTimerClassSelector";
    container.style.marginTop = "25px";
    container.style.padding = "10px";
    container.style.border = "1px solid #666";
    container.style.background = "#222";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h3");
    title.textContent = "Spell Timer System ‚Äî Select Class";
    title.style.marginTop = "0";
    container.appendChild(title);

const classGrid = [
    // Row 1
    ["ENC", "Enchanter"], ["BRD", "Bard"], ["PAL", "Paladin"], ["CLR", "Cleric"],
    // Row 2
    ["MAG", "Magician"], ["MNK", "Monk"], ["SHD", "Shadow Knight"], ["DRU", "Druid"],
    // Row 3
    ["NEC", "Necromancer"], ["RNG", "Ranger"], ["WAR", "Warrior"], ["SHM", "Shaman"],
    // Row 4
    ["WIZ", "Wizard"], ["ROG", "Rogue"]
];


// Build a 4-column grid
const grid = document.createElement("div");
grid.style.display = "grid";
grid.style.gridTemplateColumns = "repeat(4, 1fr)";
grid.style.gap = "6px 12px";

classGrid.forEach(([code, label]) => {
    const cell = document.createElement("div");
    cell.style.display = "flex";
    cell.style.alignItems = "center";

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.disabled = true;
    checkbox.style.marginRight = "6px";
    checkbox.dataset.classCode = code;

    const text = document.createElement("span");
    text.textContent = label;
    text.style.opacity = "0.4";

    checkbox.addEventListener("change", () => {
        SpellClassFlags[code] = checkbox.checked;

        document.dispatchEvent(new CustomEvent("SpellClassSelectionChanged", {
            detail: { flags: SpellClassFlags }
        }));
    });

    cell.appendChild(checkbox);
    cell.appendChild(text);
    grid.appendChild(cell);
});

container.appendChild(grid);


    document.body.appendChild(container);
})();

// ===============================
// 4. FUNCTION TO ENABLE A CLASS LATER
// ===============================
// When we add a class's spell list, we call:
// enableSpellClass("NEC");
function enableSpellClass(classCode) {
    SpellClassAvailable[classCode] = true;

    const selector = document.querySelectorAll("#spellTimerClassSelector input[type='checkbox']");
    selector.forEach(cb => {
        if (cb.dataset.classCode === classCode) {
            cb.disabled = false;
            cb.nextSibling.style.opacity = "1.0"; // unfade label
        }
    });
}

    __DBG("b4ENTER: swooshLoadFromText()");
function swooshLoadFromText(text) {
    __DBG("ENTER: swooshLoadFromText()");
    const lines = text.split("\n");

    let endIndex = -1;
    let startIndex = -1;

    // ===============================
    // Find newest END
    // ===============================
    for (let i = lines.length - 1; i >= 0; i--) {
        if (lines[i].includes(SWOOSH_END)) {
            endIndex = i;
            __DBG("FOUND: SWOOSH_END at line " + i);
            break;
        }
    }
    if (endIndex === -1) {
        __DBG("ERROR: No SWOOSH_END found.");
        logLine("No swoosh block found.");
        return;
    }

    // ===============================
    // Find matching START
    // ===============================
    for (let j = endIndex - 1; j >= 0; j--) {
        if (lines[j].includes(SWOOSH_START)) {
            startIndex = j;
            __DBG("FOUND: SWOOSH_START at line " + j);
            break;
        }
    }
    if (startIndex === -1) {
        __DBG("ERROR: SWOOSH_END found but no SWOOSH_START.");
        logLine("Swoosh END found but no START marker.");
        return;
    }

    // ===============================
    // Extract JSON block
    // ===============================
    const swooshText = lines.slice(startIndex + 1, endIndex).join("\n");
    __DBG("EXTRACTED swooshText length=" + swooshText.length);

    let swoosh;
    try {
        swoosh = JSON.parse(swooshText);
        __DBG("PARSE OK: swoosh JSON loaded.");
    } catch (e) {
        __DBG("PARSE ERROR: " + e.message);
        logLine("Failed to parse swoosh block.");
        return;
    }

    // ===============================
    // Apply loaded data
    // ===============================
    __DBG("APPLY: Updating SpellRegistry, UserOverrides, UserCustomSpells, SpellClassAvailable");

    SpellRegistry = swoosh.registry || {};
    UserOverrides = swoosh.overrides || {};
    UserCustomSpells = swoosh.custom || {};
    SpellClassAvailable = swoosh.classes || {};
    __DBG("XXENTER: Apply loaded data");
    // ===============================
    // Restore Long Term Timers
    // ===============================
    if (swoosh.longTermTimers) {
        __DBG("APPLY: Restoring LongTermTimers");
        LongTermTimersAPI.loadAll(swoosh.longTermTimers);
        logLine("LTT Restored from Swoosh.");
    } else {
        __DBG("NOTE: No longTermTimers found in swoosh.");
    }

    // ===============================
    // Rebuild UI
    // ===============================
    rebuildSpellUI();

    if (typeof updateSwooshListUI === "function") {
        updateSwooshListUI(swoosh.timestamp);
    } else {
        __DBG("NOTE: updateSwooshListUI is not defined ‚Äî skipping UI update.");
    }

    logLine("Swoosh Load Complete.");
    __DBG("EXIT: swooshLoadFromText() ‚Äî COMPLETE");
}



function rebuildSpellUI() {
    // ===============================
    // 1. Remove all existing spell list UI blocks
    // ===============================
    const oldLists = document.querySelectorAll("[id$='SpellList']");
    oldLists.forEach(el => el.remove());

    // ===============================
    // 2. Re-enable classes based on swoosh database
    // ===============================
    for (const classCode in SpellClassAvailable) {
        if (SpellClassAvailable[classCode]) {
            enableSpellClass(classCode);
        }
    }

    // ===============================
    // 3. Rebuild spell lists from SpellRegistry
    // ===============================
    for (const classCode in SpellRegistry) {
        const spells = SpellRegistry[classCode];
        if (!spells) continue;

        // Create container
        const container = document.createElement("div");
        container.id = `${classCode.toLowerCase()}SpellList`;
        container.style.marginTop = "15px";
        container.style.padding = "10px";
        container.style.border = "1px solid #444";
        container.style.background = "#111";
        container.style.color = "white";
        container.style.borderRadius = "6px";

        // Title
        const title = document.createElement("h4");
        title.textContent = `${classCode} ‚Äî Spells`;
        title.style.marginTop = "0";
        container.appendChild(title);

        // Grid
        const grid = document.createElement("div");
        grid.style.display = "grid";
        grid.style.gridTemplateColumns = "repeat(3, 1fr)";
        grid.style.gap = "6px 20px";
        grid.style.marginTop = "10px";
        container.appendChild(grid);

        // Add spells
        spells.forEach(spell => {
            const cell = document.createElement("div");
            cell.style.display = "flex";
            cell.style.alignItems = "center";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.dataset.spellId = spell.id;
            checkbox.style.marginRight = "6px";

            const label = document.createElement("span");
            label.textContent = spell.name;

            cell.appendChild(checkbox);
            cell.appendChild(label);
            grid.appendChild(cell);

            checkbox.addEventListener("change", () => {
                if (checkbox.checked) {
                    createSpellTimerUI(spell, container.id);
                } else {
                    removeSpellTimerUI(spell.id);
                }
            });
        });

        document.body.appendChild(container);
    }

    logLine("Spell UI rebuilt from Swoosh database.");
}



<!-- === SPELL TIMER SYSTEM: NECROMANCER TEST SPELLS (BLOCK #2 ‚Äî UPGRADED) === -->

// ===============================
// NECROMANCER TEST SPELL DATA
// ===============================
// ===============================
// NECROMANCER SPELL DATA ‚Äî BLOCK 1
// Levels 1‚Äì4, 8‚Äì12, 16‚Äì20
// ===============================

window.SpellData_NEC = [

    // ===============================
    // LEVEL 1 SPELLS
    // ===============================

    {
        id: "NEC_DISEASE_CLOUD",
        name: "Disease Cloud",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 180,   // 30 ticks
        maxDurationSeconds: 360,   // 60 ticks
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 1,
        spellLevelMax: 1,
        notes: "Classic low-level disease DoT. Generates strong aggro.",
        description: "Deals 5 direct damage + 1 damage per tick for 30‚Äì60 ticks.",
    },

    {
        id: "NEC_INVIS_UNDEAD",
        name: "Invisibility vs Undead",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 180,    // 3 min @ L1
        maxDurationSeconds: 1620,   // 27 min @ L9+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 1,
        spellLevelMax: 9,
        notes: "Single-target invisibility vs undead. Must be grouped with target.",
        description: "Cloaks target in invisibility vs undead. Duration scales with level.",
    },

    {
        id: "NEC_MINOR_SHIELDING",
        name: "Minor Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1620,   // 27 minutes
        maxDurationSeconds: 1620,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 1,
        spellLevelMax: 1,
        notes: "Basic HP/AC buff.",
        description: "Increases max HP by 6‚Äì10 and AC by 3‚Äì4.",
    },

    {
        id: "NEC_SIPHON_STRENGTH",
        name: "Siphon Strength",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 180,   // 3 min @ L1
        maxDurationSeconds: 360,   // 6 min @ L2+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 1,
        spellLevelMax: 2,
        notes: "Drains STR from target and grants it to caster.",
        description: "Decreases target STR by 5‚Äì10 and increases caster STR by same amount.",
    },

    // ===============================
    // LEVEL 4 SPELLS
    // ===============================

    {
        id: "NEC_CLINGING_DARKNESS",
        name: "Clinging Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 12,   // 2 ticks
        maxDurationSeconds: 48,   // 8 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 4,
        spellLevelMax: 12,
        notes: "Low-level snare + DoT. Does not break early.",
        description: "Deals 5 damage per tick for 2‚Äì8 ticks and snares target 24‚Äì30%.",
    },

    {
        id: "NEC_ENDURE_COLD",
        name: "Endure Cold",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 180,
        maxDurationSeconds: 1620,
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 1,
        spellLevelMax: 9,
        notes: "Cold resist buff.",
        description: "Increases cold resistance by 11‚Äì20. Duration scales with level.",
    },

    {
        id: "NEC_FEAR",
        name: "Fear",
        class: "NEC",
        category: "Fear",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 4,
        spellLevelMax: 4,
        notes: "Classic fear. Breaks early on resist checks.",
        description: "Causes target to flee in terror for up to 18 seconds.",
    },

    {
        id: "NEC_GRIM_AURA",
        name: "Grim Aura",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 720,   // 12 min @ L4
        maxDurationSeconds: 1620,  // 27 min @ L9+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 4,
        spellLevelMax: 9,
        notes: "Does not stack with Firefist, Strength of Nature, Celestial Tranquility.",
        description: "Increases ATK by 7‚Äì10. Duration scales with level.",
    },

    {
        id: "NEC_NUMB_THE_DEAD",
        name: "Numb the Dead",
        class: "NEC",
        category: "Lull (Undead)",
        minDurationSeconds: 84,   // 1.4 min @ L4
        maxDurationSeconds: 120,  // 2 min @ L10
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 4,
        spellLevelMax: 10,
        notes: "Undead-only lull. Charisma affects success.",
        description: "Reduces undead aggro radius. Breaks on resist.",
    },

    {
        id: "NEC_POISON_BOLT",
        name: "Poison Bolt",
        class: "NEC",
        category: "DoT (Poison)",
        minDurationSeconds: 12,   // 2 ticks
        maxDurationSeconds: 42,   // 7 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 4,
        spellLevelMax: 12,
        notes: "Low-level poison DoT.",
        description: "Deals 6 direct damage + 5/tick for 2‚Äì7 ticks.",
    },

    // ===============================
    // LEVEL 8 SPELLS
    // ===============================

    {
        id: "NEC_DEADEYE",
        name: "Deadeye",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1440,  // 24 min @ L8
        maxDurationSeconds: 1620,  // 27 min @ L9
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 8,
        spellLevelMax: 9,
        notes: "Self-only See Invisible + Infravision.",
        description: "Grants infravision and see invisibility. Duration scales with level.",
    },

    {
        id: "NEC_GATHER_SHADOWS",
        name: "Gather Shadows",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1200,  // 20 minutes
        maxDurationSeconds: 1200,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 8,
        spellLevelMax: 8,
        notes: "Self invisibility.",
        description: "Casts invisibility on the caster for 20 minutes.",
    },

    {
        id: "NEC_IMPART_STRENGTH",
        name: "Impart Strength",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 360,
        maxDurationSeconds: 360,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 8,
        spellLevelMax: 8,
        notes: "Transfers 10 STR to target.",
        description: "Caster loses 10 STR; target gains 10 STR for 6 minutes.",
    },

    {
        id: "NEC_LESSER_SHIELDING",
        name: "Lesser Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1440,  // 24 min @ L8
        maxDurationSeconds: 1620,  // 27 min @ L9
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 8,
        spellLevelMax: 9,
        notes: "HP/AC buff.",
        description: "Increases HP by 20‚Äì30 and AC by 6‚Äì9.",
    },

    {
        id: "NEC_VAMPIRIC_EMBRACE",
        name: "Vampiric Embrace",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 108,   // 1.8 min @ L8
        maxDurationSeconds: 420,   // 7 min @ L60
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 8,
        spellLevelMax: 60,
        notes: "Adds lifetap proc to melee attacks.",
        description: "Grants a melee lifetap proc. Duration scales with level.",
    },

    // ===============================
    // LEVEL 12 SPELLS
    // ===============================

    {
        id: "NEC_ENDURE_DISEASE",
        name: "Endure Disease",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1620,
        maxDurationSeconds: 1620,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 12,
        spellLevelMax: 12,
        notes: "Disease resist buff.",
        description: "Increases disease resistance by 19‚Äì20 for 27 minutes.",
    },

    {
        id: "NEC_ENGULFING_DARKNESS",
        name: "Engulfing Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 60,   // 10 ticks
        maxDurationSeconds: 60,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 12,
        spellLevelMax: 12,
        notes: "Stronger snare + DoT upgrade.",
        description: "Deals 11/tick for 10 ticks and snares target by 40%.",
    },

    {
        id: "NEC_HEAT_BLOOD",
        name: "Heat Blood",
        class: "NEC",
        category: "DoT (Fire)",
        minDurationSeconds: 36,   // 6 ticks
        maxDurationSeconds: 60,   // 10 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 20,
        notes: "Classic fire DoT.",
        description: "Deals 17 damage per tick for 6‚Äì10 ticks.",
    },

    {
        id: "NEC_LEACH",
        name: "Leach",
        class: "NEC",
        category: "DoT (Drain)",
        minDurationSeconds: 36,   // 6 ticks
        maxDurationSeconds: 54,   // 9 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 20,
        notes: "Life drain DoT.",
        description: "Deals 8/tick and heals caster for 8/tick for 6‚Äì9 ticks.",
    },

    {
        id: "NEC_SCENT_OF_DUSK",
        name: "Scent of Dusk",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 204,   // 3.4 min @ L12
        maxDurationSeconds: 840,   // 14 min @ L65
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 65,
        notes: "Reduces fire, poison, and disease resist.",
        description: "Decreases fire/poison/disease resist by 7‚Äì9.",
    },

    {
        id: "NEC_SPOOK_THE_DEAD",
        name: "Spook the Dead",
        class: "NEC",
        category: "Fear (Undead)",
        minDurationSeconds: 6,   // 1 tick
        maxDurationSeconds: 18,  // 3 ticks
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 20,
        notes: "Undead-only fear.",
        description: "Fears undead for 1‚Äì3 ticks. Breaks early.",
    },

    {
        id: "NEC_WAVE_OF_ENFEEBLEMENT",
        name: "Wave of Enfeeblement",
        class: "NEC",
        category: "Debuff (AoE)",
        minDurationSeconds: 72,   // 12 ticks
        maxDurationSeconds: 120,  // 20 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 20,
        notes: "AoE STR debuff.",
        description: "Decreases STR by 11‚Äì15 for 12‚Äì20 ticks.",
    },

    // ===============================
    // LEVEL 16‚Äì20 SPELLS
    // ===============================

    {
        id: "NEC_BANSHEE_AURA",
        name: "Banshee Aura",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 252,   // 4.2 min @ L16
        maxDurationSeconds: 540,   // 9 min @ L40+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 16,
        spellLevelMax: 40,
        notes: "Damage shield. Requires pearl (not consumed).",
        description: "Damage shield that scales with level. Duration increases with level.",
    },

    {
        id: "NEC_HEART_FLUTTER",
        name: "Heart Flutter",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 72,   // 12 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 16,
        spellLevelMax: 24,
        notes: "DoT + STR/AC debuff.",
        description: "Deals 12/tick for 8‚Äì12 ticks and reduces STR/AC.",
    },

    {
        id: "NEC_HUNGRY_EARTH",
        name: "Hungry Earth",
        class: "NEC",
        category: "Root (Undead)",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 48,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "Undead-only root. Breaks on damage.",
        description: "Roots undead for 8 ticks and deals 26‚Äì75 damage.",
    },

    {
        id: "NEC_INFECTIOUS_CLOUD",
        name: "Infectious Cloud",
        class: "NEC",
        category: "DoT (AoE)",
        minDurationSeconds: 126,   // 21 ticks
        maxDurationSeconds: 126,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "AoE poison DoT.",
        description: "Deals 20 direct damage + 5/tick for 21 ticks.",
    },

    {
        id: "NEC_SHIELDING",
        name: "Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,   // 36 minutes
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "HP/AC/MR buff.",
        description: "Increases HP by 46‚Äì50, AC by 12‚Äì13, and MR by 13.",
    },

    {
        id: "NEC_SHIELDSKIN",
        name: "Shieldskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "Absorbs 27‚Äì55 damage. Consumes Cat's Eye Agate.",
        description: "Absorbs a small amount of damage. Lasts 36 minutes.",
    },

    {
        id: "NEC_SPIRIT_ARMOR",
        name: "Spirit Armor",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "AC buff.",
        description: "Increases AC by 11‚Äì13 for 36 minutes.",
    },

    {
        id: "NEC_ALLURE_OF_DEATH",
        name: "Allure of Death",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L20
        maxDurationSeconds: 780,   // 13 min @ L60
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 20,
        spellLevelMax: 60,
        notes: "Lich line. Does not stack with clarity. Stacks with bard mana songs.",
        description: "Drains 5 HP/tick and restores 4 mana/tick. Duration scales with level.",
    },

    {
        id: "NEC_DOMINATE_UNDEAD",
        name: "Dominate Undead",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 420,    // 7 min @ L20
        maxDurationSeconds: 1230,   // 20.5 min @ L65
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 20,
        spellLevelMax: 65,
        notes: "Charm undead up to level 32. Breaks randomly.",
        description: "Charms an undead creature for 7‚Äì20.5 minutes. Breaks early on resist checks.",
    },

    {
        id: "NEC_HARMSHIELD",
        name: "Harmshield",
        class: "NEC",
        category: "Buff (Invulnerability)",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 20,
        spellLevelMax: 20,
        notes: "Caster becomes immune to all damage but cannot attack or cast.",
        description: "Grants complete damage immunity for 18 seconds. Cannot attack or cast while active.",
    },

    {
        id: "NEC_SHADOW_COMPACT",
        name: "Shadow Compact",
        class: "NEC",
        category: "Heal (HP Transfer)",
        minDurationSeconds: 24,   // 4 ticks
        maxDurationSeconds: 24,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 20,
        spellLevelMax: 20,
        notes: "Transfers HP from caster to target over time.",
        description: "Caster loses 20 HP/tick while target is healed for 20 HP/tick for 4 ticks.",
    },

    {
        id: "NEC_SHADOW_VORTEX",
        name: "Shadow Vortex",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 0,     // Instant effect, no duration
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 20,
        spellLevelMax: 20,
        notes: "AC debuff that transfers AC to caster.",
        description: "Reduces target AC by 9‚Äì12 and grants the same amount to the caster.",
    },
// ===============================
// NECROMANCER SPELL DATA ‚Äî BLOCK 2
// Levels 24‚Äì29, 34‚Äì39
// ===============================

    // ===============================
    // LEVEL 24 SPELLS
    // ===============================

    {
        id: "NEC_INTENSIFY_DEATH",
        name: "Intensify Death",
        class: "NEC",
        category: "Buff (Pet)",
        minDurationSeconds: 0,
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Pet buff: increases attack speed, STR, and AC.",
        description: "Increases pet attack speed by 22‚Äì30%, STR by 26‚Äì33, and AC by 6‚Äì8.",
    },

    {
        id: "NEC_LEATHERSKIN",
        name: "Leatherskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,   // 36 minutes
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Absorbs 71‚Äì118 damage. Consumes a bloodstone.",
        description: "Absorbs a moderate amount of damage. Lasts 36 minutes.",
    },

    {
        id: "NEC_MAJOR_SHIELDING",
        name: "Major Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "HP/AC/MR buff.",
        description: "Increases HP by 69‚Äì75, AC by 16‚Äì18, and MR by 14.",
    },

    {
        id: "NEC_RESIST_COLD",
        name: "Resist Cold",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Cold resist buff.",
        description: "Increases cold resistance by 39‚Äì40 for 36 minutes.",
    },

    {
        id: "NEC_REST_THE_DEAD",
        name: "Rest the Dead",
        class: "NEC",
        category: "Lull (Undead)",
        minDurationSeconds: 0,   // Duration not meaningful; lull breaks on resist
        maxDurationSeconds: 0,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Undead-only lull. Charisma affects success.",
        description: "Reduces undead aggro radius. Breaks on resist.",
    },

    {
        id: "NEC_SCENT_OF_SHADOW",
        name: "Scent of Shadow",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 348,   // 5.8 min @ L24
        maxDurationSeconds: 840,   // 14 min @ L65
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 24,
        spellLevelMax: 65,
        notes: "Reduces fire, poison, and disease resist.",
        description: "Decreases fire/poison/disease resist by 14‚Äì18.",
    },

    {
        id: "NEC_SCREAMING_TERROR",
        name: "Screaming Terror",
        class: "NEC",
        category: "Mez",
        minDurationSeconds: 18,   // 3 ticks
        maxDurationSeconds: 18,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Short mez with a chance to memblur.",
        description: "Mesmerizes target for 3 ticks with a small chance to memblur.",
    },

    {
        id: "NEC_SHADOW_SIGHT",
        name: "Shadow Sight",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Ultravision buff.",
        description: "Grants ultravision for 36 minutes.",
    },

    // ===============================
    // LEVEL 29 SPELLS
    // ===============================

    {
        id: "NEC_BOIL_BLOOD",
        name: "Boil Blood",
        class: "NEC",
        category: "DoT (Fire)",
        minDurationSeconds: 96,   // 16 ticks
        maxDurationSeconds: 126,  // 21 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 29,
        spellLevelMax: 39,
        notes: "Efficient fire DoT.",
        description: "Deals 24 damage per tick for 16‚Äì21 ticks.",
    },

    {
        id: "NEC_DOOMING_DARKNESS",
        name: "Dooming Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 90,   // 15 ticks
        maxDurationSeconds: 96,   // 16 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 29,
        spellLevelMax: 39,
        notes: "Stronger snare + DoT upgrade.",
        description: "Deals 20/tick for 15‚Äì16 ticks and snares target by 49‚Äì60%.",
    },

    {
        id: "NEC_PANIC_THE_DEAD",
        name: "Panic the Dead",
        class: "NEC",
        category: "Fear (Undead)",
        minDurationSeconds: 54,   // 9 ticks
        maxDurationSeconds: 54,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 29,
        spellLevelMax: 29,
        notes: "Undead-only fear.",
        description: "Fears undead for 9 ticks. Breaks early.",
    },

    {
        id: "NEC_VAMPIRIC_CURSE",
        name: "Vampiric Curse",
        class: "NEC",
        category: "DoT (Drain)",
        minDurationSeconds: 54,   // 9 ticks
        maxDurationSeconds: 54,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 29,
        spellLevelMax: 29,
        notes: "Life drain DoT.",
        description: "Deals 21/tick and heals caster for 21/tick for 9 ticks.",
    },

    // ===============================
    // LEVEL 34 SPELLS
    // ===============================

    {
        id: "NEC_BEGUILE_UNDEAD",
        name: "Beguile Undead",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 660,   // 11 min
        maxDurationSeconds: 1200,  // 20 min
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 34,
        spellLevelMax: 60,
        notes: "Charm undead up to level 51. Breaks randomly.",
        description: "Charms undead for 11‚Äì20 minutes. Breaks early on resist.",
    },

    {
        id: "NEC_CALL_OF_BONES",
        name: "Call of Bones",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L34
        maxDurationSeconds: 780,   // 13 min @ L60
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 34,
        spellLevelMax: 60,
        notes: "Lich line. Skeleton illusion.",
        description: "Drains 10 HP/tick and restores 8 mana/tick. Duration scales with level.",
    },

    {
        id: "NEC_GREATER_SHIELDING",
        name: "Greater Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "HP/AC/MR buff.",
        description: "Increases HP by 94‚Äì100, AC by 21‚Äì30, and MR by 16.",
    },

    {
        id: "NEC_INVOKE_FEAR",
        name: "Invoke Fear",
        class: "NEC",
        category: "Fear",
        minDurationSeconds: 42,   // 7 ticks
        maxDurationSeconds: 42,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Standard fear spell.",
        description: "Fears target for 7 ticks. Breaks early.",
    },

    {
        id: "NEC_RESIST_DISEASE",
        name: "Resist Disease",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Disease resist buff.",
        description: "Increases disease resistance by 40 for 36 minutes.",
    },

    {
        id: "NEC_ROOT",
        name: "Root",
        class: "NEC",
        category: "Root",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 48,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Breaks on direct damage.",
        description: "Roots target for 8 ticks. Breaks early on damage.",
    },

    {
        id: "NEC_STEELSKIN",
        name: "Steelskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Absorbs 168‚Äì230 damage. Consumes a jasper.",
        description: "Absorbs a large amount of damage. Lasts 36 minutes.",
    },

    {
        id: "NEC_SURGE_OF_ENFEEBLEMENT",
        name: "Surge of Enfeeblement",
        class: "NEC",
        category: "Debuff (PBAoE)",
        minDurationSeconds: 600,   // 100 ticks
        maxDurationSeconds: 600,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Large-radius STR debuff.",
        description: "Decreases STR by 22‚Äì30 for 100 ticks.",
    },

    {
        id: "NEC_VENOM_OF_THE_SNAKE",
        name: "Venom of the Snake",
        class: "NEC",
        category: "DoT (Poison)",
        minDurationSeconds: 42,   // 7 ticks
        maxDurationSeconds: 48,   // 8 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 34,
        spellLevelMax: 39,
        notes: "Strong poison DoT.",
        description: "Deals 40 direct + 59/tick for 7‚Äì8 ticks.",
    },

    // ===============================
    // LEVEL 39 SPELLS
    // ===============================

    {
        id: "NEC_AUGMENT_DEATH",
        name: "Augment Death",
        class: "NEC",
        category: "Buff (Pet)",
        minDurationSeconds: 0,
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 39,
        spellLevelMax: 39,
        notes: "Major pet buff.",
        description: "Increases pet attack speed by 49‚Äì55%, STR by 39‚Äì45, and AC by 10‚Äì12.",
    },

    {
        id: "NEC_CHILLING_EMBRACE",
        name: "Chilling Embrace",
        class: "NEC",
        category: "DoT (Poison)",
        minDurationSeconds: 96,   // 16 ticks
        maxDurationSeconds: 96,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 39,
        spellLevelMax: 39,
        notes: "Velious-era poison DoT.",
        description: "Deals 40 damage per tick for 16 ticks.",
    },

    {
        id: "NEC_SCENT_OF_DARKNESS",
        name: "Scent of Darkness",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 0,   // Duration not meaningful
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 39,
        spellLevelMax: 39,
        notes: "Reduces fire, poison, and disease resist.",
        description: "Decreases fire/poison/disease resist by 24‚Äì27.",
    },

    {
        id: "NEC_SCOURGE",
        name: "Scourge",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 126,   // 21 ticks
        maxDurationSeconds: 126,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 39,
        spellLevelMax: 39,
        notes: "Strong disease DoT.",
        description: "Deals 40 direct + 24/tick for 21 ticks.",
    },
// ===============================
// NECROMANCER SPELL DATA ‚Äî BLOCK 3
// Levels 44‚Äì49, 50‚Äì60
// ===============================

    // ===============================
    // LEVEL 44 SPELLS
    // ===============================

    {
        id: "NEC_ARCH_SHIELDING",
        name: "Arch Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,   // 36 minutes
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 44,
        spellLevelMax: 44,
        notes: "High-tier HP/AC/MR buff.",
        description: "Increases HP by 144‚Äì150, AC by 25‚Äì36, and MR by 20.",
    },

    {
        id: "NEC_ASYSTOLE",
        name: "Asystole",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 60,   // 10 ticks
        maxDurationSeconds: 60,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 44,
        spellLevelMax: 44,
        notes: "Strong STR/AC debuff + DoT.",
        description: "Deals 69/tick for 10 ticks and reduces STR by 37‚Äì40 and AC by 16‚Äì18.",
    },

    {
        id: "NEC_DEAD_MAN_FLOATING",
        name: "Dead Man Floating",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 44,
        spellLevelMax: 44,
        notes: "Levitation + see invis + water breathing + poison resist.",
        description: "Grants levitation, see invis, water breathing, and +64‚Äì70 poison resist.",
    },

    {
        id: "NEC_DIAMONDSKIN",
        name: "Diamondskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 44,
        spellLevelMax: 44,
        notes: "Absorbs 245‚Äì394 damage. Consumes a peridot.",
        description: "Large damage absorb shield lasting 36 minutes.",
    },

    // ===============================
    // LEVEL 49 SPELLS
    // ===============================

    {
        id: "NEC_BOND_OF_DEATH",
        name: "Bond of Death",
        class: "NEC",
        category: "DoT (Drain)",
        minDurationSeconds: 54,   // 9 ticks
        maxDurationSeconds: 54,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "Strong life-drain DoT.",
        description: "Deals 80/tick and heals caster for 80/tick for 9 ticks.",
    },

    {
        id: "NEC_CAJOLLE_UNDEAD",
        name: "Cajole Undead",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 900,   // 15 min
        maxDurationSeconds: 1140,  // 19 min
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 49,
        spellLevelMax: 60,
        notes: "Charms undead up to level 51. Breaks randomly.",
        description: "Charms undead for 15‚Äì19 minutes. Breaks early on resist.",
    },

    {
        id: "NEC_CASCADING_DARKNESS",
        name: "Cascading Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 96,   // 16 ticks
        maxDurationSeconds: 96,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "High-level snare + DoT.",
        description: "Deals 72/tick for 16 ticks and snares target by 60%.",
    },

    {
        id: "NEC_DEAD_MEN_FLOATING",
        name: "Dead Men Floating",
        class: "NEC",
        category: "Buff (Group)",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "Group version of Dead Man Floating.",
        description: "Applies Dead Man Floating to the entire group.",
    },

    {
        id: "NEC_IGNITE_BLOOD",
        name: "Ignite Blood",
        class: "NEC",
        category: "DoT (Fire)",
        minDurationSeconds: 126,   // 21 ticks
        maxDurationSeconds: 126,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "High-efficiency fire DoT.",
        description: "Deals 56/tick for 21 ticks.",
    },

    {
        id: "NEC_LICH",
        name: "Lich",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L49
        maxDurationSeconds: 780,   // 13 min @ L60
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 49,
        spellLevelMax: 60,
        notes: "Lich line. Bloody skeleton illusion.",
        description: "Drains 22 HP/tick and restores 20 mana/tick. Duration scales with level.",
    },

    {
        id: "NEC_PARALYZING_EARTH",
        name: "Paralyzing Earth",
        class: "NEC",
        category: "Root",
        minDurationSeconds: 180,   // 30 ticks
        maxDurationSeconds: 180,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "Long-duration root. Breaks on direct damage.",
        description: "Roots target for 30 ticks. Breaks early on damage.",
    },

    // ===============================
    // LEVEL 50 SPELLS
    // ===============================

    {
        id: "NEC_IMPROVED_INVIS_UNDEAD",
        name: "Improved Invis vs Undead",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 180,   // 3 min @ L1
        maxDurationSeconds: 1620,  // 27 min @ L9+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 1,
        spellLevelMax: 9,
        notes: "Improved invisibility vs undead.",
        description: "Grants invisibility vs undead. Duration scales with level.",
    },

    // ===============================
    // LEVEL 51 SPELLS
    // ===============================

    {
        id: "NEC_DREAD_OF_NIGHT",
        name: "Dread of Night",
        class: "NEC",
        category: "Fear (Undead)",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 48,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 51,
        notes: "Undead-only fear.",
        description: "Fears undead for 8 ticks. Breaks early.",
    },

    {
        id: "NEC_ENVENOMED_BOLT",
        name: "Envenomed Bolt",
        class: "NEC",
        category: "DoT (Poison)",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 48,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 51,
        notes: "High-damage poison DoT.",
        description: "Deals 110 direct damage, then 146/tick for 8 ticks.",
    },

    {
        id: "NEC_SPLURT",
        name: "Splurt",
        class: "NEC",
        category: "DoT (Magic)",
        minDurationSeconds: 102,   // 17 ticks
        maxDurationSeconds: 102,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 51,
        notes: "Damage increases every tick.",
        description: "Starts at 11 damage and increases by 12 each tick for 17 ticks.",
    },

    // ===============================
    // LEVEL 52 SPELLS
    // ===============================

    {
        id: "NEC_MANASKIN",
        name: "Manaskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 52,
        notes: "Absorbs 521‚Äì600 damage. Adds +1 mana regen.",
        description: "Large damage absorb shield with mana regen.",
    },

    {
        id: "NEC_PLAGUE",
        name: "Plague",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 132,   // 22 ticks
        maxDurationSeconds: 132,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 52,
        notes: "Long-duration disease DoT.",
        description: "Deals 60 direct damage, then 55/tick for 22 ticks.",
    },

    {
        id: "NEC_SCENT_OF_TERRIS",
        name: "Scent of Terris",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 0,
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 52,
        notes: "High-tier resist debuff.",
        description: "Decreases fire/poison/disease resist by 33‚Äì36.",
    },

    // ===============================
    // LEVEL 53 SPELLS
    // ===============================

    {
        id: "NEC_ENSTILL",
        name: "Enstill",
        class: "NEC",
        category: "Root",
        minDurationSeconds: 96,   // 16 ticks
        maxDurationSeconds: 96,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 53,
        spellLevelMax: 53,
        notes: "Breaks on direct damage.",
        description: "Roots target for 16 ticks. Breaks early on damage.",
    },

    // ===============================
    // LEVEL 54 SPELLS
    // ===============================

    {
        id: "NEC_SHIELD_OF_THE_MAGI",
        name: "Shield of the Magi",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 54,
        notes: "High-tier HP/AC/MR buff.",
        description: "Increases HP by 232‚Äì250, AC by 29‚Äì31, and MR by 22‚Äì24.",
    },

    {
        id: "NEC_THRALL_OF_BONES",
        name: "Thrall of Bones",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 1020,   // 17 min
        maxDurationSeconds: 1200,   // 20 min
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 54,
        spellLevelMax: 60,
        notes: "Charms undead up to level 53.",
        description: "Charms undead for 17‚Äì20 minutes. Breaks early.",
    },

    // ===============================
    // LEVEL 55 SPELLS
    // ===============================

    {
        id: "NEC_AUGMENTATION_OF_DEATH",
        name: "Augmentation of Death",
        class: "NEC",
        category: "Buff (Pet)",
        minDurationSeconds: 0,
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 55,
        notes: "Major pet buff.",
        description: "Increases pet attack speed by 65%, STR by 52‚Äì55, and AC by 14‚Äì15.",
    },

    {
        id: "NEC_SKIN_OF_THE_SHADOW",
        name: "Skin of the Shadow",
        class: "NEC",
        category: "Utility",
        minDurationSeconds: 0,   // Night-only effect
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 55,
        notes: "Night-only invisibility + ultravision.",
        description: "Grants invisibility, ultravision, and increased sight range at night.",
    },

    // ===============================
    // LEVEL 56 SPELLS
    // ===============================

    {
        id: "NEC_CESSATION_OF_COR",
        name: "Cessation of Cor",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 66,   // 11 ticks
        maxDurationSeconds: 66,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 56,
        spellLevelMax: 56,
        notes: "High-damage disease DoT.",
        description: "Deals 100/tick for 11 ticks and reduces STR by 50 and AC by 19‚Äì21.",
    },

    {
        id: "NEC_TREPIDATION",
        name: "Trepidation",
        class: "NEC",
        category: "Fear",
        minDurationSeconds: 36,   // 6 ticks
        maxDurationSeconds: 36,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 56,
        spellLevelMax: 56,
        notes: "Standard fear spell.",
        description: "Fears target for 6 ticks. Breaks early.",
    },

    // ===============================
    // LEVEL 57 SPELLS
    // ===============================

    {
        id: "NEC_VEXING_MORDINIA",
        name: "Vexing Mordinia",
        class: "NEC",
        category: "DoT (Drain)",
        minDurationSeconds: 60,   // 10 ticks
        maxDurationSeconds: 60,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 57,
        spellLevelMax: 57,
        notes: "High-level life-drain DoT.",
        description: "Deals 122/tick for 10 ticks and heals caster for 122/tick (9 ticks).",
    },

    // ===============================
    // LEVEL 58 SPELLS
    // ===============================

    {
        id: "NEC_IMMOBILIZE",
        name: "Immobilize",
        class: "NEC",
        category: "Root",
        minDurationSeconds: 60,   // 10 ticks
        maxDurationSeconds: 60,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 58,
        notes: "Breaks on direct damage.",
        description: "Roots target for 10 ticks. Breaks early on damage.",
    },

    {
        id: "NEC_PYROCRUOR",
        name: "Pyrocruor",
        class: "NEC",
        category: "DoT (Fire)",
        minDurationSeconds: 114,   // 19 ticks
        maxDurationSeconds: 114,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 58,
        notes: "High-damage fire DoT.",
        description: "Deals 111/tick for 19 ticks.",
    },

    {
        id: "NEC_QUIVERING_VEIL_OF_XARN",
        name: "Quivering Veil of Xarn",
        class: "NEC",
        category: "Buff (Invulnerability)",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 58,
        notes: "Heals 150 HP and grants 18 seconds of invulnerability.",
        description: "Heals caster for 150 and grants 18 seconds of damage immunity.",
    },

    // ===============================
    // LEVEL 59 SPELLS
    // ===============================

    {
        id: "NEC_DEVOURING_DARKNESS",
        name: "Devouring Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 78,   // 13 ticks
        maxDurationSeconds: 78,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 59,
        spellLevelMax: 59,
        notes: "High-level snare + DoT.",
        description: "Deals 107/tick for 13 ticks and snares target by 69‚Äì70%.",
    },

    // ===============================
    // LEVEL 60 SPELLS
    // ===============================

    {
        id: "NEC_ARCH_LICH",
        name: "Arch Lich",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L60 minimum scaling
        maxDurationSeconds: 780,   // 13 min @ L60 (max scaling)
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 60,
        spellLevelMax: 60,
        notes: "Top-tier lich form. Spectre illusion. Does not stack with clarity.",
        description: "Drains 20 HP/tick and restores 20 mana/tick. Grants spectre illusion.",
    },

    {
        id: "NEC_DEMI_LICH",
        name: "Demi Lich",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L60 minimum scaling
        maxDurationSeconds: 780,   // 13 min @ L60 (max scaling)
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 60,
        spellLevelMax: 60,
        notes: "High-tier lich form. Bloody skeleton illusion. Does not stack with clarity.",
        description: "Drains 48 HP/tick and restores 31 mana/tick. Grants bloody skeleton illusion.",
    },

    {
        id: "NEC_ENSLAVE_DEATH",
        name: "Enslave Death",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 30,   // 5 ticks
        maxDurationSeconds: 30,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
        notes: "Very short-duration but extremely powerful undead charm.",
        description: "Charms undead for 5 ticks. Very difficult to resist but breaks early.",
    },

]; // 






// ===============================
// NECROMANCER SPELL LIST UI
// ===============================
// ===============================
// NECROMANCER SPELL LIST UI (GRID LIKE CLASS SELECTOR)
// ===============================
(function loadNecromancerSpellList() {

    const container = document.createElement("div");
    container.id = "necSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Necromancer ‚Äî Spell List";
    title.style.marginTop = "0";
    container.appendChild(title);

    // Create a grid wrapper EXACTLY like class selector
    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)"; // 3 columns
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    // Add each spell as a grid cell
    SpellData_NEC.forEach(spell => {

        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        // When checked ‚Üí create timer
        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "necSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();


// ===============================
// ROGUE DISCIPLINE DATA
// ===============================
window.SpellData_ROG = [
    {
        id: "ROG_RESISTANT",
        name: "Resistant Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300, // patch note: increased to 5 min
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 30,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+3 to +10 all resists depending on level.",
        description: "Grants resistance to all magic types."
    },
    {
        id: "ROG_FEARLESS",
        name: "Fearless Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 40,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "ROG_COUNTERATTACK",
        name: "Counterattack Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 9,
        maxDurationSeconds: 9,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 53,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Ripostes every incoming blow.",
        description: "Perfectly times counterattacks, riposting all incoming hits."
    },
    {
        id: "ROG_DEADEYE",
        name: "Deadeye Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Greatly increases hit rate.",
        description: "Focuses vision to vastly increase hit accuracy."
    },
    {
        id: "ROG_NIMBLE",
        name: "Nimble Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Avoids most attacks.",
        description: "Increases combat reflexes, avoiding most melee attacks."
    },
    {
        id: "ROG_KINESTHETICS",
        name: "Kinesthetics Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 57,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Dual wield + double attack every round.",
        description: "Increases combat sense, enabling dual wield and double attack each round."
    },
    {
        id: "ROG_BLINDING_SPEED",
        name: "Blinding Speed Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Increases attack speed.",
        description: "Focuses energy into arms, increasing attack speed."
    },
    {
        id: "ROG_DUELIST",
        name: "Duelist Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 59,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "100% melee damage increase.",
        description: "Doubles all melee damage for the duration."
    }
];

// ===============================
// ROGUE DISCIPLINE LIST UI
// ===============================
(function loadRogueDisciplineList() {

    const container = document.createElement("div");
    container.id = "rogSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Rogue ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_ROG.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "rogSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// WARRIOR DISCIPLINE DATA
// ===============================
window.SpellData_WAR = [
    {
        id: "WAR_RESISTANT",
        name: "Resistant Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 30,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+20 all resists.",
        description: "Grants +20 to all resistances."
    },
    {
        id: "WAR_FEARLESS",
        name: "Fearless Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 40,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "WAR_EVASIVE",
        name: "Evasive Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 60,
	reuseSeconds: 420,
        notes: "50% increased avoidance.",
        description: "Increases chance to avoid attacks by 50%."
    },
    {
        id: "WAR_CHARGE",
        name: "Charge Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 14,
        maxDurationSeconds: 14,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 53,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Increases hit chance.",
        description: "Increases accuracy of all melee attacks."
    },
    {
        id: "WAR_MIGHTY_STRIKE",
        name: "Mighty Strike Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 10,
        maxDurationSeconds: 10,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "All attacks crit.",
        description: "Causes every melee attack to land as a critical hit."
    },
    {
        id: "WAR_DEFENSIVE",
        name: "Defensive Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 600,
        notes: "Reduces DI by 50%.",
        description: "Reduces incoming damage interval by 50%."
    },
    {
        id: "WAR_FURIOUS",
        name: "Furious Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 9,
        maxDurationSeconds: 9,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 56,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Ripostes all attacks.",
        description: "Ripostes every incoming blow."
    },
    {
        id: "WAR_PRECISION",
        name: "Precision Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 57,
        spellLevelMax: 60,
	reuseSeconds: 1620,
        notes: "Increases hit rate.",
        description: "Increases hit rate significantly."
    },
    {
        id: "WAR_FELSTRIKE",
        name: "Felstrike Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Increases melee damage.",
        description: "Increases melee damage output."
    },
    {
        id: "WAR_FORTITUDE",
        name: "Fortitude Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 8,
        maxDurationSeconds: 8,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 59,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Increases avoidance.",
        description: "Increases chance to evade attacks."
    },
    {
        id: "WAR_AGGRESSIVE",
        name: "Aggressive Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 1620,
        notes: "+30% damage, take more damage.",
        description: "Increases damage output by 30% but increases damage taken."
    }
];

// ===============================
// WARRIOR DISCIPLINE LIST UI
// ===============================
(function loadWarriorDisciplineList() {

    const container = document.createElement("div");
    container.id = "warSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Warrior ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_WAR.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "warSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// MONK DISCIPLINE DATA
// ===============================
window.SpellData_MNK = [
    {
        id: "MNK_RESISTANT",
        name: "Resistant Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 30,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "+3 to +10 all resists.",
        description: "Grants resistance to all magic types."
    },
    {
        id: "MNK_FEARLESS",
        name: "Fearless Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 40,
        spellLevelMax: 60,
	reuseSeconds: 2400,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "MNK_STONESTANCE",
        name: "Stonestance Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 240,
        notes: "60% melee damage reduction.",
        description: "Greatly decreases melee damage taken."
    },
    {
        id: "MNK_THUNDERKICK",
        name: "Thunderkick Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 180, // next flying kick or 3 min
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 60,
	reuseSeconds: 240,
        notes: "Empowers next Flying Kick.",
        description: "Focuses energy into feet for a powerful Flying Kick."
    },
    {
        id: "MNK_WHIRLWIND",
        name: "Whirlwind Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 9,
        maxDurationSeconds: 9,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 53,
        spellLevelMax: 60,
	reuseSeconds: 3180,
        notes: "Ripostes all attacks.",
        description: "Ripostes every attack from the front."
    },
    {
        id: "MNK_VOIDDANCE",
        name: "Voiddance Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 8,
        maxDurationSeconds: 8,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3240,
        notes: "Avoids all melee attacks.",
        description: "Allows avoidance of all melee attacks from any angle."
    },
    {
        id: "MNK_INNERFLAME",
        name: "Innerflame Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 56,
        spellLevelMax: 60,
	reuseSeconds: 1560,
        notes: "100% melee damage increase.",
        description: "Greatly increases melee damage output."
    },
    {
        id: "MNK_HUNDRED_FISTS",
        name: "Hundred Fists Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 15,
        maxDurationSeconds: 15,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 57,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Increased attack speed.",
        description: "Increases attack rate and damage."
    },
    {
        id: "MNK_SILENTFIST",
        name: "Silentfist Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 59,
        spellLevelMax: 60,
	reuseSeconds: 480,
        notes: "Empowers next Dragon Punch.",
        description: "Focuses rage into hands for a powerful Dragon Punch."
    },
    {
        id: "MNK_ASHENHAND",
        name: "Ashenhand Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Empowers next Eagle Strike.",
        description: "Focuses energy into hands for a powerful Eagle Strike."
    }
];

// ===============================
// MONK DISCIPLINE LIST UI
// ===============================
(function loadMonkDisciplineList() {

    const container = document.createElement("div");
    container.id = "mnkSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Monk ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    // Grid wrapper
    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    // Add each discipline
    SpellData_MNK.forEach(spell => {

        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "mnkSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

<!-- === SPELL TIMER SYSTEM: RANGER TEST SPELLS (BLOCK #3) === -->

// ===============================
// RANGER TEST SPELL DATA
// ===============================
// ===============================
// RANGER DISCIPLINE DATA
// ===============================
window.SpellData_RNG = [
    {
        id: "RNG_RESISTANT",
        name: "Resistant Discipline",
        class: "RNG",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300, // patch note: increased to 5 min
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+10 all resists.",
        description: "Increases all resistances by 10."
    },
    {
        id: "RNG_FEARLESS",
        name: "Fearless Discipline",
        class: "RNG",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "RNG_TRUESHOT",
        name: "Trueshot Discipline",
        class: "RNG",
        category: "Discipline",
        minDurationSeconds: 120,
        maxDurationSeconds: 120,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "+105% bow damage, +accuracy.",
        description: "Imbues bow with energy, increasing damage and accuracy."
    },
    {
        id: "RNG_WEAPON_SHIELD",
        name: "Weapon Shield Discipline",
        class: "RNG",
        category: "Discipline",
        minDurationSeconds: 20,
        maxDurationSeconds: 20,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Parry all frontal melee attacks.",
        description: "Allows parrying of all melee attacks from the front."
    }
];


// ===============================
// RANGER SPELL LIST UI
// ===============================
// ===============================
// RANGER DISCIPLINE LIST UI
// ===============================
(function loadRangerDisciplineList() {

    const container = document.createElement("div");
    container.id = "rngSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Ranger ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_RNG.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "rngSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// SHADOW KNIGHT DISCIPLINE DATA
// ===============================
window.SpellData_SHD = [
    {
        id: "SHD_RESISTANT",
        name: "Resistant Discipline",
        class: "SHD",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+10 all resists.",
        description: "Increases all resistances by 10."
    },
    {
        id: "SHD_FEARLESS",
        name: "Fearless Discipline",
        class: "SHD",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "SHD_UNHOLY_AURA",
        name: "Unholy Aura Discipline",
        class: "SHD",
        category: "Discipline",
        minDurationSeconds: 180, // Next Harm Touch or 3 min
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "+50% Harm Touch damage, nearly unresistable.",
        description: "Empowers Harm Touch with increased damage and resist adjust."
    },
    {
        id: "SHD_LEECHCURSE",
        name: "Leechcurse Discipline",
        class: "SHD",
        category: "Discipline",
        minDurationSeconds: 20,
        maxDurationSeconds: 20,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Heal for every melee hit.",
        description: "Converts melee damage dealt into healing."
    }
];

// ===============================
// SHADOW KNIGHT DISCIPLINE LIST UI
// ===============================
(function loadShadowKnightDisciplineList() {

    const container = document.createElement("div");
    container.id = "shdSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Shadow Knight ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_SHD.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "shdSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// PALADIN DISCIPLINE DATA
// ===============================
window.SpellData_PAL = [
    {
        id: "PAL_RESISTANT",
        name: "Resistant Discipline",
        class: "PAL",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+10 all resists.",
        description: "Increases all resistances by 10."
    },
    {
        id: "PAL_FEARLESS",
        name: "Fearless Discipline",
        class: "PAL",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "PAL_HOLYFORGE",
        name: "Holyforge Discipline",
        class: "PAL",
        category: "Discipline",
        minDurationSeconds: 120,
        maxDurationSeconds: 300, // patch note: increased to 5 min
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Crits vs all, crippling vs undead.",
        description: "Increases critical hit chance and crippling blows vs undead."
    },
    {
        id: "PAL_SANCTIFICATION",
        name: "Sanctification Discipline",
        class: "PAL",
        category: "Discipline",
        minDurationSeconds: 15,
        maxDurationSeconds: 15,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "100% spell resist.",
        description: "Resists all spells that are not unresistable."
    }
];

// ===============================
// PALADIN DISCIPLINE LIST UI
// ===============================
(function loadPaladinDisciplineList() {

    const container = document.createElement("div");
    container.id = "palSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Paladin ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_PAL.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "palSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// BARD DISCIPLINE DATA
// ===============================
window.SpellData_BRD = [
    {
        id: "BRD_RESISTANT",
        name: "Resistant Discipline",
        class: "BRD",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300, // patch note: increased to 5 minutes
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+10 all resists. Bard must stop singing before activating.",
        description: "Increases all resistances by 10. Cancels if songs are active."
    },
    {
        id: "BRD_FEARLESS",
        name: "Fearless Discipline",
        class: "BRD",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear. Bard must stop singing before activating.",
        description: "Grants immunity to fear effects. Cancels if songs are active."
    },
    {
        id: "BRD_DEFTDANCE",
        name: "Deftdance Discipline",
        class: "BRD",
        category: "Discipline",
        minDurationSeconds: 15, // patch note: increased to 15 seconds
        maxDurationSeconds: 15,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Auto-dodge frontal attacks + auto dual-wield. Bard must stop singing.",
        description: "Allows automatic dodging of frontal attacks and auto dual-wield."
    },
    {
        id: "BRD_PURETONE",
        name: "Puretone Discipline",
        class: "BRD",
        category: "Discipline",
        minDurationSeconds: 240, // patch note: increased to 4 minutes
        maxDurationSeconds: 240,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Acts as best instrument of every type (28 mod). Works on singing mod.",
        description: "Makes all songs behave as if using the best instrument of each type."
    }
];

// ===============================
// BARD DISCIPLINE LIST UI
// ===============================
(function loadBardDisciplineList() {

    const container = document.createElement("div");
    container.id = "brdSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Bard ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    // Grid wrapper
    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    // Add each discipline
    SpellData_BRD.forEach(spell => {

        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "brdSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

__DBG("past BARD DISCIPLINE LIST UI()66644431111333");
// ===============================
// SPELL REGISTRY BOOTSTRAPPER (FULLY INSTRUMENTED)
// ===============================

__DBG("ENTER: SPELL REGISTRY BOOTSTRAPPER");

//window.SpellRegistry = {};
//window.UserOverrides = {};
//window.UserCustomSpells = [];
//window.SpellClassAvailable = {};

//let SpellRegistry = window.SpellRegistry;
//let UserOverrides = window.UserOverrides;
//let UserCustomSpells = window.UserCustomSpells;
//let SpellClassAvailable = window.SpellClassAvailable;


(function bootstrapSpellRegistry() {
    __DBG("ENTER: bootstrapSpellRegistry()");

    let foundClasses = 0;
    let skippedNonArrays = 0;
    let skippedInvalidSpells = 0;

    for (const key in window) {

        // Only process SpellData_*
        if (!key.startsWith("SpellData_")) {
            continue;
        }

        __DBG("FOUND SpellData KEY: " + key);

        const classCode = key.replace("SpellData_", "");
        const spellArray = window[key];

        // Validate array
        if (!Array.isArray(spellArray)) {
            __DBG("SKIP: " + key + " is NOT an array.");
            skippedNonArrays++;
            continue;
        }

        __DBG("PASS: " + key + " is a valid spell array.");
        foundClasses++;

        // Mark class as available
        SpellClassAvailable[classCode] = true;
        __DBG("CLASS AVAILABLE: " + classCode);

        // Clone spells safely
        SpellRegistry[classCode] = [];

        spellArray.forEach((spell, idx) => {
            if (spell && typeof spell === "object") {
                SpellRegistry[classCode].push({ ...spell });
            } else {
                __DBG("SKIP INVALID SPELL: " + key + " index=" + idx);
                skippedInvalidSpells++;
            }
        });

        __DBG("CLASS " + classCode + " LOADED: " + SpellRegistry[classCode].length + " spells.");
    }

    __DBG("BOOTSTRAP SUMMARY:");
    __DBG("  Classes found: " + foundClasses);
    __DBG("  Non-arrays skipped: " + skippedNonArrays);
    __DBG("  Invalid spells skipped: " + skippedInvalidSpells);

    __DBG("EXIT: bootstrapSpellRegistry()");
})();

__DBG("PASS: SPELL REGISTRY BOOTSTRAPPER COMPLETE");


__DBG("past SPELL REGISTRY BOOTSTRAPPER (SAFE VERSION)()66611144431111333");
// <<keep this below all abilitys but above swoosh panel menu // swoosh
// keep this below the boot strapper above the swoosh pannel >>

// ===============================
// AUTO-GENERATE FIRST SWOOSH SAVE (FIRST RUN) ‚Äî FULLY INSTRUMENTED
// ===============================

__DBG("ENTER: autoFirstRunSwoosh()");

(function autoFirstRunSwoosh() {

    // Check if already loaded this session
    if (window.__swooshLoadedOnce) {
        __DBG("SKIP: __swooshLoadedOnce already TRUE.");
        return;
    }
    __DBG("PASS: __swooshLoadedOnce is FALSE (first run).");

    // Check if log already contains a swoosh block
    const log = document.getElementById("log");

    if (!log) {
        __DBG("ERROR: #log element NOT FOUND during autoFirstRunSwoosh.");
    } else {
        __DBG("PASS: #log element FOUND.");
    }

    if (log && log.textContent.includes(SWOOSH_START)) {
        __DBG("SKIP: Log already contains a swoosh block.");
        return;
    }

    __DBG("PASS: No swoosh block found in log. Generating first-run swoosh.");

    // Mark as generated
    window.__swooshLoadedOnce = true;
    __DBG("SET: __swooshLoadedOnce = TRUE");

    // Generate initial swoosh block
    freezeLogForSwoosh().then(() => {

        __DBG("ENTER: freezeLogForSwoosh() resolved ‚Äî writing initial swoosh.");

        const fullDatabase = {
            timestamp: new Date().toISOString(),
            registry: SpellRegistry,
            overrides: UserOverrides,
            custom: UserCustomSpells,
            classes: SpellClassAvailable
        };

        __DBG("WRITING: SWOOSH_START");
        logRaw(SWOOSH_START);

        __DBG("WRITING: JSON fullDatabase");
        logRaw(JSON.stringify(fullDatabase, null, 2));

        __DBG("WRITING: SWOOSH_END");
        logRaw(SWOOSH_END);

        LOG_UNLOCKED = true;
        __DBG("SET: LOG_UNLOCKED = TRUE");

        logLine("Initial Swoosh database generated (first run).");
        __DBG("PASS: Initial swoosh generation COMPLETE.");

    }).catch(err => {
        __DBG("ERROR: freezeLogForSwoosh() rejected: " + err);
    });

})();

__DBG("EXIT: autoFirstRunSwoosh()");


// keep above swoosh panel, below swoosh load by text

function triggerSwooshLoadDialog() {
    __DBG("ENTER: triggerSwooshLoadDialog()");

    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".txt,.log,.json";

    input.addEventListener("change", () => {
        const file = input.files && input.files[0];
        if (!file) {
            __DBG("SKIP: No file selected in triggerSwooshLoadDialog().");
            return;
        }

        __DBG("PASS: File selected: " + file.name);

        const reader = new FileReader();

        reader.onload = () => {
            const text = reader.result || "";
            __DBG("PASS: File read complete, length=" + text.length);
            try {
                swooshLoadFromText(text);
                __DBG("PASS: swooshLoadFromText() CALL RETURNED.");
            } catch (e) {
                __DBG("ERROR: swooshLoadFromText() threw: " + e.message);
            }
        };

        reader.onerror = () => {
            __DBG("ERROR: FileReader failed in triggerSwooshLoadDialog().");
            logLine("Failed to read swoosh file.");
        };

        reader.readAsText(file);
    });

    input.click();
}


window.addEventListener("DOMContentLoaded", () => {
    window.updateSwooshListUI = function(timestamp) {
        const listDiv = document.getElementById("swooshList");
        if (!listDiv) {
            __DBG("updateSwooshListUI: #swooshList not found.");
            return;
        }

        const label = timestamp
            ? `Loaded Swoosh: ${new Date(timestamp).toLocaleString()}`
            : "Loaded Swoosh: Loaded (no timestamp)";

        listDiv.textContent = label;
        __DBG("updateSwooshListUI: " + label);
    };
});

__DBG("ENTER: SWOOSH PANEL");
// ===============================
// SWOOSH PANEL (FULLY INSTRUMENTED + DOWNLOAD BUTTON)
// ===============================
// ===============================
// SWOOSH PANEL (SAVE / LOAD / DOWNLOAD / SYNC)
// ===============================
window.addEventListener("DOMContentLoaded", () => {
    (function createSwooshPanel() {
        __DBG("ENTER: createSwooshPanel()");

        // --- PANEL CONTAINER ---
        const panel = document.createElement("div");
        panel.id = "swooshPanel";
        panel.style.marginTop = "25px";
        panel.style.padding = "12px";
        panel.style.border = "1px solid #888";
        panel.style.background = "#111";
        panel.style.color = "white";
        panel.style.borderRadius = "6px";
        __DBG("PASS: Created swooshPanel DIV.");

        // --- TITLE ---
        const title = document.createElement("h3");
        title.textContent = "Swoosh System ‚Äî Save / Load";
        panel.appendChild(title);
        __DBG("PASS: Title appended to panel.");

        // --- INFO TEXT ---
        const info = document.createElement("div");
        info.style.fontSize = "13px";
        info.style.opacity = "0.8";
        info.style.marginBottom = "10px";
info.innerHTML = `
    The Swoosh System saves your entire spell database, including overrides and custom spells.<br>
    Load or download your swoosh log to restore your personalized spell system. Save first, then download.<br>
    It will also save and restore your Long Term Timers.
`;

        panel.appendChild(info);
        __DBG("PASS: Info block appended to panel.");

        // --- BUTTON ROW ---
        const btnRow = document.createElement("div");
        btnRow.style.display = "flex";
        btnRow.style.gap = "10px";
        btnRow.style.marginBottom = "12px";
        __DBG("PASS: Created swooshPanel BUTTON ROW.");

        // ===============================
        // SAVE BUTTON
        // ===============================
        const saveBtn = document.createElement("button");
        saveBtn.textContent = "Swoosh Save";
        saveBtn.style.padding = "6px 12px";

        saveBtn.addEventListener("click", () => {
            __DBG("EVENT: Swoosh Save button CLICKED.");
            try {
                swooshSave();
                __DBG("PASS: swooshSave() CALL RETURNED.");
            } catch (e) {
                __DBG("ERROR: swooshSave() threw: " + e.message);
            }
        });

        btnRow.appendChild(saveBtn);
        __DBG("PASS: Save button appended.");

        // ===============================
        // LOAD BUTTON
        // ===============================
        const loadBtn = document.createElement("button");
        loadBtn.textContent = "Swoosh Load";
        loadBtn.style.padding = "6px 12px";

        loadBtn.addEventListener("click", () => {
            __DBG("EVENT: Swoosh Load button CLICKED.");
            try {
                triggerSwooshLoadDialog();
                __DBG("PASS: triggerSwooshLoadDialog() CALL RETURNED.");
            } catch (e) {
                __DBG("ERROR: triggerSwooshLoadDialog() threw: " + e.message);
            }
        });

        btnRow.appendChild(loadBtn);
        __DBG("PASS: Load button appended.");

        // ===============================
        // DOWNLOAD FULL LOG BUTTON
        // ===============================
        const downloadBtn = document.createElement("button");
        downloadBtn.textContent = "Download Full Log";
        downloadBtn.style.padding = "6px 12px";

        downloadBtn.addEventListener("click", () => {
            __DBG("EVENT: Download Full Log button CLICKED.");

            try {
                const logEl = document.getElementById("log");
                if (!logEl) {
                    __DBG("ERROR: #log element NOT FOUND.");
                    alert("Log element not found ‚Äî cannot download.");
                    return;
                }

                const text = logEl.value || logEl.innerText || "";
                __DBG("DOWNLOAD: Retrieved log text length=" + text.length);

                const blob = new Blob([text], { type: "text/plain" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
                a.href = url;
                a.download = `swoosh_log_${timestamp}.txt`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                __DBG("PASS: Log download triggered.");
            } catch (e) {
                __DBG("ERROR: Download failed: " + e.message);
                alert("Failed to download log: " + e.message);
            }
        });

        btnRow.appendChild(downloadBtn);
        __DBG("PASS: Download button appended.");

        // ===============================
        // SYNC ALL TIMERS BUTTON (NEW)
        // ===============================
        const syncBtn = document.createElement("button");
        syncBtn.textContent = "Sync All Timers";
        syncBtn.style.padding = "6px 12px";
        syncBtn.style.opacity = "0.4";
        syncBtn.style.pointerEvents = "none"; // disabled until swoosh loaded

        syncBtn.addEventListener("click", () => {
            __DBG("EVENT: Sync All Timers button CLICKED.");

            try {
                const engine = (typeof SpellTimerEngine !== "undefined") ? SpellTimerEngine : null;

                if (!engine) {
                    __DBG("SYNC ERROR: SpellTimerEngine not ready (global not defined).");
                    alert("Engine not ready ‚Äî cannot sync timers.");
                    return;
                }

                // Resolve timers collection safely
                let timersMap = null;

                if (typeof timers !== "undefined") {
                    timersMap = timers;
                } else if (engine.timers && typeof engine.timers.forEach === "function") {
                    timersMap = engine.timers;
                }

                if (!timersMap || typeof timersMap.forEach !== "function") {
                    __DBG("SYNC ERROR: timers collection not available.");
                    alert("Timers not available ‚Äî nothing to sync.");
                    return;
                }

                timersMap.forEach((t, spellId) => {
                    __DBG("SYNC: Resetting " + spellId + " to override/computed duration.");
                    engine.resetTimer(spellId);
                });

                __DBG("PASS: All timers synced.");
                alert("All timers synced to overrides.");

            } catch (e) {
                __DBG("ERROR: Sync failed: " + e.message);
                alert("Sync failed: " + e.message);
            }
        });

        btnRow.appendChild(syncBtn);
        __DBG("PASS: Sync button appended (initially disabled).");

        panel.appendChild(btnRow);

        // ===============================
        // LOADED SWOOSH TITLE + DISPLAY
        // ===============================
        const listTitle = document.createElement("h4");
        listTitle.textContent = "Loaded Swoosh:";
        panel.appendChild(listTitle);

        const swooshList = document.createElement("div");
        swooshList.id = "swooshList";
        swooshList.style.fontSize = "13px";
        swooshList.style.opacity = "0.9";
        swooshList.textContent = "None loaded.";
        panel.appendChild(swooshList);

        // ===============================
        // HOOK INTO updateSwooshListUI
        // ===============================
        const oldUpdate = window.updateSwooshListUI;

        window.updateSwooshListUI = function (timestamp) {
            __DBG("HOOK: updateSwooshListUI called ‚Äî enabling Sync button.");

            if (typeof oldUpdate === "function") {
                try {
                    oldUpdate(timestamp);
                } catch (e) {
                    __DBG("WARNING: old updateSwooshListUI crashed early: " + e.message);
                }
            }

            syncBtn.style.opacity = "1";
            syncBtn.style.pointerEvents = "auto";
        };

        // ===============================
        // APPEND PANEL TO BODY
        // ===============================
        document.body.appendChild(panel);
        __DBG("PASS: swooshPanel appended to document.body.");
        __DBG("EXIT: createSwooshPanel() COMPLETE.");
    })();
});

__DBG("past SWOOSH PANEL (FULLY INSTRUMENTED)");  

// ===============================
// AUTO‚ÄëENABLE CLASSES BASED ON SPELL DATA (BLOCK 3.99)
// ===============================

// Map class codes to the expected spell data variable name
const SpellDataSources = {
    NEC: "SpellData_NEC",
    RNG: "SpellData_RNG",
    SHM: "SpellData_SHM",
    ENC: "SpellData_ENC",
    MAG: "SpellData_MAG",
    WIZ: "SpellData_WIZ",
    CLR: "SpellData_CLR",
    DRU: "SpellData_DRU",
    BRD: "SpellData_BRD",
    MNK: "SpellData_MNK",
    ROG: "SpellData_ROG",
    PAL: "SpellData_PAL",
    SHD: "SpellData_SHD",
    WAR: "SpellData_WAR"
};

// Enable only classes that have spell data arrays
window.addEventListener("DOMContentLoaded", () => {

    Object.entries(SpellDataSources).forEach(([classCode, varName]) => {

        const exists = (typeof window[varName] !== "undefined");

        if (exists) {
            // Enable this class in the selector
            enableSpellClass(classCode);
        } else {
            // Disable this class in the selector
            const selector = document.querySelectorAll("#spellTimerClassSelector input[type='checkbox']");
            selector.forEach(cb => {
                if (cb.dataset.classCode === classCode) {
                    cb.disabled = true;
                    cb.nextSibling.style.opacity = "0.4"; // fade label
                }
            });
        }
    });

});


// ===============================
// SPELL TIMER SYSTEM: CLASS VISIBILITY CONTROL (BLOCK #4)
// ===============================

// Map class codes to their spell list container IDs
const SpellListContainers = {
    NEC: "necSpellList",
    ROG: "rogSpellList",
    WAR: "warSpellList",
    MNK: "mnkSpellList",
    RNG: "rngSpellList",
    SHD: "shdSpellList",
    PAL: "palSpellList",
    BRD: "brdSpellList",
};


// Hide all spell lists AFTER they are created
window.addEventListener("DOMContentLoaded", () => {
    setTimeout(() => {
        Object.values(SpellListContainers).forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = "none";
        });
    }, 50);
});

// Show/hide spell lists when class selection changes
document.addEventListener("SpellClassSelectionChanged", (e) => {
    const flags = e.detail.flags;

    Object.entries(SpellListContainers).forEach(([classCode, elementId]) => {
        const el = document.getElementById(elementId);
        if (!el) return;

        el.style.display = flags[classCode] ? "block" : "none";
    });
});

// notes push


function formatTime(seconds) {
    seconds = Math.max(0, Math.floor(seconds));

    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;

    if (h > 0) {
        return `${h}:${m.toString().padStart(2,"0")}:${s.toString().padStart(2,"0")}`;
    }
    return `${m}:${s.toString().padStart(2,"0")}`;
}

// === SPELL TIMER SYSTEM: BLOCK #5 ‚Äî CORE TIMER ENGINE (UPDATED WITH COOLDOWNS) ===
const SpellTimerEngine = (function () {

    // ===============================
    // INTERNAL STATE
    // ===============================
    const timers = new Map();      // spellId -> timerState
    const history = new Map();     // spellId -> [entries]
    const activeClasses = new Set();

    const listeners = {
        timerUpdate: [],
        timerRemove: [],
        historyUpdate: [],
        activeClassesChange: []
    };

    // ===============================
    // INTERNAL HELPERS
    // ===============================

    function emit(event, payload) {
        const list = listeners[event];
        if (!list) return;
        list.forEach(fn => {
            try { fn(payload); } catch (e) {
                console.error("SpellTimerEngine listener error:", e);
            }
        });
    }

    function getActiveClasses() {
        return Array.from(activeClasses);
    }

    function recalcActiveClassesFor(classCode) {
        if (!classCode) return;
        let stillHas = false;
        timers.forEach(t => {
            if (t.classCode === classCode) stillHas = true;
        });
        if (!stillHas) {
            activeClasses.delete(classCode);
        }
        emit("activeClassesChange", getActiveClasses());
    }

    function ensureSpellId(spell) {
        if (!spell) return null;
        if (!spell.id) {
            const cls = spell.class || "GEN";
            const base = (spell.name || "SPELL").replace(/\s+/g, "_").toUpperCase();
            spell.id = `${cls}_${base}`;
        }
        return spell.id;
    }

    function captureNotes(t) {
        const ui = t.ui;
        if (ui?.notesArea) {
            updateNotes(t.spellId, ui.notesArea.value);
        }
    }

    // ===============================
    // CORE ENGINE FUNCTIONS
    // ===============================

    function ensureTimer(spell) {
        __DBG("ENTER: ensureTimer(" + (spell?.id || spell?.name || "UNKNOWN") + ")");

        if (!spell) {
            __DBG("ensureTimer: No spell provided ‚Äî ABORT.");
            return null;
        }

        const spellId = ensureSpellId(spell);
        if (!spellId) {
            __DBG("ensureTimer: Failed to resolve spellId ‚Äî ABORT.");
            return null;
        }

        let t = timers.get(spellId);

        if (!t) {
            __DBG("ensureTimer: Creating NEW timer for " + spellId);

            let baseDur;

            if (UserOverrides[spellId] &&
                typeof UserOverrides[spellId].baseDuration === "number") {

                baseDur = UserOverrides[spellId].baseDuration;
                __DBG("ensureTimer: Using OVERRIDE duration for " + spellId + " => " + baseDur);

            } else {
                baseDur = SpellTimerEngine.computeDuration(spell);
                __DBG("ensureTimer: Using COMPUTED duration for " + spellId + " => " + baseDur);
            }

            t = {
                spellId,
                spellName: spell.name || spellId,
                classCode: spell.class || null,
                spell,
                baseDuration: baseDur,
                remaining: baseDur,
                running: false,
                startedAt: null,
                elapsedAccum: 0,
                notes: "",
                levelOverride: null
            };

            timers.set(spellId, t);

            if (t.classCode) {
                activeClasses.add(t.classCode);
                emit("activeClassesChange", getActiveClasses());
                __DBG("ensureTimer: Added active class " + t.classCode);
            }

            __DBG("ensureTimer: NEW timer created for " + spellId);
        } else {
            __DBG("ensureTimer: Existing timer found for " + spellId);
        }

        __DBG("EXIT: ensureTimer(" + spellId + ")");
        return t;
    }

    function createTimer(spell) {
        const t = ensureTimer(spell);
        if (!t) return null;
        emit("timerUpdate", { type: "create", timer: { ...t } });
        return t;
    }

    function removeTimer(spellId) {
        const t = timers.get(spellId);
        if (!t) {
            emit("timerRemove", { spellId });
            return;
        }
        timers.delete(spellId);
        recalcActiveClassesFor(t.classCode);
        emit("timerRemove", { spellId });
    }

    function internalUpdateState(t, type) {
        emit("timerUpdate", { type: type || "state", timer: { ...t } });
    }

    function startTimer(spellId) {
        const t = timers.get(spellId);
        if (!t || t.running) return;

        t.running = true;
        t.startedAt = performance.now();

        logLineWithRoster(`Started timer: ${t.spellName}`);
        internalUpdateState(t, "state");
    }

    function pauseTimer(spellId) {
        const t = timers.get(spellId);
        if (!t || !t.running) return;

        const now = performance.now();
        const delta = (now - t.startedAt) / 1000;

        t.elapsedAccum += delta;
        t.startedAt = null;
        t.running = false;

        t.remaining = Math.max(0, t.baseDuration - t.elapsedAccum);

        logLineWithRoster(`Paused timer: ${t.spellName}`);
        internalUpdateState(t, "state");
    }

    function resetTimer(spellId) {
        __DBG("ENTER: resetTimer(" + spellId + ")");

        const t = timers.get(spellId);
        if (!t) {
            __DBG("RESET: No timer found ‚Äî ABORT.");
            return;
        }

        let newDur;

        if (typeof t.baseDuration === "number" && t.baseDuration > 0) {
            newDur = t.baseDuration;
        } else {
            newDur = SpellTimerEngine.computeDuration(t.spell, t.levelOverride);
        }

        t.baseDuration = newDur;
        t.remaining = newDur;
        t.running = false;
        t.startedAt = null;
        t.elapsedAccum = 0;

        internalUpdateState(t, "reset");
        __DBG("EXIT: resetTimer(" + spellId + ")");
    }

    function finalizeElapsed(t) {
        if (t.running) {
            const now = performance.now();
            const delta = (now - t.startedAt) / 1000;
            t.elapsedAccum += delta;
            t.startedAt = null;
            t.running = false;
        }

        if (t.baseDuration > 0 && t.elapsedAccum === 0) {
            t.elapsedAccum = t.baseDuration;
        }

        t.remaining = Math.max(0, t.baseDuration - t.elapsedAccum);
    }

    function completeTimer(spellId) {
        const t = timers.get(spellId);
        if (!t) return;

        captureNotes(t);
        finalizeElapsed(t);

        const actual = t.elapsedAccum || t.baseDuration || 0;

        logLineWithRoster(`Completed: ${t.spellName} (Duration: ${formatTime(actual)})`);
        logHistory(spellId, "Completed", actual, t.notes);

        resetTimer(spellId);
    }

    function fadeEarlyTimer(spellId) {
        const t = timers.get(spellId);
        if (!t) return;

        captureNotes(t);
        finalizeElapsed(t);

        const actual = t.elapsedAccum || 0;

        logLineWithRoster(`Faded Early: ${t.spellName} (Duration: ${formatTime(actual)})`);
        logHistory(spellId, "Faded Early", actual, t.notes);

        resetTimer(spellId);
    }

    function updateNotes(spellId, notes) {
        const t = timers.get(spellId);
        if (!t) return;

        t.notes = notes || "";
        logLineWithRoster(`Notes updated for ${t.spellName}: "${t.notes}"`);
        internalUpdateState(t, "notes");
    }

    function logHistory(spellId, result, durationSeconds, notes) {
        if (!history.has(spellId)) history.set(spellId, []);

        const entry = {
            timestamp: new Date(),
            result,
            durationSeconds: durationSeconds || 0,
            notes: notes || ""
        };

        history.get(spellId).push(entry);

        emit("historyUpdate", {
            spellId,
            entry,
            history: history.get(spellId).slice()
        });
    }

    function getHistory(spellId) {
        return history.has(spellId) ? history.get(spellId).slice() : [];
    }

    function getAverageDuration(spellId) {
        const h = history.get(spellId);
        if (!h || !h.length) return 0;
        const sum = h.reduce((acc, e) => acc + (e.durationSeconds || 0), 0);
        return sum / h.length;
    }

    function on(eventName, handler) {
        if (!listeners[eventName]) {
            console.warn("SpellTimerEngine.on: unknown event", eventName);
            return;
        }
        listeners[eventName].push(handler);
    }

    function spawnCooldownTimer(t) {
        const reuse = t.spell && t.spell.reuseSeconds;
        if (!reuse) return;

        const cdSpell = {
            id: t.spellId + "_COOLDOWN",
            name: t.spellName + " ‚Äî COOLDOWN REUSE TIMER",
            class: t.classCode,
            minDurationSeconds: reuse,
            maxDurationSeconds: reuse,
            scalesWithLevel: false
        };

        const newTimer = createTimer(cdSpell);
        if (newTimer) {
            startTimer(cdSpell.id);
        }
    }
// ===============================
// TICK LOOP
// ===============================
function tickLoop() {
    const now = performance.now();

    timers.forEach(t => {
        if (!t.running) return;

        const elapsed = t.elapsedAccum + (now - t.startedAt) / 1000;
        t.elapsed = elapsed;

        const remaining = Math.max(0, t.baseDuration - elapsed);
        t.remaining = remaining;

        const done = remaining <= 0.01;

        if (done) {
            t.running = false;
            t.startedAt = null;
            t.elapsedAccum = t.baseDuration;

            captureNotes(t);

if (t.cooldownId) {

    // Make cooldown timer visible in UI
    const cdBox = TimerUIMap.get(t.cooldownId);
    if (cdBox) cdBox.style.display = "block";

    const cdClone = CloneUIMap.get(t.cooldownId);
    if (cdClone) cdClone.style.display = "block";

    // Start the cooldown timer
    SpellTimerEngine.startTimer(t.cooldownId);
}


            logHistory(t.spellId, "Completed", t.baseDuration, t.notes);
            internalUpdateState(t, "auto-complete");

        } else {
            internalUpdateState(t, "tick");
        }
    });

    requestAnimationFrame(tickLoop);
}

    // ‚≠ê THIS MUST BE INDENTED ‚Äî INSIDE THE IIFE
    requestAnimationFrame(tickLoop);

    // ‚≠ê computeDuration MUST ALSO BE INSIDE THE IIFE
    function computeDuration(spell, levelOverride = null) {
        const min = spell.minDurationSeconds || 0;
        const max = spell.maxDurationSeconds || min;

        if (!spell.scalesWithLevel) return max;

        const lvlMin = spell.spellLevelMin || 1;
        const lvlMax = spell.spellLevelMax || lvlMin;

        const lvl = Math.max(lvlMin, Math.min(levelOverride || lvlMax, lvlMax));
        const pct = (lvl - lvlMin) / (lvlMax - lvlMin || 1);

        return Math.round(min + pct * (max - min));
    }

    return {
        timers,
        history,
        activeClasses,
        listeners,
        createTimer,
        removeTimer,
        startTimer,
        pauseTimer,
        resetTimer,
        completeTimer,
        fadeEarlyTimer,
        updateNotes,
        logHistory,
        getHistory,
        getAverageDuration,
        getActiveClasses,
        on,
        computeDuration
    };

})();  // END OF ENGINE




__DBG("past MAIN TICK LOOP ()999");

// ===============================
// SPELL TIMER SYSTEM: BLOCK #6 ()‚Äî UI BUILDER (UPDATED)
// ===============================

// Where the bottom panel will insert timers (Block 7 will create this container)
let SPELL_TIMER_MASTER_CONTAINER = null;

// Map spellId -> DOM container for the timer
const TimerUIMap = new Map();

// Helper: format seconds as mm:ss
function fmtTime(sec) {
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${s.toString().padStart(2, "0")}`;
}

// PUBLIC: Create a timer UI for a spell
function createSpellTimerUI(spell, parentContainerId) {
    if (!SPELL_TIMER_MASTER_CONTAINER) return;

    // ‚≠ê NEW: cooldown spells use the dual-timer UI
    if (spell.reuseSeconds) {
        return createDualTimerUI(spell);
    }

    // ‚≠ê OLD BEHAVIOR for normal spells
    const t = SpellTimerEngine.createTimer(spell);
    if (!t) return;

    if (TimerUIMap.has(spell.id)) return;

    const classSection = ensureClassSection(spell.class);

    const bottomBox = buildTimerBox(spell, t);
    classSection.appendChild(bottomBox);
    TimerUIMap.set(spell.id, bottomBox);

    const cloneBox = buildTimerBoxClone(spell, t);
    CloneUIMap.set(spell.id, cloneBox);

    const cloneContainer = document.getElementById("spellTimerPanelContainer_clone");
    if (cloneContainer) {
        cloneContainer.appendChild(cloneBox);
    }
}
function buildTimerBoxClone(spell, t) {
    __DBG("ENTER: buildTimerBoxClone(" + spell.id + ")");

    const box = document.createElement("div");
    box.className = "section";
    box.style.marginTop = "6px";

    // ===============================
    // Save & Update button (SPELL TIMERS)
    // ===============================
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Save & Update";
    saveBtn.style.marginBottom = "6px";

    saveBtn.addEventListener("click", () => {
        __DBG("EVENT: Save & Update clicked for spell timer: " + spell.id);

        // Spell timers do not have editable duration/label/notes fields,
        // so we pass nulls. The handler will update internal timer state + swoosh.
        saveAndUpdateTimer(t, {
            durationInput: null,
            labelInput: null,
            notesInput: null
        });
    });

    box.appendChild(saveBtn);

    // ===============================
    // Title
    // ===============================
    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = spell.name;
    box.appendChild(title);

    // ===============================
    // Duration Display (NEW ‚Äî shows override!)
    // ===============================
    const durRow = document.createElement("div");
    durRow.style.fontSize = "12px";
    durRow.style.color = "#ccc";
    durRow.style.marginBottom = "6px";

    // Always show the REAL duration: the override if present
    const effectiveDuration = t.baseDuration || SpellTimerEngine.computeDuration(spell);
    durRow.textContent = "Duration (sec): " + effectiveDuration;

    __DBG("CLONE UI: Duration display for " + spell.id + " = " + effectiveDuration);

    box.appendChild(durRow);

    // ===============================
    // Progress Bar
    // ===============================
    const progOuter = document.createElement("div");
    progOuter.style.width = "100%";
    progOuter.style.height = "14px";
    progOuter.style.background = "#333";
    progOuter.style.border = "1px solid #555";
    progOuter.style.marginBottom = "6px";

    const progFill = document.createElement("div");
    progFill.style.height = "100%";
    progFill.style.width = "0%";
    progFill.style.background = "#3cb371";

    progOuter.appendChild(progFill);
    box.appendChild(progOuter);

    // ===============================
    // Time Labels
    // ===============================
    const timeElapsed = document.createElement("div");
    timeElapsed.style.fontSize = "12px";
    timeElapsed.style.color = "#ccc";
    timeElapsed.style.marginBottom = "2px";
    timeElapsed.textContent = "Elapsed: 0s";
    box.appendChild(timeElapsed);

    const timeRemaining = document.createElement("div");
    timeRemaining.style.fontSize = "12px";
    timeRemaining.style.color = "#ccc";
    timeRemaining.style.marginBottom = "6px";
    timeRemaining.textContent = "Remaining: 0s";
    box.appendChild(timeRemaining);

    // ===============================
    // Buttons (LIVE)
    // ===============================
    const btnRow = document.createElement("div");

    btnRow.appendChild(makeBtn("Start", () => SpellTimerEngine.startTimer(spell.id)));
    btnRow.appendChild(makeBtn("Pause", () => SpellTimerEngine.pauseTimer(spell.id)));
    btnRow.appendChild(makeBtn("Reset", () => SpellTimerEngine.resetTimer(spell.id)));
    btnRow.appendChild(makeBtn("Completed", () => SpellTimerEngine.completeTimer(spell.id)));
    btnRow.appendChild(makeBtn("Faded Early", () => SpellTimerEngine.fadeEarlyTimer(spell.id)));

    // Cooldown button
    if (spell.reuseSeconds) {
        const btnStartCooldown = makeBtn("Start Cooldown Reuse Timer Now", () => {
            if (t.cooldownId) {
                const cdBox = TimerUIMap.get(t.cooldownId);
                if (cdBox) cdBox.style.display = "block";

                const cdClone = CloneUIMap.get(t.cooldownId);
                if (cdClone) cdClone.style.display = "block";

                SpellTimerEngine.startTimer(t.cooldownId);
            }
        });

        btnStartCooldown.style.marginLeft = "6px";
        btnRow.appendChild(btnStartCooldown);
    }

    // Hide button
    const hideBtn = makeBtn("Hide", () => {
        box.style.display = "none";
    });
    hideBtn.style.marginLeft = "6px";
    btnRow.appendChild(hideBtn);

    box.appendChild(btnRow);

    // ===============================
    // Store UI refs for updates
    // ===============================
    box._ui = {
        progFill,
        timeElapsed,
        timeRemaining,
        notesArea: null,
        durationRow: durRow   // NEW ‚Äî so live updates can refresh duration
    };

    t.cloneUi = box._ui;

    __DBG("EXIT: buildTimerBoxClone(" + spell.id + ")");
    return box;
}



__DBG("past block 6 ()999666");

// PUBLIC: Remove timer UI
function removeSpellTimerUI(spellId) {
    const box = TimerUIMap.get(spellId);
    if (box && box.parentNode) {
        box.parentNode.removeChild(box);
    }
    TimerUIMap.delete(spellId);

    SpellTimerEngine.removeTimer(spellId);

    cleanupEmptyClassSections();
}
function buildTimerBox(spell, t) {
    __DBG("ENTER: buildTimerBox(" + spell.id + ")");

    const box = document.createElement("div");
    box.className = "section";
    box.style.marginTop = "6px";

    // ===============================
    // Save & Update button
    // ===============================
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Save & Update";
    saveBtn.style.marginBottom = "6px";

    saveBtn.addEventListener("click", () => {
        __DBG("EVENT: Save & Update clicked for spell timer: " + spell.id);

        saveAndUpdateTimer(t, {
            durationInput: null,
            labelInput: null,
            notesInput: null
        });
    });

    box.appendChild(saveBtn);

    // ===============================
    // Title
    // ===============================
    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = spell.name;
    box.appendChild(title);

    // ===============================
    // Duration Row (OVERRIDE-AWARE)
    // ===============================
    const durRow = document.createElement("div");
    durRow.style.marginBottom = "6px";

    const durLabel = document.createElement("span");
    durLabel.textContent = "Duration (sec): ";
    durRow.appendChild(durLabel);

    const durInput = document.createElement("input");
    durInput.type = "number";
    durInput.style.width = "70px";

    // Use override if present
    const effectiveDuration =
        t.baseDuration ||
        (UserOverrides[spell.id]?.baseDuration) ||
        SpellTimerEngine.computeDuration(spell);

    durInput.value = effectiveDuration;

    __DBG("UI: Duration input for " + spell.id + " = " + effectiveDuration);

    durInput.addEventListener("change", () => {
        const newVal = Number(durInput.value) || 0;

        __DBG("EVENT: Duration changed for " + spell.id + " => " + newVal);

        // Update timer object
        t.baseDuration = newVal;
        t.remaining = newVal;

        // Persist override
        if (!UserOverrides[spell.id]) UserOverrides[spell.id] = {};
        UserOverrides[spell.id].baseDuration = newVal;

        __DBG("OVERRIDE STORED: UserOverrides[" + spell.id + "].baseDuration=" + newVal);

        SpellTimerEngine.resetTimer(spell.id);
    });

    durRow.appendChild(durInput);
    box.appendChild(durRow);

    // ===============================
    // Progress Bar
    // ===============================
    const progOuter = document.createElement("div");
    progOuter.style.width = "100%";
    progOuter.style.height = "14px";
    progOuter.style.background = "#333";
    progOuter.style.border = "1px solid #555";
    progOuter.style.marginBottom = "6px";

    const progFill = document.createElement("div");
    progFill.style.height = "100%";
    progFill.style.width = "0%";
    progFill.style.background = "#3cb371";

    progOuter.appendChild(progFill);
    box.appendChild(progOuter);

    // ===============================
    // Time Labels
    // ===============================
    const timeElapsed = document.createElement("div");
    timeElapsed.style.fontSize = "12px";
    timeElapsed.style.color = "#ccc";
    timeElapsed.style.marginBottom = "2px";
    timeElapsed.textContent = "Elapsed: 0s";
    box.appendChild(timeElapsed);

    const timeRemaining = document.createElement("div");
    timeRemaining.style.fontSize = "12px";
    timeRemaining.style.color = "#ccc";
    timeRemaining.style.marginBottom = "6px";
    timeRemaining.textContent = "Remaining: 0s";
    box.appendChild(timeRemaining);

    // ===============================
    // Buttons
    // ===============================
    const btnRow = document.createElement("div");

    btnRow.appendChild(makeBtn("Start", () => {
        __DBG("BTN: Start pressed for " + spell.id);
        SpellTimerEngine.startTimer(spell.id);
    }));

    btnRow.appendChild(makeBtn("Pause", () => {
        __DBG("BTN: Pause pressed for " + spell.id);
        SpellTimerEngine.pauseTimer(spell.id);
    }));

    btnRow.appendChild(makeBtn("Reset", () => {
        __DBG("BTN: Reset pressed for " + spell.id);
        SpellTimerEngine.resetTimer(spell.id);
    }));

    btnRow.appendChild(makeBtn("Completed", () => {
        __DBG("BTN: Completed pressed for " + spell.id);
        SpellTimerEngine.completeTimer(spell.id);
    }));

    btnRow.appendChild(makeBtn("Faded Early", () => {
        __DBG("BTN: Faded Early pressed for " + spell.id);
        SpellTimerEngine.fadeEarlyTimer(spell.id);
    }));

    // Cooldown button
    if (spell.reuseSeconds) {
        const btnStartCooldown = makeBtn("Start Cooldown Reuse Timer Now", () => {
            __DBG("BTN: Start Cooldown pressed for " + spell.id);

            if (t.cooldownId) {
                const cdBox = TimerUIMap.get(t.cooldownId);
                if (cdBox) cdBox.style.display = "block";

                const cdClone = CloneUIMap.get(t.cooldownId);
                if (cdClone) cdClone.style.display = "block";

                SpellTimerEngine.startTimer(t.cooldownId);
            }
        });

        btnStartCooldown.style.marginLeft = "6px";
        btnRow.appendChild(btnStartCooldown);
    }

    // Info button
    btnRow.appendChild(makeBtn("Info", () => {
        __DBG("BTN: Info pressed for " + spell.id);
        alert(
            `${spell.name}\n\n` +
            `${spell.description || "No description available."}\n\n` +
            `Notes: ${spell.notes || "None"}`
        );
    }));

    // Show in Top Panel
    btnRow.appendChild(makeBtn("Show Top", () => {
        __DBG("BTN: Show Top pressed for " + spell.id);
        const cloneBox = CloneUIMap.get(spell.id);
        if (cloneBox) cloneBox.style.display = "block";
    }));

    box.appendChild(btnRow);

    // ===============================
    // Notes
    // ===============================
    const notesLabel = document.createElement("div");
    notesLabel.textContent = "Notes:";
    notesLabel.style.marginTop = "6px";
    box.appendChild(notesLabel);

    const notesArea = document.createElement("textarea");
    notesArea.style.height = "50px";
    notesArea.value = t.notes || "";
    box.appendChild(notesArea);

    const saveNotesBtn = makeBtn("Save Notes", () => {
        __DBG("BTN: Save Notes pressed for " + spell.id);
        SpellTimerEngine.updateNotes(spell.id, notesArea.value);
    });
    saveNotesBtn.style.marginTop = "4px";
    box.appendChild(saveNotesBtn);

    // ===============================
    // History Table
    // ===============================
    const histTitle = document.createElement("div");
    histTitle.textContent = "History:";
    histTitle.style.marginTop = "6px";
    histTitle.style.fontWeight = "bold";
    box.appendChild(histTitle);

    const histTable = document.createElement("table");

    const hthead = document.createElement("thead");
    hthead.innerHTML = `
        <tr>
            <th>Time</th>
            <th>Result</th>
            <th>Duration</th>
            <th>Notes</th>
        </tr>`;
    histTable.appendChild(hthead);

    const htbody = document.createElement("tbody");
    histTable.appendChild(htbody);

    box.appendChild(histTable);

    // ===============================
    // Store UI references
    // ===============================
    box._ui = {
        progFill,
        timeElapsed,
        timeRemaining,
        notesArea,
        histBody: htbody,
        durationInput: durInput
    };

    t.ui = box._ui;

    __DBG("EXIT: buildTimerBox(" + spell.id + ")");
    return box;
}



__DBG("function buildTimerBox ()999777666");

function createDualTimerUI(spell) {
    __DBG("ENTER: createDualTimerUI(" + spell.id + ")");

    const classSection = ensureClassSection(spell.class);

    // ============================================================
    // MAIN TIMER
    // ============================================================
    __DBG("DUAL: Creating MAIN timer for " + spell.id);
    const mainTimer = SpellTimerEngine.createTimer(spell);

    const mainBox = buildTimerBox(spell, mainTimer);
    classSection.appendChild(mainBox);
    TimerUIMap.set(spell.id, mainBox);

    // ============================================================
    // COOLDOWN SPELL OBJECT
    // ============================================================
    const cdSpell = {
        id: spell.id + "_CD",
        name: spell.name + " ‚Äî Cooldown",
        class: spell.class,
        minDurationSeconds: spell.reuseSeconds,
        maxDurationSeconds: spell.reuseSeconds,
        scalesWithLevel: false
    };

    __DBG("DUAL: Creating COOLDOWN timer for " + cdSpell.id);

    // ============================================================
    // COOLDOWN TIMER (override-aware via ensureTimer + computeDuration)
    // ============================================================
    const cdTimer = SpellTimerEngine.createTimer(cdSpell);

    // Build cooldown UI
    const cdBox = buildTimerBox(cdSpell, cdTimer);
    cdBox.style.display = "none"; // hidden until needed
    classSection.appendChild(cdBox);
    TimerUIMap.set(cdSpell.id, cdBox);

    // ============================================================
    // LINK MAIN ‚Üí COOLDOWN
    // ============================================================
    mainTimer.cooldownId = cdSpell.id;
    __DBG("DUAL: Linked " + spell.id + " ‚Üí cooldown " + cdSpell.id);

    // ============================================================
    // CLONE PANEL
    // ============================================================
    const cloneContainer = document.getElementById("spellTimerPanelContainer_clone");

    __DBG("DUAL: Creating MAIN clone for " + spell.id);
    const mainClone = buildTimerBoxClone(spell, mainTimer);
    CloneUIMap.set(spell.id, mainClone);
    if (cloneContainer) cloneContainer.appendChild(mainClone);

    __DBG("DUAL: Creating COOLDOWN clone for " + cdSpell.id);
    const cdClone = buildTimerBoxClone(cdSpell, cdTimer);
    cdClone.style.display = "none";
    CloneUIMap.set(cdSpell.id, cdClone);
    if (cloneContainer) cloneContainer.appendChild(cdClone);

    __DBG("EXIT: createDualTimerUI(" + spell.id + ")");
    return mainBox;
}


// flash tracker

function flashButton(btn) {
    btn.classList.remove("button-flash");
    void btn.offsetWidth; // forces reflow so animation can restart
    btn.classList.add("button-flash");
}

document.addEventListener("click", (e) => {
    if (e.target.tagName === "BUTTON") {
        flashButton(e.target);
    }
});


// Helper: make a styled button
function makeBtn(label, onClick) {
    const btn = document.createElement("button");
    btn.textContent = label;

    btn.addEventListener("click", (e) => {
        flashButton(btn);   // ‚≠ê global flash
        onClick(e);         // original behavior
    });

    return btn;
}


// Ensure class section exists
function ensureClassSection(classCode) {
    const id = "timer_section_" + classCode;
    let sec = document.getElementById(id);
    if (sec) return sec;

    sec = document.createElement("div");
    sec.id = id;
    sec.className = "section";
    sec.style.marginTop = "10px";

    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = classCode + " Timers";
    sec.appendChild(title);

    SPELL_TIMER_MASTER_CONTAINER.appendChild(sec);
    return sec;
}

// Remove empty class sections
function cleanupEmptyClassSections() {
    if (!SPELL_TIMER_MASTER_CONTAINER) return;

    const children = [...SPELL_TIMER_MASTER_CONTAINER.children];
    children.forEach(sec => {
        if (sec.id && sec.id.startsWith("timer_section_")) {
            // A class section always has:
            //   1 child = the title only
            //   >1 children = title + timers
            if (sec.children.length <= 1) {
                SPELL_TIMER_MASTER_CONTAINER.removeChild(sec);
            }
        }
    });
}
__DBG("Remove empty class sections ()999888666");
// ENGINE EVENT LISTENERS
SpellTimerEngine.on("timerUpdate", payload => {
    const t = payload.timer;

    const bottomBox = TimerUIMap.get(t.spellId);
    const cloneBox  = CloneUIMap.get(t.spellId);

    const boxes = [bottomBox, cloneBox].filter(b => b && b._ui);
    if (boxes.length === 0) return;

    const spell = t.spell;

    let inBreakZone = false;
    if (spell.breakable) {
        if (spell.category?.includes("Charm") && (t.elapsed || 0) >= spell.minDurationSeconds) {
            inBreakZone = true;
        }
        if (spell.category?.includes("Fear") || spell.category?.includes("Root")) {
            inBreakZone = true;
        }
    }

    boxes.forEach(box => {
        const ui = box._ui;

        // Progress bar width
        if (t.baseDuration > 0) {
            const pct = ((t.baseDuration - t.remaining) / t.baseDuration) * 100;
            ui.progFill.style.width = pct + "%";
        } else {
            ui.progFill.style.width = "0%";
        }

        // Progress bar color
        if (!spell.breakable) ui.progFill.style.background = "#3cb371";
        else if (inBreakZone) ui.progFill.style.background = "#cc3333";
        else ui.progFill.style.background = "#e6c300";

        // ‚≠ê Time labels
        if (ui.timeElapsed) {
            ui.timeElapsed.textContent = "Elapsed: " + formatTime(t.elapsed || 0);
        }

        if (ui.timeRemaining) {
            ui.timeRemaining.textContent = "Remaining: " + formatTime(t.remaining || 0);
        }

    });
});   // ‚≠ê THIS WAS MISSING

__DBG("PAST  ENGINE EVENT LISTENERS ()9990011");
// Update history
SpellTimerEngine.on("historyUpdate", payload => {
    const { spellId, entry } = payload;
    const box = TimerUIMap.get(spellId);
    if (!box || !box._ui) return;

    const body = box._ui.histBody;
    const row = document.createElement("tr");

    row.innerHTML = `
        <td>${entry.timestamp.toLocaleTimeString()}</td>
        <td>${entry.result}</td>
        <td>${fmtTime(entry.durationSeconds)}</td>
        <td>${entry.notes}</td>
    `;

    body.appendChild(row);
});


<!-- === SPELL TIMER SYSTEM: BLOCK #7  ‚Äî BOTTOM TIMER PANEL === -->
// Creates the bottom Spell Timer panel and manages dynamic title updates

(function initBottomSpellTimerPanel() {

    // Create the master panel wrapper
    const panel = document.createElement("div");
    panel.id = "spellTimerPanel";
    panel.className = "section";
    panel.style.marginTop = "20px";

    // Title
    const title = document.createElement("div");
    title.id = "spellTimerPanelTitle";
    title.className = "section-title";
    title.textContent = "Spell Timers";
    panel.appendChild(title);

    // Container where class sections + timers will be inserted
    const container = document.createElement("div");
    container.id = "spellTimerPanelContainer";
    panel.appendChild(container);

    // Attach panel to bottom of page
    document.body.appendChild(panel);

    // IMPORTANT: Expose the correct container to the UI builder
    // This ensures all timers are inserted into #spellTimerPanelContainer
    SPELL_TIMER_MASTER_CONTAINER = container;

    // CLASS NAME MAP (for dynamic title updates)
    const CLASS_NAMES = {
        NEC: "Necromancer",
        RNG: "Ranger",
        SHM: "Shaman",
        ENC: "Enchanter",
        MAG: "Magician",
        WIZ: "Wizard",
        CLR: "Cleric",
        DRU: "Druid",
        BRD: "Bard",
        MNK: "Monk",
        ROG: "Rogue",
        PAL: "Paladin",
        SHD: "Shadow Knight",
        WAR: "Warrior"
    };

    // Update title when active classes change
    SpellTimerEngine.on("activeClassesChange", classList => {
        let base = "Spell Timers";

        if (classList.length > 0) {
            const names = classList
                .map(c => CLASS_NAMES[c] || c)
                .join(" + ");
            base += " + " + names;
        }

        title.textContent = base;

        // Also update cloned panel title (Block 8 will create it)
        const cloneTitle = document.getElementById("spellTimerPanelTitle_clone");
        if (cloneTitle) cloneTitle.textContent = base;
    });

})();
__DBG("PAST SPELL TIMER SYSTEM: BLOCK #7  ()1119990011");
<!-- === SPELL TIMER SYSTEM: BLOCK #8 ‚Äî TOP CLONED PANEL SYSTEM === -->

// ===============================
// TOP CLONED PANEL SYSTEM (CHECKBOX VERSION)
// - Creates a mirror of the bottom Spell Timer panel
// - Appears directly under the <h1> header
// - Fully synced with bottom panel
// - User enables it via checkbox toggle
// ===============================
(function initTopClonedPanelSystem() {

    // Locate the <h1> header
    const header = document.querySelector("h1");
    if (!header) {
        console.warn("Top clone panel: <h1> header not found.");
        return;
    }

    // Create the cloned panel container (initially hidden)
    const clonePanel = document.createElement("div");
    clonePanel.id = "spellTimerPanel_clone";
    clonePanel.className = "section";
    clonePanel.style.marginTop = "10px";
    clonePanel.style.display = "none";

    // Title
    const cloneTitle = document.createElement("div");
    cloneTitle.id = "spellTimerPanelTitle_clone";
    cloneTitle.className = "section-title";
    cloneTitle.textContent = "Spell Timers";
    clonePanel.appendChild(cloneTitle);

    // Container for cloned class sections
    const cloneContainer = document.createElement("div");
    cloneContainer.id = "spellTimerPanelContainer_clone";
    clonePanel.appendChild(cloneContainer);

    // Insert cloned panel directly under the header
    header.insertAdjacentElement("afterend", clonePanel);


    // ===============================
    // CHECKBOX TOGGLE IN BOTTOM PANEL
    // ===============================
    const bottomPanel = document.getElementById("spellTimerPanel");
    if (bottomPanel) {

        const wrapper = document.createElement("label");
        wrapper.style.display = "flex";
        wrapper.style.alignItems = "center";
        wrapper.style.cursor = "pointer";
        wrapper.style.marginBottom = "8px";

        const cloneCheckbox = document.createElement("input");
        cloneCheckbox.type = "checkbox";
        cloneCheckbox.style.marginRight = "6px";

        const cloneLabel = document.createElement("span");
        cloneLabel.textContent = "Clone Panel to Top (enables Show Top button)";

        wrapper.appendChild(cloneCheckbox);
        wrapper.appendChild(cloneLabel);

        // Insert at top of bottom panel
        bottomPanel.insertBefore(wrapper, bottomPanel.firstChild);

        // Toggle behavior
        cloneCheckbox.addEventListener("change", () => {
            if (cloneCheckbox.checked) {
                clonePanel.style.display = "block";
            } else {
                clonePanel.style.display = "none";
            }
        });
    }

})();
__DBG("PAST TOP CLONED PANEL SYSTEM   ()111110011");
// ===============================
// INSTRUMENT ALL FUNCTIONS
// ===============================
setTimeout(() => {
    instrumentAllFunctions(window);
    console.log("Function instrumentation complete.");
}, 0);


//
function saveAndUpdateTimer(timerObj, dom) {
    __DBG("ENTER: saveAndUpdateTimer()");

    // ===============================
    // Read DOM inputs safely
    // ===============================
    const newDuration = dom.durationInput
        ? Number(dom.durationInput.value) || timerObj.baseDuration || timerObj.durationSeconds || 0
        : (timerObj.baseDuration || timerObj.durationSeconds || 0);

    const newLabel = dom.labelInput
        ? dom.labelInput.value
        : (timerObj.label || "");

    const newNotes = dom.notesInput
        ? dom.notesInput.value
        : (timerObj.notes || "");

    __DBG("READ: newDuration=" + newDuration + ", newLabel=" + newLabel);

    // ===============================
    // Update timer object
    // ===============================
    timerObj.baseDuration = newDuration;
    timerObj.remaining = newDuration;
    timerObj.label = newLabel;
    timerObj.notes = newNotes;
    timerObj.startTimestamp = Date.now();

    // ===============================
    // Persist override for swoosh
    // ===============================
    const spellId = timerObj.spellId || timerObj.id;

    if (spellId) {
        if (!UserOverrides[spellId]) {
            UserOverrides[spellId] = {};
        }
        UserOverrides[spellId].baseDuration = newDuration;

        __DBG("OVERRIDE STORED: UserOverrides[" + spellId + "].baseDuration=" + newDuration);
    } else {
        __DBG("WARN: saveAndUpdateTimer() ‚Äî no spellId on timerObj, cannot persist override.");
    }

    // ===============================
    // Log + Save
    // ===============================
    logLine(`Timer updated: ${timerObj.label || spellId} ‚Üí ${newDuration} sec`);
    swooshSave();

    __DBG("EXIT: saveAndUpdateTimer()");
}

// ===============================
// LONG TERM TIMERS MODULE (FINAL + LOGGING)
// ===============================
(function LongTermTimersModule() {

    __DBG("ENTER: LongTermTimersModule");

    let LTT = [];
    let lttClockOverride = null;

    const wrap = document.createElement("div");
    wrap.style.marginTop = "40px";
    wrap.style.padding = "10px";
    wrap.style.border = "2px solid #444";
    wrap.style.background = "#222";
    wrap.style.color = "#fff";
    wrap.style.fontFamily = "monospace";

    // ===============================
    // HEADER WITH CLOCK + SET TIME
    // ===============================
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "10px";

    header.innerHTML = `
        <div style="font-size:20px; font-weight:bold;">Long Term Timers</div>
        <div style="text-align:right;">
            <div id="lttClock" style="font-size:16px; color:#0f0;">00:00</div>
            <button id="lttSetTimeBtn" style="margin-top:4px;">Set Time</button>
        </div>
    `;

    wrap.appendChild(header);
    document.body.appendChild(wrap);

    const clockEl = header.querySelector("#lttClock");

    // ===============================
    // CLOCK UPDATE (RESPECT OVERRIDE)
    // ===============================
    function updateLTTClock() {
        //__DBG("ENTER: updateLTTClock"); // weird bug messes up duration change saves with save & update

        try {
            if (lttClockOverride) {
                clockEl.textContent = `${lttClockOverride.hh}:${lttClockOverride.mm}`;
                return;
            }

            const now = new Date();
            const hh = now.getHours().toString().padStart(2, "0");
            const mm = now.getMinutes().toString().padStart(2, "0");
            clockEl.textContent = `${hh}:${mm}`;
            clockEl.style.opacity = "1";

        } catch (e) {
            clockEl.textContent = "00:00";
            clockEl.style.opacity = clockEl.style.opacity === "1" ? "0.3" : "1";
        }
    }

    setInterval(updateLTTClock, 1000);
    updateLTTClock();

    // ===============================
    // MANUAL CLOCK OVERRIDE
    // ===============================
    header.querySelector("#lttSetTimeBtn").onclick = () => {
        __DBG("ENTER: lttSetTimeBtn.onclick");

        const current = clockEl.textContent;
        const newTime = prompt("Set time (HH:MM):", current);
        if (!newTime) return;

        const parts = newTime.split(":");
        if (parts.length !== 2) return;

        const hh = parseInt(parts[0]);
        const mm = parseInt(parts[1]);

        if (isNaN(hh) || isNaN(mm) || hh < 0 || hh > 23 || mm < 0 || mm > 59) return;

        const now = new Date();
        const sysHH = now.getHours();
        const sysMM = now.getMinutes();
        const diffMin = (hh - sysHH) * 60 + (mm - sysMM);

        logLine(`LTT Clock override: system=${sysHH}:${sysMM} user=${hh}:${mm} (offset ${diffMin} min)`);

        lttClockOverride = {
            hh: hh.toString().padStart(2, "0"),
            mm: mm.toString().padStart(2, "0")
        };

        clockEl.textContent = `${lttClockOverride.hh}:${lttClockOverride.mm}`;
        clockEl.style.color = "#ff0";
        setTimeout(() => clockEl.style.color = "#0f0", 1500);
    };

    // ===============================
    // ADD FORM
    // ===============================
    const form = document.createElement("div");
    form.innerHTML = `
        <input id="lttName" placeholder="Timer Name" style="width:200px;">
        <input id="lttDays" type="number" min="0" placeholder="Days" style="width:60px;">
        <input id="lttHours" type="number" min="0" max="23" placeholder="Hours" style="width:60px;">
        <input id="lttMin" type="number" min="0" max="59" placeholder="Min" style="width:60px;">
        <input id="lttSec" type="number" min="0" max="59" placeholder="Sec" style="width:60px;">
        <button id="lttAdd">Add</button>
    `;
    wrap.appendChild(form);

    const list = document.createElement("div");
    wrap.appendChild(list);

    // ===============================
    // ADD TIMER
    // ===============================
    document.getElementById("lttAdd").onclick = () => {
        __DBG("ENTER: lttAdd.onclick");

        const name = document.getElementById("lttName").value.trim();
        const d = parseInt(document.getElementById("lttDays").value) || 0;
        const h = parseInt(document.getElementById("lttHours").value) || 0;
        const m = parseInt(document.getElementById("lttMin").value) || 0;
        const s = parseInt(document.getElementById("lttSec").value) || 0;

        if (!name) return;

        const totalMs = (d*86400 + h*3600 + m*60 + s) * 1000;
        if (totalMs <= 0) return;

        const obj = {
            id: "LTT_" + Math.random().toString(36).slice(2),
            name,
            target: Date.now() + totalMs,
            note: "",
            history: []
        };

        LTT.push(obj);

        logLine(`LTT Created: ${name} (${d}d ${h}h ${m}m ${s}s)`);

        render();
    };

    // ===============================
    // RENDER (STATIC PARTS ONLY)
    // ===============================
    function render() {
        __DBG("ENTER: render");

        list.innerHTML = "";

        LTT.forEach(t => {
            const div = document.createElement("div");
            div.style.margin = "10px 0";
            div.style.padding = "10px";
            div.style.border = "1px solid #555";

            div.innerHTML = `
                <b>${t.name}</b>
                <button class="edit" style="float:right;">Edit</button>
                <br><br>

                Remaining: <span id="ltt_rem_${t.id}"></span><br>
                Ends On: <span id="ltt_end_${t.id}" style="color:#0af"></span>
                <br><br>

                <textarea class="note" style="width:100%;height:40px;">${t.note}</textarea><br>
                <button class="saveNote">Save Note</button>

                <br><br>
                <button class="toggleHist">Show History</button>
                <div class="hist" style="display:none; margin-top:10px; border-top:1px solid #555; padding-top:10px;">
                    ${t.history.length === 0 ? "<i>No edits yet</i>" : ""}
                </div>

                <br><br>
                <label><input type="checkbox" class="chk1"> Confirm</label>
                <label><input type="checkbox" class="chk2"> Really?</label>
                <button class="delete" style="margin-left:10px;">Delete</button>
            `;

            // ===============================
            // SAVE NOTE
            // ===============================
            div.querySelector(".saveNote").onclick = () => {
                __DBG("ENTER: saveNote.onclick");

                t.note = div.querySelector(".note").value;
logLine(`LTT Note Updated: ${t.name} ‚Üí "${t.note}"`);

            };

            // ===============================
            // TOGGLE HISTORY
            // ===============================
            div.querySelector(".toggleHist").onclick = () => {
                __DBG("ENTER: toggleHist.onclick");

                const h = div.querySelector(".hist");
                h.style.display = h.style.display === "none" ? "block" : "none";
            };

            // ===============================
            // EDIT TIMER
            // ===============================
            div.querySelector(".edit").onclick = () => {
                __DBG("ENTER: edit.onclick");

                const newD = prompt("Days:");
                const newH = prompt("Hours:");
                const newM = prompt("Minutes:");
                const newS = prompt("Seconds:");

                const totalMs = ((+newD||0)*86400 + (+newH||0)*3600 + (+newM||0)*60 + (+newS||0)) * 1000;
                if (totalMs <= 0) return;

                const oldTarget = t.target;
                t.target = Date.now() + totalMs;

                logLine(`LTT Edited: ${t.name} ‚Üí ${newD}d ${newH}h ${newM}m ${newS}s`);

                // Force immediate Ends On update
                const endEl = document.getElementById("ltt_end_" + t.id);
                if (endEl) {
                    let now = new Date();
                    if (lttClockOverride) {
                        now = new Date(
                            now.getFullYear(),
                            now.getMonth(),
                            now.getDate(),
                            parseInt(lttClockOverride.hh),
                            parseInt(lttClockOverride.mm),
                            0
                        );
                    }

                    const endDate = new Date(now.getTime() + totalMs);

                    const options = {
                        year: "numeric",
                        month: "short",
                        day: "numeric",
                        hour: "2-digit",
                        minute: "2-digit",
                        hour12: true
                    };

                    endEl.textContent = endDate.toLocaleString(undefined, options);
                }

                t.history.push({
                    when: new Date().toLocaleString(),
                    oldRemaining: oldTarget - Date.now(),
                    newRemaining: totalMs
                });

                render();
            };

            // ===============================
            // DELETE TIMER
            // ===============================
            div.querySelector(".delete").onclick = () => {
                __DBG("ENTER: delete.onclick");

                const c1 = div.querySelector(".chk1").checked;
                const c2 = div.querySelector(".chk2").checked;
                if (!c1 || !c2) return;

                logLine(`LTT Deleted: ${t.name}`);

                LTT = LTT.filter(x => x.id !== t.id);
                render();
            };

            // ===============================
            // HISTORY RENDER
            // ===============================
            const histDiv = div.querySelector(".hist");
            t.history.forEach(h => {
                const row = document.createElement("div");
                row.style.marginBottom = "6px";
                row.innerHTML = `
                    <b>${h.when}</b><br>
                    Old: ${(h.oldRemaining/1000).toFixed(0)} sec<br>
                    New: ${(h.newRemaining/1000).toFixed(0)} sec<br>
                `;
                histDiv.appendChild(row);
            });

            list.appendChild(div);
        });
    }

// ===============================
// PARTIAL UPDATE LOOP (ONLY REMAINING TIME)
// ===============================
setInterval(() => {
    LTT.forEach(t => {
        const el = document.getElementById("ltt_rem_" + t.id);
        if (!el) return;

        const remaining = t.target - Date.now();
        const ready = remaining <= 0;

        const days = Math.max(0, Math.floor(remaining / 86400000));
        const hours = Math.max(0, Math.floor((remaining % 86400000) / 3600000));
        const mins = Math.max(0, Math.floor((remaining % 3600000) / 60000));
        const secs = Math.max(0, Math.floor((remaining % 60000) / 1000));

        el.innerHTML = ready
            ? `<span style="color:#ff0">READY</span>`
            : `<span style="color:#0f0">${days}d ${hours}h ${mins}m ${secs}s</span>`;

        const endEl = document.getElementById("ltt_end_" + t.id);
        if (endEl) {
            let now = new Date();
            if (lttClockOverride) {
                now = new Date(
                    now.getFullYear(),
                    now.getMonth(),
                    now.getDate(),
                    parseInt(lttClockOverride.hh),
                    parseInt(lttClockOverride.mm),
                    0
                );
            }

            const endDate = new Date(now.getTime() + remaining);

            const options = {
                year: "numeric",
                month: "short",
                day: "numeric",
                hour: "2-digit",
                minute: "2-digit",
                hour12: true
            };

            endEl.textContent = endDate.toLocaleString(undefined, options);
        }
    });
}, 1000);

// ===============================
// API EXPORT
// ===============================
window.LongTermTimersAPI = {
    getAll: () => LTT,
    loadAll: arr => { LTT = arr || []; render(); }
};

})();

// ===============================
// TIME CONVERTER (BETA)
// ===============================
(function TimeConverterModule() {

    const wrap = document.createElement("div");
    wrap.style.marginTop = "40px";
    wrap.style.padding = "10px";
    wrap.style.border = "2px solid #444";
    wrap.style.background = "#111";
    wrap.style.color = "#fff";
    wrap.style.fontFamily = "monospace";
    wrap.innerHTML = "<h2>Time Converter <span style='color:#0f0'>(BETA)</span></h2>";
    document.body.appendChild(wrap);

    const addBtn = document.createElement("button");
    addBtn.textContent = "Add Converter";
    addBtn.style.marginBottom = "10px";
    wrap.appendChild(addBtn);

    const list = document.createElement("div");
    wrap.appendChild(list);

    let converters = [];

    addBtn.onclick = () => {
        const id = "TC_" + Math.random().toString(36).slice(2);
        converters.push({ id });
        render();
    };

    function render() {
        list.innerHTML = "";

        converters.forEach(conv => {
            const box = document.createElement("div");
            box.style.margin = "10px 0";
            box.style.padding = "10px";
            box.style.border = "1px solid #555";
            box.style.background = "#222";

            box.innerHTML = `
                <b>Converter</b>  
                <button class="delete" style="float:right;">Delete</button>
                <br><br>

                <input class="sec" type="number" placeholder="Seconds" style="width:120px;"> ‚Üí
                <span class="out1"></span><br>

                <input class="min" type="number" placeholder="Minutes" style="width:120px;"> ‚Üí
                <span class="out2"></span><br>

                <input class="hr" type="number" placeholder="Hours" style="width:120px;"> ‚Üí
                <span class="out3"></span><br>

                <input class="day" type="number" placeholder="Days" style="width:120px;"> ‚Üí
                <span class="out4"></span><br>
            `;

            // Delete converter
            box.querySelector(".delete").onclick = () => {
                converters = converters.filter(x => x.id !== conv.id);
                render();
            };

            const sec = box.querySelector(".sec");
            const min = box.querySelector(".min");
            const hr  = box.querySelector(".hr");
            const day = box.querySelector(".day");

            const out1 = box.querySelector(".out1");
            const out2 = box.querySelector(".out2");
            const out3 = box.querySelector(".out3");
            const out4 = box.querySelector(".out4");

            // ===============================
            // TOTAL OUTPUT COLUMN
            // ===============================
            const totalOut = document.createElement("div");
            totalOut.style.marginTop = "6px";
            totalOut.style.color = "#0f0";
            totalOut.style.fontWeight = "bold";
            box.appendChild(totalOut);

            function updateTotal() {
                const s = parseFloat(sec.value) || 0;
                const m = (parseFloat(min.value) || 0) * 60;
                const h = (parseFloat(hr.value)  || 0) * 3600;
                const d = (parseFloat(day.value) || 0) * 86400;

                const total = s + m + h + d;

                // Convert to HH:MM:SS
                const hh = Math.floor(total / 3600);
                const mm = Math.floor((total % 3600) / 60);
                const ss = Math.floor(total % 60);

                const hhmmss =
                    hh > 0
                        ? `${hh.toString().padStart(2,"0")}:${mm.toString().padStart(2,"0")}:${ss.toString().padStart(2,"0")}`
                        : `${mm.toString().padStart(2,"0")}:${ss.toString().padStart(2,"0")}`;

                totalOut.textContent = `Total: ${hhmmss} (${s} + ${m} + ${h} + ${d})`;
            }

            // ===============================
            // EXISTING CONVERSION LOGIC
            // ===============================
            sec.oninput = () => {
                const s = parseFloat(sec.value) || 0;
                out1.textContent = `${(s/60).toFixed(2)} min | ${(s/3600).toFixed(2)} hr | ${(s/86400).toFixed(2)} days`;
                updateTotal();
            };

            min.oninput = () => {
                const m = parseFloat(min.value) || 0;
                out2.textContent = `${m*60} sec | ${(m/60).toFixed(2)} hr | ${(m/1440).toFixed(2)} days`;
                updateTotal();
            };

            hr.oninput = () => {
                const h = parseFloat(hr.value) || 0;
                out3.textContent = `${h*3600} sec | ${h*60} min | ${(h/24).toFixed(2)} days`;
                updateTotal();
            };

            day.oninput = () => {
                const d = parseFloat(day.value) || 0;
                out4.textContent = `${d*86400} sec | ${d*1440} min | ${d*24} hr`;
                updateTotal();
            };

            // Initialize total
            updateTotal();

            list.appendChild(box);
        });
    }

})();


// ===============================
// REFRESH / CLOSE WARNING
// ===============================
window.addEventListener("beforeunload", function (e) {
    // Custom message (not all browsers show it, but the warning still triggers)
    const message = "Warning: This page does NOT save any data. Refreshing will wipe all timers, notes, and history. Save your logs before leaving.";

    e.preventDefault();
    e.returnValue = message; // Required for Chrome/Edge
    return message;
});


__DBG("PAST end to script end 0101337");
</script>

</body>
</html>
yesyesyesx