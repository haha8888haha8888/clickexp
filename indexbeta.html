<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>EQ P99 XP & Mob Tracker</title>
    <style>
        body {
            background-color: #101820;
            color: #f0e6c8;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
        }
        h1 {
            text-align: center;
            color: #ffd700;
            margin-bottom: 10px;
        }
        .section {
            border: 1px solid #444;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #1b2430;
        }
        .section-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffcc66;
        }
        label {
            margin-right: 5px;
        }
        select, input[type="number"], input[type="text"], textarea {
            margin-right: 10px;
            margin-bottom: 5px;
        }
        textarea {
            width: 100%;
            height: 60px;
            resize: vertical;
        }
        button {
            margin: 3px;
            padding: 5px 10px;
            background-color: #2f3b4f;
            color: #f0e6c8;
            border: 1px solid #555;
            cursor: pointer;
        }
        button:disabled {
            background-color: #444;
            cursor: not-allowed;
        }
        #xpBarContainer {
            margin-top: 5px;
            width: 100%;
            background-color: #333;
            border: 1px solid #555;
            height: 20px;
            position: relative;
        }
        #xpBarFill {
            background-color: #3cb371;
            height: 100%;
            width: 0%;
        }
        #xpBarText {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 12px;
            top: 2px;
        }
#log {
    background-color: #000;
    color: #0f0;
    font-family: "Courier New", monospace;
    font-size: 11px;
    height: 220px;
    overflow-y: auto;
    padding: 5px;
    border: 1px solid #555;
    white-space: pre-line;
}

        .timer-display {
            font-size: 16px;
            font-weight: bold;
            margin: 5px 0;
        }
        .flash {
            animation: flash 0.7s infinite alternate;
        }
        @keyframes flash {
            from { background-color: #8b0000; }
            to   { background-color: #ff4500; }
        }
        .group-row {
            margin-left: 10px;
            margin-bottom: 3px;
            font-size: 12px;
        }
        .small-label {
            font-size: 11px;
            color: #ccc;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            margin-top: 5px;
        }
        th, td {
            border: 1px solid #555;
            padding: 3px 4px;
            text-align: center;
        }
        th {
            background-color: #2a3445;
        }
        .subtimer {
            border: 1px solid #555;
            padding: 5px;
            margin-top: 5px;
            background-color: #151d28;
        }
        .xp-edit-input {
            width: 60px;
        }
        .xp-note-input {
            width: 140px;
        }
        .pet-slider-wrapper {
            margin-top: 5px;
            font-size: 12px;
        }
        .pet-slider-wrapper input[type="range"] {
            width: 200px;
        }
        .timer-restart-area {
            margin-top: 5px;
            font-size: 12px;
            border-top: 1px solid #333;
            padding-top: 5px;
        }
        .timer-restart-area label {
            margin-right: 5px;
        }
        .timer-restart-buttons {
            margin-top: 5px;
        }
.button-flash {
    animation: flashPulse 120ms ease-out;
}

@keyframes flashPulse {
    0%   { transform: scale(1);     filter: brightness(1); }
    50%  { transform: scale(0.96);  filter: brightness(1.4); }
    100% { transform: scale(1);     filter: brightness(1); }
}

    </style>
<div id="topTimersArea"></div>

</head>
<body>
    <h1>EverQuest P99 XP & Mob Tracker</h1>

    <!-- SESSION NOTES -->
    <div class="section">
        <div class="section-title">Session Notes</div>
        <textarea id="sessionNotes" placeholder="Anything about this camp, group, loot, patterns, etc."></textarea>
        <button id="sessionNotesUpdateBtn">Update Session Notes</button>
    </div>

    <!-- HEADER: CHARACTER / GROUP / SESSION -->
    <div class="section">
        <div class="section-title">Character & Group Setup</div>
        <div>
            <label for="charNameInput">Name:</label>
            <input id="charNameInput" type="text" placeholder="Optional" style="width:120px;">

            <label for="classSelect">Class:</label>
            <select id="classSelect">
                <option value="NEC">Necromancer (NEC)</option>
                <option value="ENC">Enchanter (ENC)</option>
                <option value="MAG">Magician (MAG)</option>
                <option value="WIZ">Wizard (WIZ)</option>
                <option value="CLR">Cleric (CLR)</option>
                <option value="DRU">Druid (DRU)</option>
                <option value="SHM">Shaman (SHM)</option>
                <option value="BRD">Bard (BRD)</option>
                <option value="MNK">Monk (MNK)</option>
                <option value="RNG">Ranger (RNG)</option>
                <option value="ROG">Rogue (ROG)</option>
                <option value="PAL">Paladin (PAL)</option>
                <option value="SHD">Shadow Knight (SHD)</option>
                <option value="WAR">Warrior (WAR)</option>
                <option value="DELETE">DELETE MEMBER</option>
            </select>

            <label for="raceSelect">Race:</label>
            <select id="raceSelect" onchange="cb2_startCharacterDraft()">
                <option>Human</option>
                <option>Erudite</option>
                <option>Barbarian</option>
                <option>Halfling</option>
                <option>Dwarf</option>
                <option>Gnome</option>
                <option>Half-Elf</option>
                <option>Wood Elf</option>
                <option>High Elf</option>
                <option>Dark Elf</option>
                <option>Ogre</option>
                <option>Troll</option>
                <option>Iksar</option>
            </select>

            <label for="levelInput">Level:</label>
            <input id="levelInput" type="number" min="1" max="60" value="51" style="width:60px;">

            <label for="xpInput">Current XP %:</label>
            <input id="xpInput" type="number" min="0" max="100" value="0" style="width:60px;">
        </div>

        <div style="margin-top:5px;">
            <label for="charNotes">Character Notes:</label>
            <input id="charNotes" type="text" placeholder="Root spots, charm targets, etc." style="width:260px;">
            <button id="charNotesUpdateBtn">Update Character Notes</button>
        </div>

        <div style="margin-top:5px;">
            <label>In Group?</label>
            <button id="groupYesBtn">YES</button>
            <button id="groupNoBtn">NO</button>

            <span id="groupSizeWrapper" style="margin-left:10px; display:none;">
                <label for="groupSizeInput">Total Members (1‚Äì6):</label>
                <input id="groupSizeInput" type="number" min="1" max="6" value="1" style="width:50px;">
                <button id="addMemberBtn">Add Member</button>
                <button id="removeMemberBtn">Remove Member</button>
            </span>
        </div>

        <div id="groupMembersContainer" style="margin-top:5px; display:none;">
            <div style="font-size:12px; margin-bottom:3px;">You are Member 1 (set above). Configure Members 2‚Äì6 below:</div>
            <div id="groupMemberRows"></div>
        </div>

        <div style="margin-top:5px;">
            <button id="startSessionBtn">Start Session Log</button>
            <button id="pauseSessionBtn" disabled>Pause Session</button>
            <button id="exportLogBtn">Export Log</button>
        </div>

        <div id="charTitleDisplay" style="margin-top:5px; font-size:13px; color:#ccc;">
            No session active.
        </div>

        <div id="xpBarContainer">
            <div id="xpBarFill"></div>
            <div id="xpBarText">XP: 0%</div>
        </div>
    </div>

    <!-- XP TRACKING SECTION -->
    <div class="section">
        <div class="section-title">XP Tracking</div>

        <button id="xpTimerToggleBtn">Track XP Timer: OFF</button>
        <div class="timer-display">
            XP Timer: <span id="xpTimerDisplay">0s</span>
        </div>

        <div style="margin-top:5px;">
            <label><input type="checkbox" id="usingPetCheckbox"> Using a pet?</label>
        </div>
        <div id="petSliderWrapper" class="pet-slider-wrapper" style="display:none;">
            <div>Did YOU do more damage than your pet?</div>
            <div>
                <span>YOU</span>
                <input type="range" id="petDamageSlider" min="0" max="100" value="100">
                <span>PET</span>
            </div>
            <div id="petSliderState" style="margin-top:2px;">Current: YOU get full XP</div>
        </div>

        <div class="timer-restart-area">
            <label><input type="checkbox" id="masterRestartCheckbox"> Restart selected timers when MOB EXP +1 is clicked?</label>
            <div id="timerRestartList" style="margin-top:3px; font-size:11px;">
                <!-- checkboxes for main + extra timers will appear here -->
            </div>
            <div id="timerRestartButtons" class="timer-restart-buttons">
                <!-- +1 Mob (TimerName) buttons appear here when master is checked -->
            </div>
        </div>

        <div style="margin-top:5px;">
            <button id="xpGainBtn" disabled>1% EXP GAIN RECORD</button>
            <button id="xpGainLateBtn" disabled>1% GAINED (IGNORE TIMER, INPUT LATE)</button>
        </div>

        <div style="margin-top:5px;">
            <button id="mobXpBtn" disabled>MOB EXP GAINED TRACKER +1</button>
        </div>

        <div style="font-size:12px; margin-top:5px;">
            Last 1% gap: <span id="lastGapDisplay">N/A</span><br>
            Mobs this 1%: <span id="mobsThisCycleDisplay">0</span>
        </div>

        <div style="margin-top:8px;">
            <span class="small-label">1% XP History (max 100 rows)</span>
            <table id="xpHistoryTable">
                <thead>
                    <tr>
                        <th>Current % Level</th>
                        <th>Gap</th>
                        <th>Mobs</th>
                        <th>Notes</th>
                        <th>Update</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <button id="printXpTableBtn" style="margin-top:5px;">Print XP Table to Log</button>
        </div>
    </div>

    <!-- MOB CYCLE TIMER SECTION -->
    <div class="section">
        <div class="section-title">Mob Cycle Timer</div>
        <label for="mobMinutes">Minutes:</label>
        <input id="mobMinutes" type="number" min="0" value="22" style="width:60px;">
        <label for="mobSeconds">Seconds:</label>
        <input id="mobSeconds" type="number" min="0" max="59" value="0" style="width:60px;">

        <button id="mobStartBtn">Start</button>
        <button id="mobResetBtn">Reset</button>
        <button id="mobSoundToggleBtn">Sound Alarm: ON</button>

        <div style="margin-top:5px;">
            <label for="mobNotes">Mob Timer Notes:</label>
            <input id="mobNotes" type="text" placeholder="Named PH, spawn window, etc." style="width:260px;">
            <button id="mobNotesUpdateBtn">Update Mob Timer Notes</button>
        </div>

        <div class="timer-display">
            Mob Timer: <span id="mobTimerDisplay">00:00</span>
        </div>

        <div style="margin-top:8px;">
            <button id="addCycleTimerBtn">Add Another Cycle Timer</button>
            <button id="addStopwatchBtn">Add Reverse Timer (Stopwatch)</button>
        </div>

        <div id="extraTimersContainer" style="margin-top:5px;"></div>
    </div>

    <!-- LOG PANEL -->
    <div class="section">
        <div class="section-title">Session Log</div>
        <div id="log"></div>
    </div>

<!-- ITEM BUILDER PANEL -->
<div class="section" id="itemBuilderPanel">
    <div class="section-title">Item Builder</div>
<div style="margin-top:10px;">
    <label>Item Title:</label><br>
    <input id="itemTitleInput" type="text" placeholder="Enter item name..."
           style="width: 260px;">
</div>

<div style="margin-top:10px;">
    <label>Effect Timer (seconds):</label><br>
    <input id="itemEffectInput" type="number" min="0" placeholder="0 = no timer"
           style="width: 120px;">
    <label><input id="itemEffectToggle" type="checkbox" checked> Item has effect timer</label>
</div>


    <label>Item Page URL:</label>
    <input id="itemUrlInput" type="text" 
           value="https://wiki.project1999.com/" 
           style="width: 320px;">

    <button id="itemUrlTestBtn">Test Link</button>
    <span id="itemUrlStatus" style="margin-left:10px; font-size:12px;"></span>

    <div style="margin-top:10px;">
        <label>Item Image (from /images/ folder only):</label><br>
        <input id="itemImgInput" type="text" 
               value="https://wiki.project1999.com/images/" 
               style="width: 320px;">
        <button id="itemImgTestBtn">Test Image</button>
        <span id="itemImgStatus" style="margin-left:10px; font-size:12px;"></span>
    </div>

    <div id="itemImgPreview" style="margin-top:10px;"></div>

    <div style="margin-top:10px;">
        <textarea id="itemNoteInput" placeholder="Paste item text here..."
                  style="height:120px; width:100%;"></textarea>
    </div>

    <button id="itemSealBtn">Create Seal</button>
    <button id="itemClearBtn">Clear</button>

    <div id="itemSealArea" style="margin-top:10px; display:none;"></div>
</div> 

<!-- CH CHAIN TIMER PANEL LAUNCHER -->


<div class="section">
    <div class="section-title">CH Chain Tools</div>
    <button id="addChChainPanelBtn">Add CH Chain Timer Panel</button>
</div>

<div id="chChainPanelsContainer"></div>


<!-- =============================== -->
<!-- CB2: CHARACTER BUILDER V2 PANEL -->
<!-- =============================== -->
<!-- CB2: CHARACTER BUILDER V2 PANEL -->
<!-- =============================== -->
<div id="cb2_panel_root" style="margin-top:30px; border-top:1px solid #555; padding-top:15px;">

    <div class="cb2_panel_title" id="cb2_panel_root_title">
        <h2 style="display:inline;">Character Builder v2</h2>
        <button class="cb2_toggleBtn" data-target="cb2_panel_root_body">[-]</button>
    </div>

    <div id="cb2_panel_root_body">

        <!-- MAIN LAYOUT: LEFT = LIST/CREATE, RIGHT = CHAR PANELS -->
        <div style="display:flex; gap:20px; align-items:flex-start;">

            <!-- LEFT COLUMN -->
            <div id="cb2_panel_characterList" style="min-width:260px; max-width:260px; border:1px solid #444; padding:10px;">

                <div class="cb2_panel_title" id="cb2_panel_characterList_title">
                    <h3 style="display:inline;">Stable of Characters</h3>
                    <button class="cb2_toggleBtn" data-target="cb2_panel_characterList_body">[-]</button>
                </div>

                <div id="cb2_panel_characterList_body">

                    <div id="cb2_characterListBox"
                         style="max-height:300px; overflow-y:auto; margin-bottom:10px;">
                    </div>

                    <button id="cb2_btn_deleteOne" style="margin-bottom:10px;">
                        Delete Selected Character
                    </button>

                    <div id="cb2_panel_createCharacter"
                         style="border-top:1px solid #333; padding-top:10px; margin-top:10px;">

                        <h4>Create New Character</h4>

                        <label>Name:</label><br>
                        <input id="cb2_input_newCharacterName" type="text"
                               style="width:100%; margin-bottom:6px;"><br>

                        <label>Class:</label><br>
                        <select id="cb2_input_newCharacterClass"
        style="width:100%; margin-bottom:6px;"
        onchange="cb2_startCharacterDraft()">
                                style="width:100%; margin-bottom:6px;">
<option value="Warrior">Warrior</option>
<option value="Paladin">Paladin</option>
<option value="Ranger">Ranger</option>
<option value="Shadowknight">Shadowknight</option>

<option value="Bard">Bard</option>
<option value="Rogue">Rogue</option>
<option value="Monk">Monk</option>

<option value="Cleric">Cleric</option>
<option value="Druid">Druid</option>
<option value="Shaman">Shaman</option>

<option value="Necromancer">Necromancer</option>
<option value="Wizard">Wizard</option>
<option value="Magician">Magician</option>
<option value="Enchanter">Enchanter</option>
                        </select><br>

                        <label>Race:</label><br>
                        <div id="cb2_panel_raceSelector"
                             style="display:flex; flex-wrap:wrap; gap:4px; margin-bottom:8px;">
                        </div>
<div id="cb2_chrStatPanel"></div>
                        <label>Level:</label><br>
                        <input id="cb2_input_newCharacterLevel" type="number"
                               min="1" max="60" value="60" style="width:80px;"><br><br>

                        <button id="cb2_btn_createCharacter"
        onclick="cb2_finalizeCharacterCreation()">
    Forge New Character
</button>
                    </div>
                </div>
            </div>

            <!-- RIGHT COLUMN -->
            <div id="cb2_panel_characterDeck" style="flex:1; min-height:200px;">
                <div class="cb2_panel_title" id="cb2_panel_characterDeck_title">
                    <h3 style="display:inline;">Character Panels</h3>
                    <button class="cb2_toggleBtn" data-target="cb2_panel_characterDeck_body">[-]</button>
                </div>

                <div id="cb2_panel_characterDeck_body">
                    <!-- JS renders character cards here -->
                </div>
            </div>
        </div>

<!-- ================= EXTRAS ================= -->
<div id="cb2_panel_extras" style="margin-top:20px;">

    <!-- TOKEN WORKSHOP -->
    <div id="cb2_panel_tokenWorkshop"
         style="flex:1; border:1px solid #444; padding:10px;">

        <div class="cb2_panel_title" id="cb2_panel_tokenWorkshop_title">
            <h3 style="display:inline;">Token Workshop</h3>
            <button class="cb2_toggleBtn" data-target="cb2_panel_tokenWorkshop_body">[-]</button>
        </div>

        <div id="cb2_panel_tokenWorkshop_body">

            <!-- TOKEN IMPORT -->
            <div style="margin-bottom:12px;">
                <input id="cb2_input_tokenImport" type="text"
                       placeholder="Paste token here..."
                       style="width:70%;">
                <button id="cb2_btn_importToken">Import Token</button>
            </div>

            <!-- LOAD INVENTORY ITEMS -->
            <button id="cb2_btn_loadInventoryTokens"
                    style="margin-bottom:10px;">
                Update Inventory Items
            </button>

            <!-- HIDE/SHOW INVENTORY LIST -->
            <button id="cb2_btn_toggleInventoryList"
                    style="margin-left:10px;">
                Hide Inventory List
            </button>

            <!-- INVENTORY ITEM LIST -->
            <div id="cb2_tokenInventoryList"
                 style="margin-top:10px; border-top:1px solid #333; padding-top:10px;">
            </div>

        </div>
    </div>
</div>

            <!-- ITEM PREVIEW (THIS WAS THE BROKEN ONE) -->
            <div id="cb2_panel_itemPreview"
                 style="flex:1; border:1px solid #444; padding:10px;">

                <div class="cb2_panel_title" id="cb2_panel_itemPreview_title">
                    <h3 style="display:inline;">Item Preview & Equip State</h3>
                    <button class="cb2_toggleBtn" data-target="cb2_panel_itemPreview_body">[-]</button>
                </div>

<div id="cb2_panel_itemPreview_body">
    <div id="cb2_itemPreviewBox"></div>

    <button id="cb2_btn_approveScrapedItem"
            style="margin-top:10px; padding:6px 12px;">
        Approve This Item
    </button>
<button id="cb2_btn_sendToEditor"
        style="margin-top:10px; padding:6px 12px;">
    Send to Manual Editor
</button>
</div>
<div id="cb2_approvedItemsList"
     style="margin-top:15px; padding:10px; border:1px solid #444;">
</div>

            </div>

        </div> <!-- END EXTRAS -->

        <!-- DEBUG CONSOLE -->
        <pre id="cb2_debugConsole"
             style="white-space:pre-wrap; margin-top:20px; background:#111; color:#0f0;
                    padding:10px; max-height:200px; overflow-y:auto;"></pre>

</div>
</div>
<div id="cb2_main_panels" style="display:flex; gap:20px; align-items:flex-start;">
    <!-- scraper panel goes here -->
    <!-- manual item entry panel goes here -->
<!-- =============================== -->
<!-- P99 SCRAPER PANEL (FINAL FIXED) -->
<!-- =============================== -->
<div id="p99_console_panel"
     style="
        border:1px solid #333;
        padding:10px;
        margin-top:0;                  /* NEW: remove gap */
        background:#111;
        box-sizing:border-box;
        border-top:none;               /* NEW: merges visually */
        border-radius:0 0 4px 4px;     /* NEW: matches panel */
     ">

    <!-- PANEL HEADER -->
    <div class="cb2_panel_title" id="p99_scraper_panel_title">
        <h3 style="display:inline;">P99 Item Scraper</h3>
        <button class="cb2_toggleBtn" data-target="p99_scraper_panel_body">[-]</button>
    </div>

    <!-- PANEL BODY -->
    <div id="p99_scraper_panel_body" style="padding-top:10px;">

        <label>Item URL:</label><br>
        <input id="urlInput" type="text"
               placeholder="https://wiki.project1999.com/Sprinkler_of_the_Spirits"
               style="width:100%; margin-bottom:10px;"><br>

        <div style="margin-top:10px;">
            <button id="proxy1Btn">Proxy 1</button>
            <button id="proxy2Btn">Proxy 2</button>
            <button id="proxy3Btn">Proxy 3</button>
        </div>

        <!-- =============================== -->
        <!-- SCRAPER CONSOLE (JS injects <pre>) -->
        <!-- =============================== -->

            <div id="p99_console_panel_body" style="padding-top:10px;">
                <!-- JS will insert <pre id="output"> here -->
            </div>

        </div> <!-- END CONSOLE PANEL -->

        <div id="itemImageBox" style="margin-top:10px;"></div>

    </div> <!-- END SCRAPER BODY -->


<!-- ======================================= -->
<!-- CB2: MANUAL ITEM ENTRY PANEL (MODERNIZED) -->
<!-- ======================================= -->
<div id="cb2_panel_manualItemEntry"
     style="flex:1; border:1px solid #444; padding:10px; margin-top:20px;">

    <div class="cb2_panel_title" id="cb2_panel_manualItemEntry_title">
        <h3 style="display:inline;">Manual Item Entry</h3>
        <button class="cb2_toggleBtn" data-target="cb2_panel_manualItemEntry_body">[-]</button>
    </div>

    <div id="cb2_panel_manualItemEntry_body" style="padding-top:10px;">

        <!-- =============================== -->
        <!-- BASIC INFO -->
        <!-- =============================== -->
        <h4>Basic Info</h4>
        <label>Name:</label><br>
        <input id="cb2_manual_name" type="text" style="width:100%; margin-bottom:8px;"><br>

        <!-- =============================== -->
        <!-- PRIMARY STATS -->
        <!-- =============================== -->
        <h4>Primary Stats</h4>
        <div style="display:flex; flex-wrap:wrap; gap:10px;">
            <div>STR<br><input id="cb2_manual_str" type="number" style="width:60px;"></div>
            <div>STA<br><input id="cb2_manual_sta" type="number" style="width:60px;"></div>
            <div>AGI<br><input id="cb2_manual_agi" type="number" style="width:60px;"></div>
            <div>DEX<br><input id="cb2_manual_dex" type="number" style="width:60px;"></div>
            <div>INT<br><input id="cb2_manual_int" type="number" style="width:60px;"></div>
            <div>WIS<br><input id="cb2_manual_wis" type="number" style="width:60px;"></div>
            <div>CHA<br><input id="cb2_manual_cha" type="number" style="width:60px;"></div>
        </div>

        <!-- =============================== -->
        <!-- VITALS -->
        <!-- =============================== -->
        <h4 style="margin-top:15px;">Vitals</h4>
        <div style="display:flex; gap:10px;">
            <div>HP<br><input id="cb2_manual_hp" type="number" style="width:80px;"></div>
            <div>MANA<br><input id="cb2_manual_mana" type="number" style="width:80px;"></div>
            <div>END<br><input id="cb2_manual_end" type="number" style="width:80px;"></div>
        </div>

        <!-- =============================== -->
        <!-- RESISTS -->
        <!-- =============================== -->
        <h4 style="margin-top:15px;">Resists</h4>
        <div style="display:flex; flex-wrap:wrap; gap:10px;">
            <div>Fire<br><input id="cb2_manual_fire" type="number" style="width:60px;"></div>
            <div>Cold<br><input id="cb2_manual_cold" type="number" style="width:60px;"></div>
            <div>Magic<br><input id="cb2_manual_magic" type="number" style="width:60px;"></div>
            <div>Disease<br><input id="cb2_manual_disease" type="number" style="width:60px;"></div>
            <div>Poison<br><input id="cb2_manual_poison" type="number" style="width:60px;"></div>
        </div>

        <!-- =============================== -->
        <!-- COMBAT -->
        <!-- =============================== -->
        <h4 style="margin-top:15px;">Combat</h4>
        <div style="display:flex; flex-wrap:wrap; gap:10px;">
            <div>DMG<br><input id="cb2_manual_dmg" type="number" style="width:60px;"></div>
            <div>Delay<br><input id="cb2_manual_delay" type="number" style="width:60px;"></div>
            <div>AC<br><input id="cb2_manual_ac" type="number" style="width:60px;"></div>
        </div>

        <!-- =============================== -->
        <!-- SLOT -->
        <!-- =============================== -->
<div id="cb2_panel_manualItem_slots"></div>

 

        <!-- =============================== -->
        <!-- CLASSES -->
        <!-- =============================== -->
        <h4>Classes</h4>
        <div id="cb2_panel_manualItem_classes"
             style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px;">
            <!-- JS populates class checkboxes -->
        </div>

        <!-- =============================== -->
        <!-- RACES -->
        <!-- =============================== -->
        <h4>Races</h4>
        <div id="cb2_panel_manualItem_races"
             style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px;">
            <!-- JS populates race checkboxes -->
        </div>

        <!-- =============================== -->
        <!-- TOKENS -->
        <!-- =============================== -->
        <h4>Assign Tokens</h4>
        <div id="cb2_panel_manualItem_tokens"
             style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px;">
            <!-- JS populates token checkboxes -->
        </div>

        <!-- =============================== -->
        <!-- APPROVE BUTTON -->
        <!-- =============================== -->
        <button id="cb2_btn_manualItem_approve"
                style="margin-top:10px; padding:8px 14px;">
            Send To Preview & Approve
        </button>

    </div> <!-- END BODY -->
</div> <!-- END PANEL -->



<script>
// ---------- GLOBAL CH CHAIN STATE (must load FIRST) ----------
window.CHChains  = [];        // all chain objects
window.CHDebug   = true;      // global debug toggle
window.CHTickRate = 50;       // global tick interval
window.CHPanels  = new Map(); // id -> DOM panel
window.CB2_selectedItemIndex = null;
window.CB2_selectedCharacterIndex = null;

// ---------- UTILITIES ----------
const CloneUIMap = new Map();

const SWOOSH_START = "startstartstart*$*$*$*$*$*$*$*$$*$* === SWOOSH START ===";
const SWOOSH_END   = "finfinfin*$*$*$*$*$*$*$*$$*$* === SWOOSH END ===";

let DEBUG_ENABLED = true;
let LOG_UNLOCKED = true;   // true = normal logging allowed, false = locked

let CALL_A = 1;
let CALL_B = 0;

let INSTRUMENTATION_ENABLED = false;

// ---------- GLOBAL REGISTRIES ----------
window.SpellRegistry = {};
window.UserOverrides = {};
window.UserCustomSpells = [];
window.SpellClassAvailable = {};
window.ItemRegistry = [];
window.itemTimers = {};
window.CB2_ItemRegistry = [];   // brand‚Äëmarked CB2 item DB

// Safety: ensure ItemRegistry always exists
window.ItemRegistry = window.ItemRegistry || [];

// =============================================================
// GLOBAL CB2 OBJECT
// =============================================================
window.CB2 = window.CB2 || {
    characters: [],
    items: [],
    currentCharacterDraft: null
};


//letmeseee

// ===============================
// MEGA DEBUG CONSOLE (CLICK TO OPEN)
// ===============================

(function createMegaDebugConsole() {

    // Main console window
    const dbg = document.createElement("div");
    dbg.id = "megaDebugConsole";
    dbg.style.position = "fixed";
    dbg.style.top = "0";
    dbg.style.left = "0";
    dbg.style.right = "0";
    dbg.style.height = "40vh";
    dbg.style.background = "rgba(0,0,0,0.95)";
    dbg.style.color = "#00ff00";
    dbg.style.fontFamily = "monospace";
    dbg.style.fontSize = "14px";
    dbg.style.padding = "10px";
    dbg.style.zIndex = "999999";
    dbg.style.whiteSpace = "pre-wrap";
    dbg.style.overflowY = "scroll";
    dbg.style.borderBottom = "3px solid #0f0";
    dbg.style.display = "none"; // stays hidden unless clicked

    document.body.appendChild(dbg);

    // Toggle button
    const toggle = document.createElement("div");
    toggle.textContent = "[DEBUG]";
    toggle.style.position = "fixed";
    toggle.style.top = "0";
    toggle.style.right = "0";
    toggle.style.background = "#111";
    toggle.style.color = "#0f0";
    toggle.style.padding = "6px 10px";
    toggle.style.cursor = "pointer";
    toggle.style.zIndex = "1000000";
    toggle.style.fontFamily = "monospace";
    toggle.style.fontSize = "14px";
    toggle.style.border = "1px solid #0f0";

    // Track whether user manually opened it
    let debugEnabled = false;

    toggle.onclick = () => {
        debugEnabled = !debugEnabled;
        dbg.style.display = debugEnabled ? "block" : "none";
        if (debugEnabled) dbg.scrollTop = dbg.scrollHeight;
    };

    document.body.appendChild(toggle);

    // Global debug writer (NO auto-open)
    window.__DBG = function(msg) {
        dbg.textContent += msg + "\n";
        if (debugEnabled) dbg.scrollTop = dbg.scrollHeight;
    };

    // Crash catcher (writes to log, but does NOT auto-open)
    window.onerror = function(message, source, lineno, colno, error) {
        __DBG("üî•üî•üî• SCRIPT CRASHED üî•üî•üî•");
        __DBG("Message: " + message);
        __DBG("Source: " + source + ":" + lineno);
        if (error && error.stack) __DBG("Stack:\n" + error.stack);
    };

})();
// ---------- DEBUG BUTTON FLAME INDICATOR ----------
(function() {
    // Find your debug button once the DOM is ready
    function getDebugButton() {
        return document.getElementById("debugBtn") 
            || document.querySelector("[data-debug-btn]")
            || document.querySelector(".debug-button");
    }

    // Add a flame to the debug button
    function markDebugCrashed() {
        const btn = getDebugButton();
        if (!btn) return;

        if (!btn.dataset.crashed) {
            btn.dataset.crashed = "true";
            btn.textContent = btn.textContent + " üî•";
        }
    }

    // Wrap console.error
    const originalError = console.error;
    console.error = function(...args) {
        if (args.some(a => typeof a === "string" && a.includes("üî•"))) {
            markDebugCrashed();
        }
        originalError.apply(console, args);
    };

    // Wrap console.warn (optional)
    const originalWarn = console.warn;
    console.warn = function(...args) {
        if (args.some(a => typeof a === "string" && a.includes("üî•"))) {
            markDebugCrashed();
        }
        originalWarn.apply(console, args);
    };

    // Hook into your custom crash logger
    window.addEventListener("error", (e) => {
        if (String(e.message).includes("üî•")) {
            markDebugCrashed();
        }
    });

    // Optional: hook into your swoosh crash system
    window.addEventListener("CH_CRASH", () => {
        markDebugCrashed();
    });
})();


__DBG("BOOT: script started.1337");
__DBG(" GLOBAL LOG LOCK (Exclusive Write Control).");
// =======================================
// GLOBAL LOG LOCK (Exclusive Write Control)
// =======================================



        function nowStamp() {
            return new Date().toLocaleTimeString();
        }

function flipCallState(funcName) {
    // flip the booleans
    CALL_A = CALL_A === 1 ? 0 : 1;
    CALL_B = CALL_B === 1 ? 0 : 1;

    // log the function that fired
    console.log(`[TRACE] ${funcName} fired | A=${CALL_A} B=${CALL_B}`);
}

function wrapFunction(obj, fnName) {
    if (!INSTRUMENTATION_ENABLED) return;   // <-- HARD STOP

    const original = obj[fnName];

    if (typeof original !== "function") return;

    // Skip the wrapper and the instrumentation function
    if (fnName === "wrapFunction" || fnName === "instrumentAllFunctions") return;

    obj[fnName] = function(...args) {
        flipCallState(fnName);
        return original.apply(this, args);
    };
}

__DBG("past (function wrapFunction)133.");


function instrumentAllFunctions(root) {
    if (!INSTRUMENTATION_ENABLED) {
        __DBG("Instrumentation disabled ‚Äî skipping instrumentAllFunctions()");
        return;
    }

    for (const key in root) {
        try {
            if (typeof root[key] === "function") {
                wrapFunction(root, key);
            }
        } catch (e) {
            __DBG("Instrumentation skip for key: " + key);
        }
    }
}

__DBG("past (function instrumentAllFunctions(root))1122.");

function debugLog(msg) {
    if (!DEBUG_ENABLED) return;

    // Write to console only, never to the UI log
    console.log("[DEBUG " + nowStamp() + "] " + msg);
}

function logLine(text) {
    if (!LOG_UNLOCKED) {
        debugLog("logLine blocked (LOCKED): " + text);
        return;
    }

    const log = document.getElementById("log");
    log.textContent += "[" + nowStamp() + "] " + text + "\n";
    log.scrollTop = log.scrollHeight;
}
__DBG("past (function logLine(text)).1111333");

// Raw logger: bypasses LOG_UNLOCKED lock (used only by Swoosh Save)
function logRaw(text) {
    function attempt() {
        const log = document.getElementById("log");
        if (!log) {
            __DBG("logRaw: #log missing, retrying...");
            requestAnimationFrame(attempt);
            return;
        }
        log.textContent += text + "\n";
        log.scrollTop = log.scrollHeight;
    }
    attempt();
}

// =============================================================
// ## note collect these together //##
// RACE ‚Üí CLASS MAP
// =============================================================
window.CB2_RACE_CLASS_MAP = {
    human: [
        "warrior", "paladin", "ranger", "shadowknight",
        "bard", "rogue", "monk",
        "cleric", "druid", "shaman",
        "necromancer", "wizard", "magician", "enchanter"
    ],

   //review?
};

// start up boot cmplete^^




function freezeLogForSwoosh() {
    LOG_UNLOCKED = false;
    return new Promise(resolve => setTimeout(resolve, 2000)); // 2 sec quiet time
}
async function swooshSave() {

    // ‚≠ê Sync CB2 ‚Üí swoosh memory before saving
    if (typeof cb2_writeItemsIntoSwoosh === "function") {
        cb2_writeItemsIntoSwoosh();
    }

    // ‚≠ê Sync characters
    let cb2Characters = [];
    try {
        cb2Characters = CB2.characters || [];
        cb2_log("[SYNC] CB2.characters prepared for swoosh save.");
    } catch (e) {
        cb2_log("[SYNC ERROR] Failed to sync characters: " + e.message);
    }

    // ‚≠ê Sync tokens (optional but supported)
    let cb2Tokens = [];
    try {
        cb2Tokens = CB2.tokens || [];
        cb2_log("[SYNC] CB2.tokens prepared for swoosh save.");
    } catch (e) {
        cb2_log("[SYNC ERROR] Failed to sync tokens: " + e.message);
    }

    await freezeLogForSwoosh();
    __DBG("ENTER: swooshSave() Step 1: lock and wait");

    __DBG("DBG: Building fullDatabase object...");
    let fullDatabase;
    try {
        fullDatabase = {
            timestamp: new Date().toISOString(),
            registry: SpellRegistry,
            overrides: UserOverrides,
            custom: UserCustomSpells,
            classes: SpellClassAvailable,
            longTermTimers: LongTermTimersAPI.getAll(),

            // ‚≠ê Items now come from ItemRegistry (synced from CB2.items)
            items: ItemRegistry || [],

            // ‚≠ê Characters saved directly
            characters: cb2Characters,

            // ‚≠ê Tokens saved directly
            tokens: cb2Tokens
        };

        __DBG("DBG: fullDatabase object built successfully.");
    } catch (e) {
        __DBG("ERROR: fullDatabase BUILD FAILED: " + e.message);
        return;
    }

    __DBG("DBG: Attempting logRaw(SWOOSH_START)...");
    try {
        logRaw(SWOOSH_START);
        __DBG("ENTER: swooshSave Step 2: write swoosh block (SWOOSH_START)");
    } catch (e) {
        __DBG("ERROR: logRaw(SWOOSH_START) FAILED: " + e.message);
        return;
    }

    __DBG("DBG: Attempting logRaw(JSON)...");
    try {
        logRaw(JSON.stringify(fullDatabase, null, 2));
    } catch (e) {
        __DBG("ERROR: logRaw(JSON) FAILED: " + e.message);
        return;
    }

    __DBG("DBG: Attempting logRaw(SWOOSH_END)...");
    try {
        logRaw(SWOOSH_END);
        __DBG("ENTER: swooshSave Step 3: write swoosh block (SWOOSH_END)");
    } catch (e) {
        __DBG("ERROR: logRaw(SWOOSH_END) FAILED: " + e.message);
        return;
    }

    LOG_UNLOCKED = true;
    __DBG("ENTER: swooshSave Step 4: unlock");

    logLine("Swoosh Save Complete.");
    __DBG("ENTER: swooshSave() COMPLETE");
}


// -------------------------------
// CB2: Swoosh wrappers (tie into your existing swoosh system)
// Adjust these to call your real swoosh functions.
// -------------------------------
function cb2_swooshSave(key, data) {
    try {
        localStorage.setItem("cb2_" + key, JSON.stringify(data));
    } catch (e) {
        console.warn("CB2 swooshSave failed:", e);
    }
}

function cb2_swooshLoad(key, fallback) {
    try {
        const raw = localStorage.getItem("cb2_" + key);
        if (!raw) return fallback;
        return JSON.parse(raw);
    } catch (e) {
        console.warn("CB2 swooshLoad failed:", e);
        return fallback;
    }
}



// -------------------------------
// CB2: Utility logger (separate from your main log())
// -------------------------------
function cb2_log(msg) {
    const box = document.getElementById("cb2_debugConsole");
    if (!box) return;
    box.textContent += msg + "\n";
    box.scrollTop = box.scrollHeight;
}

// end chr savestuff


// chr button panel closers^^


        function logUnloggedMembers() {
            if (!inGroup || groupSize <= 1) return;
            const rows = groupMemberRows.querySelectorAll(".group-row");
            rows.forEach(row => {
                if (row.dataset.logged === "true") return;
                const idx = row.dataset.memberIndex;
                const clsSel = row.querySelector(".gm-class");
                const lvlInp = row.querySelector(".gm-level");
                const raceSel = row.querySelector(".gm-race");
                const nameInp = row.querySelector(".gm-name");
                if (!clsSel || !lvlInp || !raceSel || !nameInp) return;
                const cls = clsSel.value;
                const lvl = parseInt(lvlInp.value, 10) || 1;
                const race = raceSel.value;
                const name = nameInp.value.trim();
                if (!cls && !race && !name) return;
                let line = `Member ${idx} info: Class: ${cls}, Race: ${race}, Level: ${lvl}`;
                if (name) line += `, Name: ${name}`;
                logLine(line);
                row.dataset.logged = "true";
            });
        }

        function logLineWithRoster(text) {
            logUnloggedMembers();
            logLine(text);
        }

        function getClassTitle(cls, lvl) {
            lvl = parseInt(lvl, 10);
            if (isNaN(lvl)) return "";

            const map = {
                "BRD": ["Minstrel", "Troubadour", "Virtuoso"],
                "CLR": ["Vicar", "Templar", "High Priest"],
                "DRU": ["Wanderer", "Preserver", "Hierophant"],
                "ENC": ["Illusionist", "Beguiler", "Phantasmist"],
                "MAG": ["Elementalist", "Conjurer", "Arch Mage"],
                "MNK": ["Disciple", "Master", "Grandmaster"],
                "NEC": ["Heretic", "Defiler", "Warlock"],
                "PAL": ["Cavalier", "Knight", "Crusader"],
                "RNG": ["Pathfinder", "Outrider", "Warder"],
                "ROG": ["Rake", "Blackguard", "Assassin"],
                "SHD": ["Reaver", "Revenant", "Grave Lord"],
                "SHM": ["Mystic", "Luminary", "Oracle"],
                "WAR": ["Champion", "Myrmidon", "Warlord"],
                "WIZ": ["Channeler", "Evoker", "Sorcerer"]
            };

            if (lvl < 51) return "";
            if (lvl >= 51 && lvl <= 54) return map[cls]?.[0] || "";
            if (lvl >= 55 && lvl <= 59) return map[cls]?.[1] || "";
            if (lvl === 60) return map[cls]?.[2] || "";
            return "";
        }
__DBG("past (getClassTitle(cls, lvl)2211333");
        function updateXpBar(percent) {
            percent = Math.max(0, Math.min(100, percent));
            const fill = document.getElementById("xpBarFill");
            const text = document.getElementById("xpBarText");
            fill.style.width = percent + "%";
            text.textContent = "XP: " + percent + "%";
        }

        function formatMs(ms) {
            const totalSec = Math.max(0, Math.floor(ms / 1000));
            const m = Math.floor(totalSec / 60);
            const s = totalSec % 60;
            return (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
        }

        function makeBeep() {
            try {
                if (!window._audioCtx) {
                    window._audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const duration = 0.3;
                const osc = window._audioCtx.createOscillator();
                const gain = window._audioCtx.createGain();
                osc.type = "square";
                osc.frequency.value = 880;
                osc.connect(gain);
                gain.connect(window._audioCtx.destination);
                gain.gain.setValueAtTime(0.2, window._audioCtx.currentTime);
                osc.start();
                osc.stop(window._audioCtx.currentTime + duration);
            } catch (e) {}
        }
__DBG("past function makeBeep()22221111333");
        function downloadLog() {
            const logText = document.getElementById("log").textContent || "";
            const now = new Date();
            const pad = n => (n < 10 ? "0" + n : "" + n);
            const yyyy = now.getFullYear();
            const mm = pad(now.getMonth() + 1);
            const dd = pad(now.getDate());
            const hh = pad(now.getHours());
            const mi = pad(now.getMinutes());
            const ss = pad(now.getSeconds());
            const filename = `eq_session_log_${yyyy}-${mm}-${dd}_${hh}-${mi}-${ss}.txt`;

            const blob = new Blob([logText], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logLine(`Log exported as ${filename}`);
        }

        // ---------- STATE ----------
        let sessionActive = false;
        let sessionPaused = false;
        let xpPercent = 0;
        let xpTimerRunning = false;
        let xpTimerStartMs = null;
        let xpTimerInterval = null;
        let xpElapsedOffsetMs = 0;
        let last1pTimeMs = null;
        let lastGapText = "N/A";
        let mobsThisCycle = 0;
        let xpHistory = [];
        let xpTablePrinted = false;

        let mobTimerInterval = null;
        let mobRemainingMs = 0;
        let mobSoundOn = true;
        let mobTimerRunning = false;
        let mobTimerStartMs = null;
        let mobTimerOriginalMs = 0;

        let inGroup = false;
        let groupSize = 1;

        let extraTimerIdCounter = 1;
        const timerRegistry = {}; // id -> {type, labelFn, restartFn, checkboxEl, buttonEl}

        // ---------- ELEMENTS ----------
        const sessionNotes = document.getElementById("sessionNotes");
        const sessionNotesUpdateBtn = document.getElementById("sessionNotesUpdateBtn");

        const charNameInput = document.getElementById("charNameInput");
        const classSelect = document.getElementById("classSelect");
        const raceSelect = document.getElementById("raceSelect");
        const levelInput = document.getElementById("levelInput");
        const xpInput = document.getElementById("xpInput");
        const charNotes = document.getElementById("charNotes");
        const charNotesUpdateBtn = document.getElementById("charNotesUpdateBtn");
        const startSessionBtn = document.getElementById("startSessionBtn");
        const pauseSessionBtn = document.getElementById("pauseSessionBtn");
        const exportLogBtn = document.getElementById("exportLogBtn");
        const charTitleDisplay = document.getElementById("charTitleDisplay");

        const groupYesBtn = document.getElementById("groupYesBtn");
        const groupNoBtn = document.getElementById("groupNoBtn");
        const groupSizeWrapper = document.getElementById("groupSizeWrapper");
        const groupSizeInput = document.getElementById("groupSizeInput");
        const addMemberBtn = document.getElementById("addMemberBtn");
        const removeMemberBtn = document.getElementById("removeMemberBtn");
        const groupMembersContainer = document.getElementById("groupMembersContainer");
        const groupMemberRows = document.getElementById("groupMemberRows");

        const xpTimerToggleBtn = document.getElementById("xpTimerToggleBtn");
        const xpTimerDisplay = document.getElementById("xpTimerDisplay");
        const xpGainBtn = document.getElementById("xpGainBtn");
        const xpGainLateBtn = document.getElementById("xpGainLateBtn");
        const mobXpBtn = document.getElementById("mobXpBtn");
        const lastGapDisplay = document.getElementById("lastGapDisplay");
        const mobsThisCycleDisplay = document.getElementById("mobsThisCycleDisplay");
        const xpHistoryTableBody = document.querySelector("#xpHistoryTable tbody");
        const printXpTableBtn = document.getElementById("printXpTableBtn");

        const usingPetCheckbox = document.getElementById("usingPetCheckbox");
        const petSliderWrapper = document.getElementById("petSliderWrapper");
        const petDamageSlider = document.getElementById("petDamageSlider");
        const petSliderState = document.getElementById("petSliderState");

        const masterRestartCheckbox = document.getElementById("masterRestartCheckbox");
        const timerRestartList = document.getElementById("timerRestartList");
        const timerRestartButtons = document.getElementById("timerRestartButtons");

        const mobMinutes = document.getElementById("mobMinutes");
        const mobSeconds = document.getElementById("mobSeconds");
        const mobStartBtn = document.getElementById("mobStartBtn");
        const mobResetBtn = document.getElementById("mobResetBtn");
        const mobSoundToggleBtn = document.getElementById("mobSoundToggleBtn");
        const mobTimerDisplay = document.getElementById("mobTimerDisplay");
        const mobNotes = document.getElementById("mobNotes");
        const mobNotesUpdateBtn = document.getElementById("mobNotesUpdateBtn");

        const addCycleTimerBtn = document.getElementById("addCycleTimerBtn");
        const addStopwatchBtn = document.getElementById("addStopwatchBtn");
        const extraTimersContainer = document.getElementById("extraTimersContainer");
__DBG("past ---------- ELEMENTS ----------33331111333");
        // ---------- NOTES BUTTONS ----------
        sessionNotesUpdateBtn.addEventListener("click", () => {
            const txt = sessionNotes.value.trim();
            if (!txt) {
                logLineWithRoster("Session notes cleared.");
            } else {
                logLineWithRoster(`Session notes updated: "${txt}"`);
            }
        });

        charNotesUpdateBtn.addEventListener("click", () => {
            const txt = charNotes.value.trim();
            if (!txt) {
                logLineWithRoster("Character notes cleared.");
            } else {
                logLineWithRoster(`Character notes updated: "${txt}"`);
            }
        });

        mobNotesUpdateBtn.addEventListener("click", () => {
            const txt = mobNotes.value.trim();
            if (!txt) {
                logLineWithRoster("Main mob timer notes cleared.");
            } else {
                logLineWithRoster(`Main mob timer notes updated: "${txt}"`);
            }
        });

        // ---------- GROUP UI ----------
        function updateGroupButtons() {
            groupSizeInput.value = groupSize;
            addMemberBtn.disabled = (groupSize >= 6);
            removeMemberBtn.disabled = (groupSize <= 1);
            groupYesBtn.disabled = inGroup;
            groupNoBtn.disabled = !inGroup;
        }

        function rebuildGroupMemberRows() {
            groupMemberRows.innerHTML = "";
            for (let i = 2; i <= groupSize; i++) {
                const row = document.createElement("div");
                row.className = "group-row";
                row.dataset.memberIndex = i;
                row.dataset.logged = "false";

                const label = document.createElement("span");
                label.textContent = `Member ${i}: `;

                const nameInput = document.createElement("input");
                nameInput.type = "text";
                nameInput.placeholder = "Name (optional)";
                nameInput.style.width = "110px";
                nameInput.className = "gm-name";

                const noteInput = document.createElement("input");
                noteInput.type = "text";
                noteInput.placeholder = "Note";
                noteInput.style.width = "120px";
                noteInput.className = "gm-note";

                const noteBtn = document.createElement("button");
                noteBtn.textContent = "Update Notes";
                noteBtn.className = "gm-note-update";

                const clsSel = document.createElement("select");
                clsSel.innerHTML = classSelect.innerHTML;
                clsSel.className = "gm-class";

                const lvlInput = document.createElement("input");
                lvlInput.type = "number";
                lvlInput.min = "1";
                lvlInput.max = "60";
                lvlInput.value = "50";
                lvlInput.style.width = "50px";
                lvlInput.className = "gm-level";

                const raceSel = document.createElement("select");
                raceSel.innerHTML = raceSelect.innerHTML;
                raceSel.className = "gm-race";

                row.appendChild(label);
                row.appendChild(document.createTextNode("Class: "));
                row.appendChild(clsSel);
                row.appendChild(document.createTextNode(" Level: "));
                row.appendChild(lvlInput);
                row.appendChild(document.createTextNode(" Race: "));
                row.appendChild(raceSel);
                row.appendChild(document.createTextNode(" Name: "));
                row.appendChild(nameInput);
                row.appendChild(document.createTextNode(" Note: "));
                row.appendChild(noteInput);
                row.appendChild(noteBtn);

                noteBtn.addEventListener("click", () => {
                    const idx = row.dataset.memberIndex;
                    const noteTxt = noteInput.value.trim();
                    if (!noteTxt) {
                        logLineWithRoster(`Member ${idx} notes cleared.`);
                    } else {
                        logLineWithRoster(`Member ${idx} notes updated: "${noteTxt}"`);
                    }
                });

                groupMemberRows.appendChild(row);
            }
        }
__DBG("past rebuildGroupMemberRows()44431111333");
        function pauseXpTimerForGroupChange(newStateText) {
            if (!xpTimerRunning) {
                logLineWithRoster(`Group state changed: ${newStateText} (XP timer idle).`);
                return;
            }
            const now = Date.now();
            const elapsed = now - xpTimerStartMs + xpElapsedOffsetMs;
            xpElapsedOffsetMs = elapsed;
            if (xpTimerInterval) clearInterval(xpTimerInterval);
            xpTimerInterval = null;
            xpTimerDisplay.textContent = Math.floor(elapsed / 1000) + "s";
            logLineWithRoster(`Group state changed: ${newStateText} (XP timer paused briefly).`);
            xpTimerStartMs = Date.now();
            xpTimerInterval = setInterval(() => {
                const elapsedSec = Math.floor((Date.now() - xpTimerStartMs + xpElapsedOffsetMs) / 1000);
                xpTimerDisplay.textContent = elapsedSec + "s";
            }, 500);
            logLineWithRoster("Group time tracking updated.");
        }

        groupYesBtn.addEventListener("click", () => {
            if (inGroup) return;
            inGroup = true;
            groupSizeWrapper.style.display = "inline";
            groupMembersContainer.style.display = "block";
            groupSize = Math.max(1, Math.min(6, parseInt(groupSizeInput.value, 10) || 1));
            updateGroupButtons();
            rebuildGroupMemberRows();
            pauseXpTimerForGroupChange("JOINED GROUP");
        });

        groupNoBtn.addEventListener("click", () => {
            if (!inGroup) return;
            inGroup = false;
            groupSize = 1;
            groupSizeWrapper.style.display = "none";
            groupMembersContainer.style.display = "none";
            updateGroupButtons();
            rebuildGroupMemberRows();
            pauseXpTimerForGroupChange("LEFT GROUP (SOLO)");
        });

        groupSizeInput.addEventListener("change", () => {
            let val = parseInt(groupSizeInput.value, 10) || 1;
            val = Math.max(1, Math.min(6, val));
            groupSize = val;
            updateGroupButtons();
            rebuildGroupMemberRows();
        });

        addMemberBtn.addEventListener("click", () => {
    if (groupSize >= 6) return;

    groupSize++;
    updateGroupButtons();

    const idx = groupSize;

    // Create a new row WITHOUT rebuilding the others
    const row = document.createElement("div");
    row.className = "group-row";
    row.dataset.memberIndex = idx;
    row.dataset.logged = "false";

    const label = document.createElement("span");
    label.textContent = `Member ${idx}: `;

    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.placeholder = "Name (optional)";
    nameInput.style.width = "110px";
    nameInput.className = "gm-name";

    const noteInput = document.createElement("input");
    noteInput.type = "text";
    noteInput.placeholder = "Note";
    noteInput.style.width = "120px";
    noteInput.className = "gm-note";

    const noteBtn = document.createElement("button");
    noteBtn.textContent = "Update Notes";
    noteBtn.className = "gm-note-update";

    const clsSel = document.createElement("select");
    clsSel.innerHTML = classSelect.innerHTML;
    clsSel.className = "gm-class";

    const lvlInput = document.createElement("input");
    lvlInput.type = "number";
    lvlInput.min = "1";
    lvlInput.max = "60";
    lvlInput.value = "50";
    lvlInput.style.width = "50px";
    lvlInput.className = "gm-level";

    const raceSel = document.createElement("select");
    raceSel.innerHTML = raceSelect.innerHTML;
    raceSel.className = "gm-race";

    row.appendChild(label);
    row.appendChild(document.createTextNode("Class: "));
    row.appendChild(clsSel);
    row.appendChild(document.createTextNode(" Level: "));
    row.appendChild(lvlInput);
    row.appendChild(document.createTextNode(" Race: "));
    row.appendChild(raceSel);
    row.appendChild(document.createTextNode(" Name: "));
    row.appendChild(nameInput);
    row.appendChild(document.createTextNode(" Note: "));
    row.appendChild(noteInput);
    row.appendChild(noteBtn);

    noteBtn.addEventListener("click", () => {
        const noteTxt = noteInput.value.trim();
        if (!noteTxt) {
            logLineWithRoster(`Member ${idx} notes cleared.`);
        } else {
            logLineWithRoster(`Member ${idx} notes updated: "${noteTxt}"`);
        }
    });

    groupMemberRows.appendChild(row);

    logLineWithRoster(`Member ${idx} added (empty fields).`);
});


        removeMemberBtn.addEventListener("click", () => {
    if (groupSize <= 1) return;

    const rows = Array.from(groupMemberRows.querySelectorAll(".group-row"));
    let removed = false;

    for (const row of rows) {
        const clsSel = row.querySelector(".gm-class");
        if (clsSel && clsSel.value === "DELETE") {
            const idx = row.dataset.memberIndex;

            const lvlInp = row.querySelector(".gm-level");
            const raceSel = row.querySelector(".gm-race");
            const nameInp = row.querySelector(".gm-name");

            const cls = clsSel.value;
            const lvl = parseInt(lvlInp.value, 10) || 1;
            const race = raceSel.value;
            const name = nameInp.value.trim();

            if (confirm(`Remove Member ${idx}?`)) {
                let line = `Member ${idx} removed (Class: ${cls}, Race: ${race}, Level: ${lvl}`;
                if (name) line += `, Name: ${name}`;
                line += ")";
                logLineWithRoster(line);

                // Remove ONLY this row
                row.remove();
                groupSize--;

                // Reindex remaining rows WITHOUT resetting their values
                const remaining = Array.from(groupMemberRows.querySelectorAll(".group-row"));
                remaining.forEach((r, i) => {
                    const newIndex = i + 2; // Member 2‚Äì6
                    r.dataset.memberIndex = newIndex;
                    r.querySelector("span").textContent = `Member ${newIndex}: `;
                });

                updateGroupButtons();
                removed = true;
            }
            break;
        }
    }

    if (!removed) {
        logLineWithRoster("No member marked as DELETE. Set a member's class to DELETE MEMBER, then press Remove.");
    }
});


        // ---------- XP HISTORY TABLE ----------
        function renderXpHistory() {
            xpHistoryTableBody.innerHTML = "";
            xpHistory.slice(0, 100).forEach((entry, index) => {
                const tr = document.createElement("tr");

                const tdLvl = document.createElement("td");
                const tdGap = document.createElement("td");
                const tdMobs = document.createElement("td");
                const tdNotes = document.createElement("td");
                const tdUpdate = document.createElement("td");

                tdLvl.textContent = entry.levelPercent + "%";

                const gapInput = document.createElement("input");
                gapInput.type = "text";
                gapInput.value = entry.gap;
                gapInput.className = "xp-edit-input";
                tdGap.appendChild(gapInput);

                const mobsInput = document.createElement("input");
                mobsInput.type = "number";
                mobsInput.value = entry.mobs;
                mobsInput.className = "xp-edit-input";
                tdMobs.appendChild(mobsInput);

                const noteInput = document.createElement("input");
                noteInput.type = "text";
                noteInput.value = entry.note || "";
                noteInput.className = "xp-note-input";
                tdNotes.appendChild(noteInput);

                const updateBtn = document.createElement("button");
                updateBtn.textContent = "Update";
                updateBtn.style.fontSize = "10px";
                tdUpdate.appendChild(updateBtn);

                updateBtn.addEventListener("click", () => {
                    const oldGap = entry.gap;
                    const oldMobs = entry.mobs;
                    const oldNote = entry.note || "";
                    entry.gap = gapInput.value.trim() || oldGap;
                    entry.mobs = parseInt(mobsInput.value, 10) || oldMobs;
                    entry.note = noteInput.value.trim();
                    logLineWithRoster(
                        `XP Table Row ${index + 1} updated: Gap="${entry.gap}", Mobs=${entry.mobs}, Notes="${entry.note || ""}"`
                    );
                    renderXpHistory();
                });

                tr.appendChild(tdLvl);
                tr.appendChild(tdGap);
                tr.appendChild(tdMobs);
                tr.appendChild(tdNotes);
                tr.appendChild(tdUpdate);
                xpHistoryTableBody.appendChild(tr);
            });
        }

        function printXpTableToLog() {
            if (!xpHistory.length) {
                logLineWithRoster("XP Table is empty, nothing to print.");
                return;
            }
            logLineWithRoster("XP Table Dump:");
            xpHistory.forEach((entry, idx) => {
                logLine(
                    `Row ${idx + 1}: ${entry.levelPercent}% ‚Äî Gap="${entry.gap}", Mobs=${entry.mobs}, Notes="${entry.note || ""}"`
                );
            });
            xpTablePrinted = true;
        }

        printXpTableBtn.addEventListener("click", () => {
            printXpTableToLog();
        });

        // ---------- PET LOGIC ----------
        usingPetCheckbox.addEventListener("change", () => {
            if (usingPetCheckbox.checked) {
                petSliderWrapper.style.display = "block";
            } else {
                petSliderWrapper.style.display = "none";
            }
        });

        petDamageSlider.addEventListener("input", () => {
            const val = parseInt(petDamageSlider.value, 10);
            if (val >= 50) {
                petSliderState.textContent = "Current: YOU get full XP";
            } else {
                petSliderState.textContent = "Current: PET did more damage (XP penalty)";
            }
        });

        function describePetXpSplit() {
            if (!usingPetCheckbox.checked) return "No pet";
            const val = parseInt(petDamageSlider.value, 10);
            if (val >= 50) return "Full XP (you outdamaged pet)";
            return "Pet penalty applied (50% XP)";
        }

        // ---------- SESSION ----------
        startSessionBtn.addEventListener("click", () => {
            if (sessionActive) {
                logLineWithRoster("Session already active. Start Session is locked.");
                return;
            }

            const cls = classSelect.value;
            const race = raceSelect.value;
            const lvl = parseInt(levelInput.value, 10) || 1;
            const xp = parseInt(xpInput.value, 10) || 0;
            const name = charNameInput.value.trim();

            sessionActive = true;
            sessionPaused = false;
            pauseSessionBtn.disabled = false;
            pauseSessionBtn.textContent = "Pause Session";
            startSessionBtn.disabled = true;

            xpPercent = Math.max(0, Math.min(100, xp));
            updateXpBar(xpPercent);

            const title = getClassTitle(cls, lvl);
            const baseClassText = title ? `Level ${lvl} ${title} (${cls})` : `Level ${lvl} ${cls}`;
            const namePart = name ? `${name} ‚Äî ` : "";
            charTitleDisplay.textContent = `${namePart}${baseClassText} ‚Äî Race: ${race}`;
            logLineWithRoster(`Session started ‚Äî ${namePart}${baseClassText}, Race: ${race}, XP: ${xpPercent}%`);

            if (!inGroup || groupSize === 1) {
                logLineWithRoster("Group: NO (solo)");
            } else {
                logLineWithRoster(`Group: YES ‚Äî ${groupSize} total members`);
                const youLine = `Member 1: ${cls} ${lvl} ${race} (you${name ? ", " + name : ""})`;
                logLineWithRoster(youLine);

                const rows = groupMemberRows.querySelectorAll(".group-row");
                rows.forEach(row => {
                    const idx = row.dataset.memberIndex;
                    const cSel = row.querySelector(".gm-class");
                    const lInp = row.querySelector(".gm-level");
                    const rSel = row.querySelector(".gm-race");
                    const nInp = row.querySelector(".gm-name");
                    const noteInp = row.querySelector(".gm-note");
                    const cVal = cSel.value;
                    const lVal = parseInt(lInp.value, 10) || 1;
                    const rVal = rSel.value;
                    const nVal = nInp.value.trim();
                    const noteVal = noteInp.value.trim();
                    let line = `Member ${idx}: ${cVal} ${lVal} ${rVal}`;
                    if (nVal) line += `, Name: ${nVal}`;
                    if (noteVal) line += `, Note: ${noteVal}`;
                    logLine(line);
                    row.dataset.logged = "true";
                });
            }

            xpTimerRunning = false;
            xpTimerStartMs = null;
            xpElapsedOffsetMs = 0;
            last1pTimeMs = null;
            lastGapText = "N/A";
            lastGapDisplay.textContent = lastGapText;
            xpTimerDisplay.textContent = "0s";
            xpTimerToggleBtn.textContent = "Track XP Timer: OFF";
            xpGainBtn.disabled = true;
            xpGainLateBtn.disabled = true;
            mobXpBtn.disabled = true;

            mobsThisCycle = 0;
            mobsThisCycleDisplay.textContent = "0";
            xpHistory = [];
            xpTablePrinted = false;
            renderXpHistory();
        });

        pauseSessionBtn.addEventListener("click", () => {
            if (!sessionActive) return;

            if (!sessionPaused) {
                sessionPaused = true;
                pauseSessionBtn.textContent = "Resume Session";

                if (xpTimerRunning) {
                    const now = Date.now();
                    const elapsed = now - xpTimerStartMs + xpElapsedOffsetMs;
                    xpElapsedOffsetMs = elapsed;
                    if (xpTimerInterval) clearInterval(xpTimerInterval);
                    xpTimerInterval = null;
                    xpTimerDisplay.textContent = Math.floor(elapsed / 1000) + "s";
                }

                xpTimerRunning = false;
                xpTimerToggleBtn.textContent = "Track XP Timer: OFF";
                xpGainBtn.disabled = true;
                xpGainLateBtn.disabled = true;
                mobXpBtn.disabled = true;

                logLineWithRoster("Session paused (XP tracking halted, mob timers continue).");

                // auto-print XP table once when session is paused for the first time
                if (!xpTablePrinted && xpHistory.length > 0) {
                    printXpTableToLog();
                }
            } else {
                sessionPaused = false;
                pauseSessionBtn.textContent = "Pause Session";
                logLineWithRoster("Session resumed.");

                if (xpElapsedOffsetMs > 0) {
                    xpTimerStartMs = Date.now();
                    xpTimerInterval = setInterval(() => {
                        const elapsedSec = Math.floor((Date.now() - xpTimerStartMs + xpElapsedOffsetMs) / 1000);
                        xpTimerDisplay.textContent = elapsedSec + "s";
                    }, 500);
                    xpTimerRunning = true;
                    xpTimerToggleBtn.textContent = "Track XP Timer: ON";
                    xpGainBtn.disabled = false;
                    xpGainLateBtn.disabled = false;
                    mobXpBtn.disabled = false;
                }
            }
        });

        exportLogBtn.addEventListener("click", downloadLog);

        // ---------- XP TIMER ----------
        xpTimerToggleBtn.addEventListener("click", () => {
            if (!sessionActive) {
                logLineWithRoster("Cannot start XP timer ‚Äî no active session.");
                return;
            }
            if (sessionPaused) {
                logLineWithRoster("Cannot change XP timer while session is paused.");
                return;
            }

            if (!xpTimerRunning) {
                xpTimerRunning = true;
                xpTimerToggleBtn.textContent = "Track XP Timer: ON";
                xpGainBtn.disabled = false;
                xpGainLateBtn.disabled = false;
                mobXpBtn.disabled = false;

                xpTimerStartMs = Date.now();
                if (!last1pTimeMs) {
                    last1pTimeMs = Date.now();
                }

                if (xpTimerInterval) clearInterval(xpTimerInterval);
                xpTimerInterval = setInterval(() => {
                    const elapsedSec = Math.floor((Date.now() - xpTimerStartMs + xpElapsedOffsetMs) / 1000);
                    xpTimerDisplay.textContent = elapsedSec + "s";
                }, 500);

                logLineWithRoster("XP timer started.");
            } else {
                xpTimerRunning = false;
                xpTimerToggleBtn.textContent = "Track XP Timer: OFF";
                xpGainBtn.disabled = true;
                xpGainLateBtn.disabled = true;
                mobXpBtn.disabled = true;

                if (xpTimerInterval) clearInterval(xpTimerInterval);
                xpTimerInterval = null;

                const now = Date.now();
                const elapsed = now - xpTimerStartMs + xpElapsedOffsetMs;
                xpElapsedOffsetMs = elapsed;
                xpTimerDisplay.textContent = Math.floor(elapsed / 1000) + "s";

                logLineWithRoster("XP timer stopped.");
            }
        });

        function handleXpGain(isLate) {
            if (!sessionActive || !xpTimerRunning || sessionPaused) return;

            const now = Date.now();
            if (last1pTimeMs) {
                const gapSec = Math.floor((now - last1pTimeMs) / 1000);
                lastGapText = gapSec + "s";
            } else {
                lastGapText = "First 1% this session";
            }
            last1pTimeMs = now;
            lastGapDisplay.textContent = lastGapText;

            const mobsForThis = mobsThisCycle;
            xpPercent = Math.min(100, xpPercent + 1);
            updateXpBar(xpPercent);

            const petSplit = describePetXpSplit();
            const mobsText = `Mobs this 1%: ${mobsForThis}`;
            if (!isLate) {
                logLineWithRoster(`XP +1% ‚Äî Gap: ${lastGapText} ‚Äî ${mobsText} ‚Äî ${petSplit}`);
            } else {
                logLineWithRoster(`XP +1% (late input) ‚Äî Gap: ${lastGapText} ‚Äî ${mobsText} ‚Äî ${petSplit}`);
            }

            if (xpHistory.length < 100) {
                xpHistory.push({
                    levelPercent: xpPercent,
                    gap: lastGapText,
                    mobs: mobsForThis,
                    note: ""
                });
                renderXpHistory();
            }

            mobsThisCycle = 0;
            mobsThisCycleDisplay.textContent = "0";
        }

        xpGainBtn.addEventListener("click", () => handleXpGain(false));
        xpGainLateBtn.addEventListener("click", () => handleXpGain(true));

        function restartSelectedTimersFromMobXp(sourceLabel) {
            const restarted = [];
            Object.values(timerRegistry).forEach(entry => {
                if (entry.checkboxEl && entry.checkboxEl.checked) {
                    entry.restartFn();
                    restarted.push(entry.labelFn());
                }
            });
            if (restarted.length) {
                logLineWithRoster(`Mob XP +1 (${sourceLabel}) ‚Äî Restarted: ${restarted.join(", ")}`);
            } else {
                logLineWithRoster(`Mob XP +1 (${sourceLabel}) ‚Äî No timers restarted.`);
            }
        }

        mobXpBtn.addEventListener("click", () => {
            if (!sessionActive || !xpTimerRunning || sessionPaused) return;
            mobsThisCycle++;
            mobsThisCycleDisplay.textContent = String(mobsThisCycle);
            const petSplit = describePetXpSplit();
            logLineWithRoster(`Mob XP +1 ‚Äî Total this cycle: ${mobsThisCycle} ‚Äî ${petSplit}`);
            if (masterRestartCheckbox.checked) {
                restartSelectedTimersFromMobXp("Global");
            }
        });

        // ---------- MAIN MOB TIMER ----------
        function registerMainMobTimer() {
            timerRegistry["mainMob"] = {
                type: "cycle",
                labelFn: () => "Main Mob Timer",
                restartFn: () => {
                    const mins = parseInt(mobMinutes.value, 10) || 0;
                    const secs = parseInt(mobSeconds.value, 10) || 0;
                    const totalMs = (mins * 60 + secs) * 1000;
                    if (totalMs <= 0) return;
                    if (mobTimerInterval) clearInterval(mobTimerInterval);
                    mobTimerOriginalMs = totalMs;
                    mobRemainingMs = totalMs;
                    mobTimerDisplay.textContent = formatMs(mobRemainingMs);
                    mobStartBtn.classList.remove("flash");
                    mobTimerRunning = true;
                    mobStartBtn.textContent = "Pause";
                    mobTimerStartMs = Date.now();
                    mobTimerInterval = setInterval(() => {
                        const elapsed = Date.now() - mobTimerStartMs;
                        mobRemainingMs = mobTimerOriginalMs - elapsed;
                        if (mobRemainingMs <= 0) {
                            mobRemainingMs = 0;
                            mobTimerDisplay.textContent = "00:00";
                            clearInterval(mobTimerInterval);
                            mobTimerInterval = null;
                            mobTimerRunning = false;
                            mobStartBtn.textContent = "Start";
                            mobStartBtn.classList.add("flash");
                            logLineWithRoster("Mob cycle timer finished.");
                            if (mobSoundOn) makeBeep();
                        } else {
                            mobTimerDisplay.textContent = formatMs(mobRemainingMs);
                        }
                    }, 500);
                },
                checkboxEl: null,
                buttonEl: null
            };
            rebuildTimerRestartUI();
        }

        mobSoundToggleBtn.addEventListener("click", () => {
            mobSoundOn = !mobSoundOn;
            mobSoundToggleBtn.textContent = "Sound Alarm: " + (mobSoundOn ? "ON" : "OFF");
            logLineWithRoster("Mob timer sound alarm turned " + (mobSoundOn ? "ON" : "OFF") + ".");
        });

        mobStartBtn.addEventListener("click", () => {
            const mins = parseInt(mobMinutes.value, 10) || 0;
            const secs = parseInt(mobSeconds.value, 10) || 0;
            const totalMs = (mins * 60 + secs) * 1000;

            if (!mobTimerRunning) {
                if (totalMs <= 0 && mobRemainingMs <= 0) {
                    logLineWithRoster("Mob timer not started ‚Äî duration must be > 0.");
                    return;
                }
                if (mobRemainingMs <= 0) {
                    mobTimerOriginalMs = totalMs;
                    mobRemainingMs = totalMs;
                }
                mobStartBtn.classList.remove("flash");
                mobTimerRunning = true;
                mobStartBtn.textContent = "Pause";
                mobTimerStartMs = Date.now();
                if (mobTimerInterval) clearInterval(mobTimerInterval);
                mobTimerInterval = setInterval(() => {
                    const elapsed = Date.now() - mobTimerStartMs;
                    mobRemainingMs = mobTimerOriginalMs - elapsed;
                    if (mobRemainingMs <= 0) {
                        mobRemainingMs = 0;
                        mobTimerDisplay.textContent = "00:00";
                        clearInterval(mobTimerInterval);
                        mobTimerInterval = null;
                        mobTimerRunning = false;
                        mobStartBtn.textContent = "Start";
                        mobStartBtn.classList.add("flash");
                        logLineWithRoster("Mob cycle timer finished.");
                        if (mobSoundOn) makeBeep();
                    } else {
                        mobTimerDisplay.textContent = formatMs(mobRemainingMs);
                    }
                }, 500);
                logLineWithRoster(`Mob cycle timer started/resumed: ${mins}m ${secs}s.`);
            } else {
                mobTimerRunning = false;
                mobStartBtn.textContent = "Continue";
                if (mobTimerInterval) clearInterval(mobTimerInterval);
                mobTimerInterval = null;
                mobTimerOriginalMs = mobRemainingMs;
                logLineWithRoster(`Mob cycle timer paused at ${formatMs(mobRemainingMs)}.`);
            }
        });

        mobResetBtn.addEventListener("click", () => {
            if (mobTimerInterval) clearInterval(mobTimerInterval);
            mobTimerInterval = null;
            mobTimerRunning = false;
            mobStartBtn.textContent = "Start";
            mobStartBtn.classList.remove("flash");
            const mins = parseInt(mobMinutes.value, 10) || 0;
            const secs = parseInt(mobSeconds.value, 10) || 0;
            mobRemainingMs = (mins * 60 + secs) * 1000;
            mobTimerOriginalMs = mobRemainingMs;
            mobTimerDisplay.textContent = formatMs(mobRemainingMs);
            logLineWithRoster("Mob cycle timer reset.");
        });

        // ---------- EXTRA TIMERS (CYCLE + STOPWATCH) ----------
        function rebuildTimerRestartUI() {
            timerRestartList.innerHTML = "";
            timerRestartButtons.innerHTML = "";

            Object.entries(timerRegistry).forEach(([id, entry]) => {
                const label = entry.labelFn();

                const cbLabel = document.createElement("label");
                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.dataset.timerId = id;
                cbLabel.appendChild(cb);
                cbLabel.appendChild(document.createTextNode(" " + label + " "));
                timerRestartList.appendChild(cbLabel);

                entry.checkboxEl = cb;

                if (masterRestartCheckbox.checked) {
                    const btn = document.createElement("button");
                    btn.textContent = `+1 Mob (${label})`;
                    btn.style.fontSize = "10px";
                    btn.addEventListener("click", () => {
                        if (!sessionActive || !xpTimerRunning || sessionPaused) return;
                        mobsThisCycle++;
                        mobsThisCycleDisplay.textContent = String(mobsThisCycle);
                        const petSplit = describePetXpSplit();
                        entry.restartFn();
                        logLineWithRoster(`Mob XP +1 (${label}) ‚Äî Timer restarted ‚Äî ${petSplit}`);
                    });
                    timerRestartButtons.appendChild(btn);
                    entry.buttonEl = btn;
                } else {
                    entry.buttonEl = null;
                }
            });
        }

        masterRestartCheckbox.addEventListener("change", () => {
            rebuildTimerRestartUI();
        });

        function createCycleTimer() {
            const id = "cycle_" + (extraTimerIdCounter++);
            const wrapper = document.createElement("div");
            wrapper.className = "subtimer";
            wrapper.dataset.timerId = id;
            wrapper.dataset.type = "cycle";

            const labelInput = document.createElement("input");
            labelInput.type = "text";
            labelInput.placeholder = "Label (optional)";
            labelInput.style.width = "140px";

            const noteInput = document.createElement("input");
            noteInput.type = "text";
            noteInput.placeholder = "Notes";
            noteInput.style.width = "140px";

            const noteBtn = document.createElement("button");
            noteBtn.textContent = "Update Notes";

            const minInput = document.createElement("input");
            minInput.type = "number";
            minInput.min = "0";
            minInput.value = "22";
            minInput.style.width = "50px";

            const secInput = document.createElement("input");
            secInput.type = "number";
            secInput.min = "0";
            secInput.max = "59";
            secInput.value = "0";
            secInput.style.width = "50px";

            const startPauseBtn = document.createElement("button");
            startPauseBtn.textContent = "Start";

            const resetBtn = document.createElement("button");
            resetBtn.textContent = "Reset";

            const alarmBtn = document.createElement("button");
            alarmBtn.textContent = "Alarm: ON";

            const deleteBtn = document.createElement("button");
            deleteBtn.textContent = "Delete";

            const display = document.createElement("span");
            display.style.marginLeft = "10px";
            display.textContent = "00:00";

            wrapper.appendChild(document.createTextNode("Cycle Timer ‚Äî "));
            wrapper.appendChild(labelInput);
            wrapper.appendChild(document.createTextNode("  M:"));
            wrapper.appendChild(minInput);
            wrapper.appendChild(document.createTextNode(" S:"));
            wrapper.appendChild(secInput);
            wrapper.appendChild(startPauseBtn);
            wrapper.appendChild(resetBtn);
            wrapper.appendChild(alarmBtn);
            wrapper.appendChild(deleteBtn);
            wrapper.appendChild(display);
            wrapper.appendChild(document.createElement("br"));
            wrapper.appendChild(document.createTextNode("Notes: "));
            wrapper.appendChild(noteInput);
            wrapper.appendChild(noteBtn);

            let interval = null;
            let remainingMs = 0;
            let running = false;
            let alarmOn = true;
            let originalMs = 0;

            function labelOrDefault() {
                return labelInput.value.trim() || `CycleTimer#${id.split("_")[1]}`;
            }

            function startTimer() {
                const mins = parseInt(minInput.value, 10) || 0;
                const secs = parseInt(secInput.value, 10) || 0;
                const totalMs = (mins * 60 + secs) * 1000;
                if (totalMs <= 0) {
                    logLineWithRoster("Extra cycle timer not started ‚Äî duration must be > 0.");
                    return;
                }
                originalMs = totalMs;
                remainingMs = totalMs;
                display.textContent = formatMs(remainingMs);
                wrapper.classList.remove("flash");

                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' started: ${mins}m ${secs}s.`);

                interval = setInterval(() => {
                    remainingMs -= 500;
                    if (remainingMs <= 0) {
                        remainingMs = 0;
                        display.textContent = "00:00";
                        clearInterval(interval);
                        interval = null;
                        running = false;
                        startPauseBtn.textContent = "Start";
                        wrapper.classList.add("flash");
                        const lbl = labelOrDefault();
                        logLineWithRoster(`Extra cycle timer '${lbl}' finished.`);
                        if (alarmOn) makeBeep();
                    } else {
                        display.textContent = formatMs(remainingMs);
                    }
                }, 500);
                running = true;
                startPauseBtn.textContent = "Pause";
            }

            function pauseTimer() {
                if (interval) {
                    clearInterval(interval);
                    interval = null;
                }
                running = false;
                startPauseBtn.textContent = "Continue";
                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' paused at ${formatMs(remainingMs)}.`);
            }

            function continueTimer() {
                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' continued.`);
                interval = setInterval(() => {
                    remainingMs -= 500;
                    if (remainingMs <= 0) {
                        remainingMs = 0;
                        display.textContent = "00:00";
                        clearInterval(interval);
                        interval = null;
                        running = false;
                        startPauseBtn.textContent = "Start";
                        wrapper.classList.add("flash");
                        const lbl = labelOrDefault();
                        logLineWithRoster(`Extra cycle timer '${lbl}' finished.`);
                        if (alarmOn) makeBeep();
                    } else {
                        display.textContent = formatMs(remainingMs);
                    }
                }, 500);
                running = true;
                startPauseBtn.textContent = "Pause";
            }

            startPauseBtn.addEventListener("click", () => {
                if (!running && remainingMs === 0) {
                    startTimer();
                } else if (running) {
                    pauseTimer();
                } else {
                    continueTimer();
                }
            });

            resetBtn.addEventListener("click", () => {
                if (interval) {
                    clearInterval(interval);
                    interval = null;
                }
                running = false;
                const mins = parseInt(minInput.value, 10) || 0;
                const secs = parseInt(secInput.value, 10) || 0;
                remainingMs = (mins * 60 + secs) * 1000;
                originalMs = remainingMs;
                display.textContent = formatMs(remainingMs);
                wrapper.classList.remove("flash");
                startPauseBtn.textContent = "Start";
                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' reset.`);
            });

            alarmBtn.addEventListener("click", () => {
                alarmOn = !alarmOn;
                alarmBtn.textContent = "Alarm: " + (alarmOn ? "ON" : "OFF");
                const label = labelOrDefault();
                logLineWithRoster(`Extra cycle timer '${label}' alarm turned ${alarmOn ? "ON" : "OFF"}.`);
            });

            deleteBtn.addEventListener("click", () => {
                const label = labelOrDefault();
                if (confirm(`Delete extra cycle timer '${label}'?`)) {
                    if (interval) clearInterval(interval);
                    delete timerRegistry[id];
                    wrapper.remove();
                    logLineWithRoster(`Extra cycle timer '${label}' deleted.`);
                    rebuildTimerRestartUI();
                }
            });

            noteBtn.addEventListener("click", () => {
                const label = labelOrDefault();
                const txt = noteInput.value.trim();
                if (!txt) {
                    logLineWithRoster(`Extra cycle timer '${label}' notes cleared.`);
                } else {
                    logLineWithRoster(`Extra cycle timer '${label}' notes updated: "${txt}"`);
                }
            });

            extraTimersContainer.appendChild(wrapper);

            timerRegistry[id] = {
                type: "cycle",
                labelFn: labelOrDefault,
                restartFn: () => {
                    if (interval) clearInterval(interval);
                    remainingMs = originalMs || ((parseInt(minInput.value, 10) || 0) * 60 + (parseInt(secInput.value, 10) || 0)) * 1000;
                    if (remainingMs <= 0) return;
                    display.textContent = formatMs(remainingMs);
                    wrapper.classList.remove("flash");
                    const label = labelOrDefault();
                    logLineWithRoster(`Extra cycle timer '${label}' restarted.`);
                    interval = setInterval(() => {
                        remainingMs -= 500;
                        if (remainingMs <= 0) {
                            remainingMs = 0;
                            display.textContent = "00:00";
                            clearInterval(interval);
                            interval = null;
                            running = false;
                            startPauseBtn.textContent = "Start";
                            wrapper.classList.add("flash");
                            const lbl = labelOrDefault();
                            logLineWithRoster(`Extra cycle timer '${lbl}' finished.`);
                            if (alarmOn) makeBeep();
                        } else {
                            display.textContent = formatMs(remainingMs);
                        }
                    }, 500);
                    running = true;
                    startPauseBtn.textContent = "Pause";
                },
                checkboxEl: null,
                buttonEl: null
            };
            rebuildTimerRestartUI();
        }

        function createStopwatchTimer() {
            const id = "stopwatch_" + (extraTimerIdCounter++);
            const wrapper = document.createElement("div");
            wrapper.className = "subtimer";
            wrapper.dataset.timerId = id;
            wrapper.dataset.type = "stopwatch";

            const labelInput = document.createElement("input");
            labelInput.type = "text";
            labelInput.placeholder = "Label (optional)";
            labelInput.style.width = "140px";

            const noteInput = document.createElement("input");
            noteInput.type = "text";
            noteInput.placeholder = "Notes";
            noteInput.style.width = "140px";

            const noteBtn = document.createElement("button");
            noteBtn.textContent = "Update Notes";

            const startBtn = document.createElement("button");
            startBtn.textContent = "Start";
            const stopBtn = document.createElement("button");
            stopBtn.textContent = "Stop";
            stopBtn.disabled = true;

            const deleteBtn = document.createElement("button");
            deleteBtn.textContent = "Delete";

            const display = document.createElement("span");
            display.style.marginLeft = "10px";
            display.textContent = "00:00";

            wrapper.appendChild(document.createTextNode("Stopwatch ‚Äî "));
            wrapper.appendChild(labelInput);
            wrapper.appendChild(startBtn);
            wrapper.appendChild(stopBtn);
            wrapper.appendChild(deleteBtn);
            wrapper.appendChild(display);
            wrapper.appendChild(document.createElement("br"));
            wrapper.appendChild(document.createTextNode("Notes: "));
            wrapper.appendChild(noteInput);
            wrapper.appendChild(noteBtn);

            let interval = null;
            let elapsedMs = 0;
            let startMs = null;

            function labelOrDefault() {
                return labelInput.value.trim() || `Stopwatch#${id.split("_")[1]}`;
            }

            startBtn.addEventListener("click", () => {
                if (interval) return;
                startMs = Date.now();
                startBtn.disabled = true;
                stopBtn.disabled = false;
                const label = labelOrDefault();
                logLineWithRoster(`Stopwatch '${label}' started.`);
                interval = setInterval(() => {
                    elapsedMs = Date.now() - startMs;
                    display.textContent = formatMs(elapsedMs);
                }, 500);
            });

            stopBtn.addEventListener("click", () => {
                if (!interval) return;
                clearInterval(interval);
                interval = null;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                const label = labelOrDefault();
                logLineWithRoster(`Stopwatch '${label}' stopped at ${formatMs(elapsedMs)}.`);
            });

            deleteBtn.addEventListener("click", () => {
                const label = labelOrDefault();
                if (confirm(`Delete stopwatch '${label}'?`)) {
                    if (interval) clearInterval(interval);
                    delete timerRegistry[id];
                    wrapper.remove();
                    logLineWithRoster(`Stopwatch '${label}' deleted.`);
                    rebuildTimerRestartUI();
                }
            });

            noteBtn.addEventListener("click", () => {
                const label = labelOrDefault();
                const txt = noteInput.value.trim();
                if (!txt) {
                    logLineWithRoster(`Stopwatch '${label}' notes cleared.`);
                } else {
                    logLineWithRoster(`Stopwatch '${label}' notes updated: "${txt}"`);
                }
            });

            extraTimersContainer.appendChild(wrapper);

            timerRegistry[id] = {
                type: "stopwatch",
                labelFn: labelOrDefault,
                restartFn: () => {
                    // stopwatches don't auto-restart on mob XP; no-op
                },
                checkboxEl: null,
                buttonEl: null
            };
            rebuildTimerRestartUI();
        }

        addCycleTimerBtn.addEventListener("click", createCycleTimer);
        addStopwatchBtn.addEventListener("click", createStopwatchTimer);

        // ---------- INIT ----------
        updateXpBar(0);
        updateGroupButtons();
        rebuildGroupMemberRows();
        registerMainMobTimer();

<!-- === SPELL TIMER SYSTEM: CLASS SELECTOR (BLOCK #1) === -->

// ===============================
// 1. CLASS AVAILABILITY FLAGS
// ===============================
// All classes start as unavailable (faded + disabled)
// When we add a class's spell list later, we will set SpellClassAvailable[CLASS] = true
SpellClassAvailable = {
    CLR: false,
    DRU: false,
    SHM: false,
    ENC: false,
    NEC: false,
    MAG: false,
    WIZ: false,
    BRD: false,
    RNG: false,
    ROG: false,
    PAL: false,
    SHD: false,
    WAR: false,
    MNK: false
};

// ===============================
// 2. CLASS SELECTION FLAGS
// ===============================
const SpellClassFlags = {
    CLR: false,
    DRU: false,
    SHM: false,
    ENC: false,
    NEC: false,
    MAG: false,
    WIZ: false,
    BRD: false,
    RNG: false,
    ROG: false,
    PAL: false,
    SHD: false,
    WAR: false,
    MNK: false
};
__DBG("past CLASS SELECTION FLAGS()544431111333");
// ===============================
// 3. CREATE SPELL TIMER SECTION UI
// ===============================
(function createSpellTimerClassSelector() {
    const container = document.createElement("div");
    container.id = "spellTimerClassSelector";
    container.style.marginTop = "25px";
    container.style.padding = "10px";
    container.style.border = "1px solid #666";
    container.style.background = "#222";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h3");
    title.textContent = "Spell Timer System ‚Äî Select Class";
    title.style.marginTop = "0";
    container.appendChild(title);

const classGrid = [
    // Row 1
    ["ENC", "Enchanter"], ["BRD", "Bard"], ["PAL", "Paladin"], ["CLR", "Cleric"],
    // Row 2
    ["MAG", "Magician"], ["MNK", "Monk"], ["SHD", "Shadow Knight"], ["DRU", "Druid"],
    // Row 3
    ["NEC", "Necromancer"], ["RNG", "Ranger"], ["WAR", "Warrior"], ["SHM", "Shaman"],
    // Row 4
    ["WIZ", "Wizard"], ["ROG", "Rogue"]
];


// Build a 4-column grid
const grid = document.createElement("div");
grid.style.display = "grid";
grid.style.gridTemplateColumns = "repeat(4, 1fr)";
grid.style.gap = "6px 12px";

classGrid.forEach(([code, label]) => {
    const cell = document.createElement("div");
    cell.style.display = "flex";
    cell.style.alignItems = "center";

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.disabled = true;
    checkbox.style.marginRight = "6px";
    checkbox.dataset.classCode = code;

    const text = document.createElement("span");
    text.textContent = label;
    text.style.opacity = "0.4";

    checkbox.addEventListener("change", () => {
        SpellClassFlags[code] = checkbox.checked;

        document.dispatchEvent(new CustomEvent("SpellClassSelectionChanged", {
            detail: { flags: SpellClassFlags }
        }));
    });

    cell.appendChild(checkbox);
    cell.appendChild(text);
    grid.appendChild(cell);
});

container.appendChild(grid);


    document.body.appendChild(container);
})();

// ===============================
// 4. FUNCTION TO ENABLE A CLASS LATER
// ===============================
// When we add a class's spell list, we call:
// enableSpellClass("NEC");
function enableSpellClass(classCode) {
    SpellClassAvailable[classCode] = true;

    const selector = document.querySelectorAll("#spellTimerClassSelector input[type='checkbox']");
    selector.forEach(cb => {
        if (cb.dataset.classCode === classCode) {
            cb.disabled = false;
            cb.nextSibling.style.opacity = "1.0"; // unfade label
        }
    });
}


function swooshLoadFromText(text) {
    __DBG("ENTER: swooshLoadFromText()");
    const lines = text.split("\n");

    let endIndex = -1;
    let startIndex = -1;

    // ===============================
    // Find newest END
    // ===============================
    for (let i = lines.length - 1; i >= 0; i--) {
        if (lines[i].includes(SWOOSH_END)) {
            endIndex = i;
            __DBG("FOUND: SWOOSH_END at line " + i);
            break;
        }
    }
    if (endIndex === -1) {
        __DBG("ERROR: No SWOOSH_END found.");
        logLine("No swoosh block found.");
        return;
    }

    // ===============================
    // Find matching START
    // ===============================
    for (let j = endIndex - 1; j >= 0; j--) {
        if (lines[j].includes(SWOOSH_START)) {
            startIndex = j;
            __DBG("FOUND: SWOOSH_START at line " + j);
            break;
        }
    }
    if (startIndex === -1) {
        __DBG("ERROR: SWOOSH_END found but no SWOOSH_START.");
        logLine("Swoosh END found but no START marker.");
        return;
    }

    // ===============================
    // Extract JSON block
    // ===============================
    const swooshText = lines.slice(startIndex + 1, endIndex).join("\n");
    __DBG("EXTRACTED swooshText length=" + swooshText.length);

    let swoosh;
    try {
        swoosh = JSON.parse(swooshText);
        __DBG("PARSE OK: swoosh JSON loaded.");
    } catch (e) {
        __DBG("PARSE ERROR: " + e.message);
        logLine("Failed to parse swoosh block.");
        return;
    }

    // ===============================
    // Apply loaded data
    // ===============================
    SpellRegistry = swoosh.registry || {};
    UserOverrides = swoosh.overrides || {};
    UserCustomSpells = swoosh.custom || {};
    SpellClassAvailable = swoosh.classes || {};

    // ===============================
    // Restore Long Term Timers
    // ===============================
    if (swoosh.longTermTimers) {
        LongTermTimersAPI.loadAll(swoosh.longTermTimers);
        logLine("LTT Restored from Swoosh.");
    }

    // ===============================
    // ‚≠ê RESTORE CB2 ITEMS
    // ===============================
if (Array.isArray(swoosh.items)) {
    ItemRegistry = swoosh.items;
    CB2.items = swoosh.items;
    cb2_log("[SYNC] Restored CB2.items from swoosh.");

    // ‚≠ê RESTORE CH TIMERS
    if (typeof restoreAllItemsFromRegistry === "function") {
        restoreAllItemsFromRegistry();
        cb2_log("[SYNC] Restored all CH timers from swoosh.");
    }

} else {
    ItemRegistry = [];
    CB2.items = [];
}

    // ===============================
    // ‚≠ê RESTORE CB2 CHARACTERS
    // ===============================
    if (Array.isArray(swoosh.characters)) {
        CB2.characters = swoosh.characters;
        cb2_log("[SYNC] Restored CB2.characters from swoosh.");
    } else {
        CB2.characters = [];
    }

    // ===============================
    // ‚≠ê RESTORE CB2 TOKENS
    // ===============================
    if (Array.isArray(swoosh.tokens)) {
        CB2.tokens = swoosh.tokens;
        cb2_log("[SYNC] Restored CB2.tokens from swoosh.");
    } else {
        CB2.tokens = [];
    }

    // ===============================
    // ‚≠ê RE-INIT CB2 UI
    // ===============================
    if (typeof cb2_init === "function") {
        CB2.initialized = false;
        cb2_init();
    }

    // ===============================
    // Rebuild Spell UI
    // ===============================
    rebuildSpellUI();

    if (typeof updateSwooshListUI === "function") {
        updateSwooshListUI(swoosh.timestamp);
    }

    logLine("Swoosh Load Complete.");
    __DBG("EXIT: swooshLoadFromText() ‚Äî COMPLETE");
}

function restoreItemTimer(panel, item) {
    const timerDisplay = panel.querySelector(`#itemTimer_${item.id}`);
    if (!timerDisplay) {
        __DBG("RESTORE: No timerDisplay found for item id=" + item.id);
        return;
    }

    if (!item.timer) {
        __DBG("RESTORE: No timer object for item id=" + item.id);
        return;
    }

    // Completed
    if (item.timer.completed) {
        timerDisplay.textContent = "DONE";
        timerDisplay.classList.add("flash");
        __DBG("RESTORE: Item id=" + item.id + " marked DONE");
        return;
    }

    // Running
    if (item.timer.running) {
        const now = Date.now();
        const elapsed = now - item.timer.savedAt;
        const remaining = Math.max(0, item.timer.remaining - elapsed);
        timerDisplay.textContent = remaining + "s";
        __DBG("RESTORE: Item id=" + item.id + " restored running timer, remaining=" + remaining);
    }
}


function rebuildSpellUI() {
    // ===============================
    // 1. Remove all existing spell list UI blocks
    // ===============================
    const oldLists = document.querySelectorAll("[id$='SpellList']");
    oldLists.forEach(el => el.remove());

    // ===============================
    // 2. Re-enable classes based on swoosh database
    // ===============================
    for (const classCode in SpellClassAvailable) {
        if (SpellClassAvailable[classCode]) {
            enableSpellClass(classCode);
        }
    }

    // ===============================
    // 3. Rebuild spell lists from SpellRegistry
    // ===============================
    for (const classCode in SpellRegistry) {
        const spells = SpellRegistry[classCode];
        if (!spells) continue;

        // Create container
        const container = document.createElement("div");
        container.id = `${classCode.toLowerCase()}SpellList`;
        container.style.marginTop = "15px";
        container.style.padding = "10px";
        container.style.border = "1px solid #444";
        container.style.background = "#111";
        container.style.color = "white";
        container.style.borderRadius = "6px";

        // Title
        const title = document.createElement("h4");
        title.textContent = `${classCode} ‚Äî Spells`;
        title.style.marginTop = "0";
        container.appendChild(title);

        // Grid
        const grid = document.createElement("div");
        grid.style.display = "grid";
        grid.style.gridTemplateColumns = "repeat(3, 1fr)";
        grid.style.gap = "6px 20px";
        grid.style.marginTop = "10px";
        container.appendChild(grid);

        // Add spells
        spells.forEach(spell => {
            const cell = document.createElement("div");
            cell.style.display = "flex";
            cell.style.alignItems = "center";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.dataset.spellId = spell.id;
            checkbox.style.marginRight = "6px";

            const label = document.createElement("span");
            label.textContent = spell.name;

            cell.appendChild(checkbox);
            cell.appendChild(label);
            grid.appendChild(cell);

            checkbox.addEventListener("change", () => {
                if (checkbox.checked) {
                    createSpellTimerUI(spell, container.id);
                } else {
                    removeSpellTimerUI(spell.id);
                }
            });
        });

        document.body.appendChild(container);
    }

    logLine("Spell UI rebuilt from Swoosh database.");
}



<!-- === SPELL TIMER SYSTEM: NECROMANCER TEST SPELLS (BLOCK #2 ‚Äî UPGRADED) === -->

// ===============================
// NECROMANCER TEST SPELL DATA
// ===============================
// ===============================
// NECROMANCER SPELL DATA ‚Äî BLOCK 1
// Levels 1‚Äì4, 8‚Äì12, 16‚Äì20
// ===============================

window.SpellData_NEC = [

    // ===============================
    // LEVEL 1 SPELLS
    // ===============================

    {
        id: "NEC_DISEASE_CLOUD",
        name: "Disease Cloud",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 180,   // 30 ticks
        maxDurationSeconds: 360,   // 60 ticks
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 1,
        spellLevelMax: 1,
        notes: "Classic low-level disease DoT. Generates strong aggro.",
        description: "Deals 5 direct damage + 1 damage per tick for 30‚Äì60 ticks.",
    },

    {
        id: "NEC_INVIS_UNDEAD",
        name: "Invisibility vs Undead",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 180,    // 3 min @ L1
        maxDurationSeconds: 1620,   // 27 min @ L9+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 1,
        spellLevelMax: 9,
        notes: "Single-target invisibility vs undead. Must be grouped with target.",
        description: "Cloaks target in invisibility vs undead. Duration scales with level.",
    },

    {
        id: "NEC_MINOR_SHIELDING",
        name: "Minor Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1620,   // 27 minutes
        maxDurationSeconds: 1620,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 1,
        spellLevelMax: 1,
        notes: "Basic HP/AC buff.",
        description: "Increases max HP by 6‚Äì10 and AC by 3‚Äì4.",
    },

    {
        id: "NEC_SIPHON_STRENGTH",
        name: "Siphon Strength",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 180,   // 3 min @ L1
        maxDurationSeconds: 360,   // 6 min @ L2+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 1,
        spellLevelMax: 2,
        notes: "Drains STR from target and grants it to caster.",
        description: "Decreases target STR by 5‚Äì10 and increases caster STR by same amount.",
    },

    // ===============================
    // LEVEL 4 SPELLS
    // ===============================

    {
        id: "NEC_CLINGING_DARKNESS",
        name: "Clinging Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 12,   // 2 ticks
        maxDurationSeconds: 48,   // 8 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 4,
        spellLevelMax: 12,
        notes: "Low-level snare + DoT. Does not break early.",
        description: "Deals 5 damage per tick for 2‚Äì8 ticks and snares target 24‚Äì30%.",
    },

    {
        id: "NEC_ENDURE_COLD",
        name: "Endure Cold",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 180,
        maxDurationSeconds: 1620,
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 1,
        spellLevelMax: 9,
        notes: "Cold resist buff.",
        description: "Increases cold resistance by 11‚Äì20. Duration scales with level.",
    },

    {
        id: "NEC_FEAR",
        name: "Fear",
        class: "NEC",
        category: "Fear",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 4,
        spellLevelMax: 4,
        notes: "Classic fear. Breaks early on resist checks.",
        description: "Causes target to flee in terror for up to 18 seconds.",
    },

    {
        id: "NEC_GRIM_AURA",
        name: "Grim Aura",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 720,   // 12 min @ L4
        maxDurationSeconds: 1620,  // 27 min @ L9+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 4,
        spellLevelMax: 9,
        notes: "Does not stack with Firefist, Strength of Nature, Celestial Tranquility.",
        description: "Increases ATK by 7‚Äì10. Duration scales with level.",
    },

    {
        id: "NEC_NUMB_THE_DEAD",
        name: "Numb the Dead",
        class: "NEC",
        category: "Lull (Undead)",
        minDurationSeconds: 84,   // 1.4 min @ L4
        maxDurationSeconds: 120,  // 2 min @ L10
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 4,
        spellLevelMax: 10,
        notes: "Undead-only lull. Charisma affects success.",
        description: "Reduces undead aggro radius. Breaks on resist.",
    },

    {
        id: "NEC_POISON_BOLT",
        name: "Poison Bolt",
        class: "NEC",
        category: "DoT (Poison)",
        minDurationSeconds: 12,   // 2 ticks
        maxDurationSeconds: 42,   // 7 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 4,
        spellLevelMax: 12,
        notes: "Low-level poison DoT.",
        description: "Deals 6 direct damage + 5/tick for 2‚Äì7 ticks.",
    },

    // ===============================
    // LEVEL 8 SPELLS
    // ===============================

    {
        id: "NEC_DEADEYE",
        name: "Deadeye",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1440,  // 24 min @ L8
        maxDurationSeconds: 1620,  // 27 min @ L9
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 8,
        spellLevelMax: 9,
        notes: "Self-only See Invisible + Infravision.",
        description: "Grants infravision and see invisibility. Duration scales with level.",
    },

    {
        id: "NEC_GATHER_SHADOWS",
        name: "Gather Shadows",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1200,  // 20 minutes
        maxDurationSeconds: 1200,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 8,
        spellLevelMax: 8,
        notes: "Self invisibility.",
        description: "Casts invisibility on the caster for 20 minutes.",
    },

    {
        id: "NEC_IMPART_STRENGTH",
        name: "Impart Strength",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 360,
        maxDurationSeconds: 360,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 8,
        spellLevelMax: 8,
        notes: "Transfers 10 STR to target.",
        description: "Caster loses 10 STR; target gains 10 STR for 6 minutes.",
    },

    {
        id: "NEC_LESSER_SHIELDING",
        name: "Lesser Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1440,  // 24 min @ L8
        maxDurationSeconds: 1620,  // 27 min @ L9
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 8,
        spellLevelMax: 9,
        notes: "HP/AC buff.",
        description: "Increases HP by 20‚Äì30 and AC by 6‚Äì9.",
    },

    {
        id: "NEC_VAMPIRIC_EMBRACE",
        name: "Vampiric Embrace",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 108,   // 1.8 min @ L8
        maxDurationSeconds: 420,   // 7 min @ L60
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 8,
        spellLevelMax: 60,
        notes: "Adds lifetap proc to melee attacks.",
        description: "Grants a melee lifetap proc. Duration scales with level.",
    },

    // ===============================
    // LEVEL 12 SPELLS
    // ===============================

    {
        id: "NEC_ENDURE_DISEASE",
        name: "Endure Disease",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 1620,
        maxDurationSeconds: 1620,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 12,
        spellLevelMax: 12,
        notes: "Disease resist buff.",
        description: "Increases disease resistance by 19‚Äì20 for 27 minutes.",
    },

    {
        id: "NEC_ENGULFING_DARKNESS",
        name: "Engulfing Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 60,   // 10 ticks
        maxDurationSeconds: 60,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 12,
        spellLevelMax: 12,
        notes: "Stronger snare + DoT upgrade.",
        description: "Deals 11/tick for 10 ticks and snares target by 40%.",
    },

    {
        id: "NEC_HEAT_BLOOD",
        name: "Heat Blood",
        class: "NEC",
        category: "DoT (Fire)",
        minDurationSeconds: 36,   // 6 ticks
        maxDurationSeconds: 60,   // 10 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 20,
        notes: "Classic fire DoT.",
        description: "Deals 17 damage per tick for 6‚Äì10 ticks.",
    },

    {
        id: "NEC_LEACH",
        name: "Leach",
        class: "NEC",
        category: "DoT (Drain)",
        minDurationSeconds: 36,   // 6 ticks
        maxDurationSeconds: 54,   // 9 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 20,
        notes: "Life drain DoT.",
        description: "Deals 8/tick and heals caster for 8/tick for 6‚Äì9 ticks.",
    },

    {
        id: "NEC_SCENT_OF_DUSK",
        name: "Scent of Dusk",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 204,   // 3.4 min @ L12
        maxDurationSeconds: 840,   // 14 min @ L65
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 65,
        notes: "Reduces fire, poison, and disease resist.",
        description: "Decreases fire/poison/disease resist by 7‚Äì9.",
    },

    {
        id: "NEC_SPOOK_THE_DEAD",
        name: "Spook the Dead",
        class: "NEC",
        category: "Fear (Undead)",
        minDurationSeconds: 6,   // 1 tick
        maxDurationSeconds: 18,  // 3 ticks
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 20,
        notes: "Undead-only fear.",
        description: "Fears undead for 1‚Äì3 ticks. Breaks early.",
    },

    {
        id: "NEC_WAVE_OF_ENFEEBLEMENT",
        name: "Wave of Enfeeblement",
        class: "NEC",
        category: "Debuff (AoE)",
        minDurationSeconds: 72,   // 12 ticks
        maxDurationSeconds: 120,  // 20 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 12,
        spellLevelMax: 20,
        notes: "AoE STR debuff.",
        description: "Decreases STR by 11‚Äì15 for 12‚Äì20 ticks.",
    },

    // ===============================
    // LEVEL 16‚Äì20 SPELLS
    // ===============================

    {
        id: "NEC_BANSHEE_AURA",
        name: "Banshee Aura",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 252,   // 4.2 min @ L16
        maxDurationSeconds: 540,   // 9 min @ L40+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 16,
        spellLevelMax: 40,
        notes: "Damage shield. Requires pearl (not consumed).",
        description: "Damage shield that scales with level. Duration increases with level.",
    },

    {
        id: "NEC_HEART_FLUTTER",
        name: "Heart Flutter",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 72,   // 12 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 16,
        spellLevelMax: 24,
        notes: "DoT + STR/AC debuff.",
        description: "Deals 12/tick for 8‚Äì12 ticks and reduces STR/AC.",
    },

    {
        id: "NEC_HUNGRY_EARTH",
        name: "Hungry Earth",
        class: "NEC",
        category: "Root (Undead)",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 48,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "Undead-only root. Breaks on damage.",
        description: "Roots undead for 8 ticks and deals 26‚Äì75 damage.",
    },

    {
        id: "NEC_INFECTIOUS_CLOUD",
        name: "Infectious Cloud",
        class: "NEC",
        category: "DoT (AoE)",
        minDurationSeconds: 126,   // 21 ticks
        maxDurationSeconds: 126,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "AoE poison DoT.",
        description: "Deals 20 direct damage + 5/tick for 21 ticks.",
    },

    {
        id: "NEC_SHIELDING",
        name: "Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,   // 36 minutes
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "HP/AC/MR buff.",
        description: "Increases HP by 46‚Äì50, AC by 12‚Äì13, and MR by 13.",
    },

    {
        id: "NEC_SHIELDSKIN",
        name: "Shieldskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "Absorbs 27‚Äì55 damage. Consumes Cat's Eye Agate.",
        description: "Absorbs a small amount of damage. Lasts 36 minutes.",
    },

    {
        id: "NEC_SPIRIT_ARMOR",
        name: "Spirit Armor",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 16,
        spellLevelMax: 16,
        notes: "AC buff.",
        description: "Increases AC by 11‚Äì13 for 36 minutes.",
    },

    {
        id: "NEC_ALLURE_OF_DEATH",
        name: "Allure of Death",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L20
        maxDurationSeconds: 780,   // 13 min @ L60
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 20,
        spellLevelMax: 60,
        notes: "Lich line. Does not stack with clarity. Stacks with bard mana songs.",
        description: "Drains 5 HP/tick and restores 4 mana/tick. Duration scales with level.",
    },

    {
        id: "NEC_DOMINATE_UNDEAD",
        name: "Dominate Undead",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 420,    // 7 min @ L20
        maxDurationSeconds: 1230,   // 20.5 min @ L65
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 20,
        spellLevelMax: 65,
        notes: "Charm undead up to level 32. Breaks randomly.",
        description: "Charms an undead creature for 7‚Äì20.5 minutes. Breaks early on resist checks.",
    },

    {
        id: "NEC_HARMSHIELD",
        name: "Harmshield",
        class: "NEC",
        category: "Buff (Invulnerability)",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 20,
        spellLevelMax: 20,
        notes: "Caster becomes immune to all damage but cannot attack or cast.",
        description: "Grants complete damage immunity for 18 seconds. Cannot attack or cast while active.",
    },

    {
        id: "NEC_SHADOW_COMPACT",
        name: "Shadow Compact",
        class: "NEC",
        category: "Heal (HP Transfer)",
        minDurationSeconds: 24,   // 4 ticks
        maxDurationSeconds: 24,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 20,
        spellLevelMax: 20,
        notes: "Transfers HP from caster to target over time.",
        description: "Caster loses 20 HP/tick while target is healed for 20 HP/tick for 4 ticks.",
    },

    {
        id: "NEC_SHADOW_VORTEX",
        name: "Shadow Vortex",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 0,     // Instant effect, no duration
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 20,
        spellLevelMax: 20,
        notes: "AC debuff that transfers AC to caster.",
        description: "Reduces target AC by 9‚Äì12 and grants the same amount to the caster.",
    },
// ===============================
// NECROMANCER SPELL DATA ‚Äî BLOCK 2
// Levels 24‚Äì29, 34‚Äì39
// ===============================

    // ===============================
    // LEVEL 24 SPELLS
    // ===============================

    {
        id: "NEC_INTENSIFY_DEATH",
        name: "Intensify Death",
        class: "NEC",
        category: "Buff (Pet)",
        minDurationSeconds: 0,
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Pet buff: increases attack speed, STR, and AC.",
        description: "Increases pet attack speed by 22‚Äì30%, STR by 26‚Äì33, and AC by 6‚Äì8.",
    },

    {
        id: "NEC_LEATHERSKIN",
        name: "Leatherskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,   // 36 minutes
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Absorbs 71‚Äì118 damage. Consumes a bloodstone.",
        description: "Absorbs a moderate amount of damage. Lasts 36 minutes.",
    },

    {
        id: "NEC_MAJOR_SHIELDING",
        name: "Major Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "HP/AC/MR buff.",
        description: "Increases HP by 69‚Äì75, AC by 16‚Äì18, and MR by 14.",
    },

    {
        id: "NEC_RESIST_COLD",
        name: "Resist Cold",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Cold resist buff.",
        description: "Increases cold resistance by 39‚Äì40 for 36 minutes.",
    },

    {
        id: "NEC_REST_THE_DEAD",
        name: "Rest the Dead",
        class: "NEC",
        category: "Lull (Undead)",
        minDurationSeconds: 0,   // Duration not meaningful; lull breaks on resist
        maxDurationSeconds: 0,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Undead-only lull. Charisma affects success.",
        description: "Reduces undead aggro radius. Breaks on resist.",
    },

    {
        id: "NEC_SCENT_OF_SHADOW",
        name: "Scent of Shadow",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 348,   // 5.8 min @ L24
        maxDurationSeconds: 840,   // 14 min @ L65
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 24,
        spellLevelMax: 65,
        notes: "Reduces fire, poison, and disease resist.",
        description: "Decreases fire/poison/disease resist by 14‚Äì18.",
    },

    {
        id: "NEC_SCREAMING_TERROR",
        name: "Screaming Terror",
        class: "NEC",
        category: "Mez",
        minDurationSeconds: 18,   // 3 ticks
        maxDurationSeconds: 18,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Short mez with a chance to memblur.",
        description: "Mesmerizes target for 3 ticks with a small chance to memblur.",
    },

    {
        id: "NEC_SHADOW_SIGHT",
        name: "Shadow Sight",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 24,
        spellLevelMax: 24,
        notes: "Ultravision buff.",
        description: "Grants ultravision for 36 minutes.",
    },

    // ===============================
    // LEVEL 29 SPELLS
    // ===============================

    {
        id: "NEC_BOIL_BLOOD",
        name: "Boil Blood",
        class: "NEC",
        category: "DoT (Fire)",
        minDurationSeconds: 96,   // 16 ticks
        maxDurationSeconds: 126,  // 21 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 29,
        spellLevelMax: 39,
        notes: "Efficient fire DoT.",
        description: "Deals 24 damage per tick for 16‚Äì21 ticks.",
    },

    {
        id: "NEC_DOOMING_DARKNESS",
        name: "Dooming Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 90,   // 15 ticks
        maxDurationSeconds: 96,   // 16 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 29,
        spellLevelMax: 39,
        notes: "Stronger snare + DoT upgrade.",
        description: "Deals 20/tick for 15‚Äì16 ticks and snares target by 49‚Äì60%.",
    },

    {
        id: "NEC_PANIC_THE_DEAD",
        name: "Panic the Dead",
        class: "NEC",
        category: "Fear (Undead)",
        minDurationSeconds: 54,   // 9 ticks
        maxDurationSeconds: 54,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 29,
        spellLevelMax: 29,
        notes: "Undead-only fear.",
        description: "Fears undead for 9 ticks. Breaks early.",
    },

    {
        id: "NEC_VAMPIRIC_CURSE",
        name: "Vampiric Curse",
        class: "NEC",
        category: "DoT (Drain)",
        minDurationSeconds: 54,   // 9 ticks
        maxDurationSeconds: 54,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 29,
        spellLevelMax: 29,
        notes: "Life drain DoT.",
        description: "Deals 21/tick and heals caster for 21/tick for 9 ticks.",
    },

    // ===============================
    // LEVEL 34 SPELLS
    // ===============================

    {
        id: "NEC_BEGUILE_UNDEAD",
        name: "Beguile Undead",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 660,   // 11 min
        maxDurationSeconds: 1200,  // 20 min
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 34,
        spellLevelMax: 60,
        notes: "Charm undead up to level 51. Breaks randomly.",
        description: "Charms undead for 11‚Äì20 minutes. Breaks early on resist.",
    },

    {
        id: "NEC_CALL_OF_BONES",
        name: "Call of Bones",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L34
        maxDurationSeconds: 780,   // 13 min @ L60
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 34,
        spellLevelMax: 60,
        notes: "Lich line. Skeleton illusion.",
        description: "Drains 10 HP/tick and restores 8 mana/tick. Duration scales with level.",
    },

    {
        id: "NEC_GREATER_SHIELDING",
        name: "Greater Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "HP/AC/MR buff.",
        description: "Increases HP by 94‚Äì100, AC by 21‚Äì30, and MR by 16.",
    },

    {
        id: "NEC_INVOKE_FEAR",
        name: "Invoke Fear",
        class: "NEC",
        category: "Fear",
        minDurationSeconds: 42,   // 7 ticks
        maxDurationSeconds: 42,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Standard fear spell.",
        description: "Fears target for 7 ticks. Breaks early.",
    },

    {
        id: "NEC_RESIST_DISEASE",
        name: "Resist Disease",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Disease resist buff.",
        description: "Increases disease resistance by 40 for 36 minutes.",
    },

    {
        id: "NEC_ROOT",
        name: "Root",
        class: "NEC",
        category: "Root",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 48,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Breaks on direct damage.",
        description: "Roots target for 8 ticks. Breaks early on damage.",
    },

    {
        id: "NEC_STEELSKIN",
        name: "Steelskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Absorbs 168‚Äì230 damage. Consumes a jasper.",
        description: "Absorbs a large amount of damage. Lasts 36 minutes.",
    },

    {
        id: "NEC_SURGE_OF_ENFEEBLEMENT",
        name: "Surge of Enfeeblement",
        class: "NEC",
        category: "Debuff (PBAoE)",
        minDurationSeconds: 600,   // 100 ticks
        maxDurationSeconds: 600,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 34,
        spellLevelMax: 34,
        notes: "Large-radius STR debuff.",
        description: "Decreases STR by 22‚Äì30 for 100 ticks.",
    },

    {
        id: "NEC_VENOM_OF_THE_SNAKE",
        name: "Venom of the Snake",
        class: "NEC",
        category: "DoT (Poison)",
        minDurationSeconds: 42,   // 7 ticks
        maxDurationSeconds: 48,   // 8 ticks
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 34,
        spellLevelMax: 39,
        notes: "Strong poison DoT.",
        description: "Deals 40 direct + 59/tick for 7‚Äì8 ticks.",
    },

    // ===============================
    // LEVEL 39 SPELLS
    // ===============================

    {
        id: "NEC_AUGMENT_DEATH",
        name: "Augment Death",
        class: "NEC",
        category: "Buff (Pet)",
        minDurationSeconds: 0,
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 39,
        spellLevelMax: 39,
        notes: "Major pet buff.",
        description: "Increases pet attack speed by 49‚Äì55%, STR by 39‚Äì45, and AC by 10‚Äì12.",
    },

    {
        id: "NEC_CHILLING_EMBRACE",
        name: "Chilling Embrace",
        class: "NEC",
        category: "DoT (Poison)",
        minDurationSeconds: 96,   // 16 ticks
        maxDurationSeconds: 96,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 39,
        spellLevelMax: 39,
        notes: "Velious-era poison DoT.",
        description: "Deals 40 damage per tick for 16 ticks.",
    },

    {
        id: "NEC_SCENT_OF_DARKNESS",
        name: "Scent of Darkness",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 0,   // Duration not meaningful
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 39,
        spellLevelMax: 39,
        notes: "Reduces fire, poison, and disease resist.",
        description: "Decreases fire/poison/disease resist by 24‚Äì27.",
    },

    {
        id: "NEC_SCOURGE",
        name: "Scourge",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 126,   // 21 ticks
        maxDurationSeconds: 126,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 39,
        spellLevelMax: 39,
        notes: "Strong disease DoT.",
        description: "Deals 40 direct + 24/tick for 21 ticks.",
    },
// ===============================
// NECROMANCER SPELL DATA ‚Äî BLOCK 3
// Levels 44‚Äì49, 50‚Äì60
// ===============================

    // ===============================
    // LEVEL 44 SPELLS
    // ===============================

    {
        id: "NEC_ARCH_SHIELDING",
        name: "Arch Shielding",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,   // 36 minutes
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 44,
        spellLevelMax: 44,
        notes: "High-tier HP/AC/MR buff.",
        description: "Increases HP by 144‚Äì150, AC by 25‚Äì36, and MR by 20.",
    },

    {
        id: "NEC_ASYSTOLE",
        name: "Asystole",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 60,   // 10 ticks
        maxDurationSeconds: 60,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 44,
        spellLevelMax: 44,
        notes: "Strong STR/AC debuff + DoT.",
        description: "Deals 69/tick for 10 ticks and reduces STR by 37‚Äì40 and AC by 16‚Äì18.",
    },

    {
        id: "NEC_DEAD_MAN_FLOATING",
        name: "Dead Man Floating",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 44,
        spellLevelMax: 44,
        notes: "Levitation + see invis + water breathing + poison resist.",
        description: "Grants levitation, see invis, water breathing, and +64‚Äì70 poison resist.",
    },

    {
        id: "NEC_DIAMONDSKIN",
        name: "Diamondskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 44,
        spellLevelMax: 44,
        notes: "Absorbs 245‚Äì394 damage. Consumes a peridot.",
        description: "Large damage absorb shield lasting 36 minutes.",
    },

    // ===============================
    // LEVEL 49 SPELLS
    // ===============================

    {
        id: "NEC_BOND_OF_DEATH",
        name: "Bond of Death",
        class: "NEC",
        category: "DoT (Drain)",
        minDurationSeconds: 54,   // 9 ticks
        maxDurationSeconds: 54,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "Strong life-drain DoT.",
        description: "Deals 80/tick and heals caster for 80/tick for 9 ticks.",
    },

    {
        id: "NEC_CAJOLLE_UNDEAD",
        name: "Cajole Undead",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 900,   // 15 min
        maxDurationSeconds: 1140,  // 19 min
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 49,
        spellLevelMax: 60,
        notes: "Charms undead up to level 51. Breaks randomly.",
        description: "Charms undead for 15‚Äì19 minutes. Breaks early on resist.",
    },

    {
        id: "NEC_CASCADING_DARKNESS",
        name: "Cascading Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 96,   // 16 ticks
        maxDurationSeconds: 96,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "High-level snare + DoT.",
        description: "Deals 72/tick for 16 ticks and snares target by 60%.",
    },

    {
        id: "NEC_DEAD_MEN_FLOATING",
        name: "Dead Men Floating",
        class: "NEC",
        category: "Buff (Group)",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "Group version of Dead Man Floating.",
        description: "Applies Dead Man Floating to the entire group.",
    },

    {
        id: "NEC_IGNITE_BLOOD",
        name: "Ignite Blood",
        class: "NEC",
        category: "DoT (Fire)",
        minDurationSeconds: 126,   // 21 ticks
        maxDurationSeconds: 126,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "High-efficiency fire DoT.",
        description: "Deals 56/tick for 21 ticks.",
    },

    {
        id: "NEC_LICH",
        name: "Lich",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L49
        maxDurationSeconds: 780,   // 13 min @ L60
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 49,
        spellLevelMax: 60,
        notes: "Lich line. Bloody skeleton illusion.",
        description: "Drains 22 HP/tick and restores 20 mana/tick. Duration scales with level.",
    },

    {
        id: "NEC_PARALYZING_EARTH",
        name: "Paralyzing Earth",
        class: "NEC",
        category: "Root",
        minDurationSeconds: 180,   // 30 ticks
        maxDurationSeconds: 180,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 49,
        spellLevelMax: 49,
        notes: "Long-duration root. Breaks on direct damage.",
        description: "Roots target for 30 ticks. Breaks early on damage.",
    },

    // ===============================
    // LEVEL 50 SPELLS
    // ===============================

    {
        id: "NEC_IMPROVED_INVIS_UNDEAD",
        name: "Improved Invis vs Undead",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 180,   // 3 min @ L1
        maxDurationSeconds: 1620,  // 27 min @ L9+
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 1,
        spellLevelMax: 9,
        notes: "Improved invisibility vs undead.",
        description: "Grants invisibility vs undead. Duration scales with level.",
    },

    // ===============================
    // LEVEL 51 SPELLS
    // ===============================

    {
        id: "NEC_DREAD_OF_NIGHT",
        name: "Dread of Night",
        class: "NEC",
        category: "Fear (Undead)",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 48,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 51,
        notes: "Undead-only fear.",
        description: "Fears undead for 8 ticks. Breaks early.",
    },

    {
        id: "NEC_ENVENOMED_BOLT",
        name: "Envenomed Bolt",
        class: "NEC",
        category: "DoT (Poison)",
        minDurationSeconds: 48,   // 8 ticks
        maxDurationSeconds: 48,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 51,
        notes: "High-damage poison DoT.",
        description: "Deals 110 direct damage, then 146/tick for 8 ticks.",
    },

    {
        id: "NEC_SPLURT",
        name: "Splurt",
        class: "NEC",
        category: "DoT (Magic)",
        minDurationSeconds: 102,   // 17 ticks
        maxDurationSeconds: 102,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 51,
        notes: "Damage increases every tick.",
        description: "Starts at 11 damage and increases by 12 each tick for 17 ticks.",
    },

    // ===============================
    // LEVEL 52 SPELLS
    // ===============================

    {
        id: "NEC_MANASKIN",
        name: "Manaskin",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 52,
        notes: "Absorbs 521‚Äì600 damage. Adds +1 mana regen.",
        description: "Large damage absorb shield with mana regen.",
    },

    {
        id: "NEC_PLAGUE",
        name: "Plague",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 132,   // 22 ticks
        maxDurationSeconds: 132,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 52,
        notes: "Long-duration disease DoT.",
        description: "Deals 60 direct damage, then 55/tick for 22 ticks.",
    },

    {
        id: "NEC_SCENT_OF_TERRIS",
        name: "Scent of Terris",
        class: "NEC",
        category: "Debuff",
        minDurationSeconds: 0,
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 52,
        notes: "High-tier resist debuff.",
        description: "Decreases fire/poison/disease resist by 33‚Äì36.",
    },

    // ===============================
    // LEVEL 53 SPELLS
    // ===============================

    {
        id: "NEC_ENSTILL",
        name: "Enstill",
        class: "NEC",
        category: "Root",
        minDurationSeconds: 96,   // 16 ticks
        maxDurationSeconds: 96,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 53,
        spellLevelMax: 53,
        notes: "Breaks on direct damage.",
        description: "Roots target for 16 ticks. Breaks early on damage.",
    },

    // ===============================
    // LEVEL 54 SPELLS
    // ===============================

    {
        id: "NEC_SHIELD_OF_THE_MAGI",
        name: "Shield of the Magi",
        class: "NEC",
        category: "Buff",
        minDurationSeconds: 2160,
        maxDurationSeconds: 2160,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 54,
        notes: "High-tier HP/AC/MR buff.",
        description: "Increases HP by 232‚Äì250, AC by 29‚Äì31, and MR by 22‚Äì24.",
    },

    {
        id: "NEC_THRALL_OF_BONES",
        name: "Thrall of Bones",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 1020,   // 17 min
        maxDurationSeconds: 1200,   // 20 min
        breakable: true,
        scalesWithLevel: true,
        spellLevelMin: 54,
        spellLevelMax: 60,
        notes: "Charms undead up to level 53.",
        description: "Charms undead for 17‚Äì20 minutes. Breaks early.",
    },

    // ===============================
    // LEVEL 55 SPELLS
    // ===============================

    {
        id: "NEC_AUGMENTATION_OF_DEATH",
        name: "Augmentation of Death",
        class: "NEC",
        category: "Buff (Pet)",
        minDurationSeconds: 0,
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 55,
        notes: "Major pet buff.",
        description: "Increases pet attack speed by 65%, STR by 52‚Äì55, and AC by 14‚Äì15.",
    },

    {
        id: "NEC_SKIN_OF_THE_SHADOW",
        name: "Skin of the Shadow",
        class: "NEC",
        category: "Utility",
        minDurationSeconds: 0,   // Night-only effect
        maxDurationSeconds: 0,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 55,
        notes: "Night-only invisibility + ultravision.",
        description: "Grants invisibility, ultravision, and increased sight range at night.",
    },

    // ===============================
    // LEVEL 56 SPELLS
    // ===============================

    {
        id: "NEC_CESSATION_OF_COR",
        name: "Cessation of Cor",
        class: "NEC",
        category: "DoT (Disease)",
        minDurationSeconds: 66,   // 11 ticks
        maxDurationSeconds: 66,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 56,
        spellLevelMax: 56,
        notes: "High-damage disease DoT.",
        description: "Deals 100/tick for 11 ticks and reduces STR by 50 and AC by 19‚Äì21.",
    },

    {
        id: "NEC_TREPIDATION",
        name: "Trepidation",
        class: "NEC",
        category: "Fear",
        minDurationSeconds: 36,   // 6 ticks
        maxDurationSeconds: 36,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 56,
        spellLevelMax: 56,
        notes: "Standard fear spell.",
        description: "Fears target for 6 ticks. Breaks early.",
    },

    // ===============================
    // LEVEL 57 SPELLS
    // ===============================

    {
        id: "NEC_VEXING_MORDINIA",
        name: "Vexing Mordinia",
        class: "NEC",
        category: "DoT (Drain)",
        minDurationSeconds: 60,   // 10 ticks
        maxDurationSeconds: 60,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 57,
        spellLevelMax: 57,
        notes: "High-level life-drain DoT.",
        description: "Deals 122/tick for 10 ticks and heals caster for 122/tick (9 ticks).",
    },

    // ===============================
    // LEVEL 58 SPELLS
    // ===============================

    {
        id: "NEC_IMMOBILIZE",
        name: "Immobilize",
        class: "NEC",
        category: "Root",
        minDurationSeconds: 60,   // 10 ticks
        maxDurationSeconds: 60,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 58,
        notes: "Breaks on direct damage.",
        description: "Roots target for 10 ticks. Breaks early on damage.",
    },

    {
        id: "NEC_PYROCRUOR",
        name: "Pyrocruor",
        class: "NEC",
        category: "DoT (Fire)",
        minDurationSeconds: 114,   // 19 ticks
        maxDurationSeconds: 114,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 58,
        notes: "High-damage fire DoT.",
        description: "Deals 111/tick for 19 ticks.",
    },

    {
        id: "NEC_QUIVERING_VEIL_OF_XARN",
        name: "Quivering Veil of Xarn",
        class: "NEC",
        category: "Buff (Invulnerability)",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 58,
        notes: "Heals 150 HP and grants 18 seconds of invulnerability.",
        description: "Heals caster for 150 and grants 18 seconds of damage immunity.",
    },

    // ===============================
    // LEVEL 59 SPELLS
    // ===============================

    {
        id: "NEC_DEVOURING_DARKNESS",
        name: "Devouring Darkness",
        class: "NEC",
        category: "DoT (Snare)",
        minDurationSeconds: 78,   // 13 ticks
        maxDurationSeconds: 78,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 59,
        spellLevelMax: 59,
        notes: "High-level snare + DoT.",
        description: "Deals 107/tick for 13 ticks and snares target by 69‚Äì70%.",
    },

    // ===============================
    // LEVEL 60 SPELLS
    // ===============================

    {
        id: "NEC_ARCH_LICH",
        name: "Arch Lich",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L60 minimum scaling
        maxDurationSeconds: 780,   // 13 min @ L60 (max scaling)
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 60,
        spellLevelMax: 60,
        notes: "Top-tier lich form. Spectre illusion. Does not stack with clarity.",
        description: "Drains 20 HP/tick and restores 20 mana/tick. Grants spectre illusion.",
    },

    {
        id: "NEC_DEMI_LICH",
        name: "Demi Lich",
        class: "NEC",
        category: "Buff (Lich)",
        minDurationSeconds: 300,   // 5 min @ L60 minimum scaling
        maxDurationSeconds: 780,   // 13 min @ L60 (max scaling)
        breakable: false,
        scalesWithLevel: true,
        spellLevelMin: 60,
        spellLevelMax: 60,
        notes: "High-tier lich form. Bloody skeleton illusion. Does not stack with clarity.",
        description: "Drains 48 HP/tick and restores 31 mana/tick. Grants bloody skeleton illusion.",
    },

    {
        id: "NEC_ENSLAVE_DEATH",
        name: "Enslave Death",
        class: "NEC",
        category: "Charm (Undead)",
        minDurationSeconds: 30,   // 5 ticks
        maxDurationSeconds: 30,
        breakable: true,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
        notes: "Very short-duration but extremely powerful undead charm.",
        description: "Charms undead for 5 ticks. Very difficult to resist but breaks early.",
    },

]; // 






// ===============================
// NECROMANCER SPELL LIST UI
// ===============================
// ===============================
// NECROMANCER SPELL LIST UI (GRID LIKE CLASS SELECTOR)
// ===============================
(function loadNecromancerSpellList() {

    const container = document.createElement("div");
    container.id = "necSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Necromancer ‚Äî Spell List";
    title.style.marginTop = "0";
    container.appendChild(title);

    // Create a grid wrapper EXACTLY like class selector
    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)"; // 3 columns
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    // Add each spell as a grid cell
    SpellData_NEC.forEach(spell => {

        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        // When checked ‚Üí create timer
        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "necSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();


// ===============================
// ROGUE DISCIPLINE DATA
// ===============================
window.SpellData_ROG = [
    {
        id: "ROG_RESISTANT",
        name: "Resistant Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300, // patch note: increased to 5 min
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 30,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+3 to +10 all resists depending on level.",
        description: "Grants resistance to all magic types."
    },
    {
        id: "ROG_FEARLESS",
        name: "Fearless Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 40,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "ROG_COUNTERATTACK",
        name: "Counterattack Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 9,
        maxDurationSeconds: 9,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 53,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Ripostes every incoming blow.",
        description: "Perfectly times counterattacks, riposting all incoming hits."
    },
    {
        id: "ROG_DEADEYE",
        name: "Deadeye Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Greatly increases hit rate.",
        description: "Focuses vision to vastly increase hit accuracy."
    },
    {
        id: "ROG_NIMBLE",
        name: "Nimble Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Avoids most attacks.",
        description: "Increases combat reflexes, avoiding most melee attacks."
    },
    {
        id: "ROG_KINESTHETICS",
        name: "Kinesthetics Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 57,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Dual wield + double attack every round.",
        description: "Increases combat sense, enabling dual wield and double attack each round."
    },
    {
        id: "ROG_BLINDING_SPEED",
        name: "Blinding Speed Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 18,
        maxDurationSeconds: 18,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Increases attack speed.",
        description: "Focuses energy into arms, increasing attack speed."
    },
    {
        id: "ROG_DUELIST",
        name: "Duelist Discipline",
        class: "ROG",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 59,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "100% melee damage increase.",
        description: "Doubles all melee damage for the duration."
    }
];

// ===============================
// ROGUE DISCIPLINE LIST UI
// ===============================
(function loadRogueDisciplineList() {

    const container = document.createElement("div");
    container.id = "rogSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Rogue ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_ROG.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "rogSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// WARRIOR DISCIPLINE DATA
// ===============================
window.SpellData_WAR = [
    {
        id: "WAR_RESISTANT",
        name: "Resistant Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 30,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+20 all resists.",
        description: "Grants +20 to all resistances."
    },
    {
        id: "WAR_FEARLESS",
        name: "Fearless Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 40,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "WAR_EVASIVE",
        name: "Evasive Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 60,
	reuseSeconds: 420,
        notes: "50% increased avoidance.",
        description: "Increases chance to avoid attacks by 50%."
    },
    {
        id: "WAR_CHARGE",
        name: "Charge Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 14,
        maxDurationSeconds: 14,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 53,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Increases hit chance.",
        description: "Increases accuracy of all melee attacks."
    },
    {
        id: "WAR_MIGHTY_STRIKE",
        name: "Mighty Strike Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 10,
        maxDurationSeconds: 10,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "All attacks crit.",
        description: "Causes every melee attack to land as a critical hit."
    },
    {
        id: "WAR_DEFENSIVE",
        name: "Defensive Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 600,
        notes: "Reduces DI by 50%.",
        description: "Reduces incoming damage interval by 50%."
    },
    {
        id: "WAR_FURIOUS",
        name: "Furious Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 9,
        maxDurationSeconds: 9,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 56,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Ripostes all attacks.",
        description: "Ripostes every incoming blow."
    },
    {
        id: "WAR_PRECISION",
        name: "Precision Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 57,
        spellLevelMax: 60,
	reuseSeconds: 1620,
        notes: "Increases hit rate.",
        description: "Increases hit rate significantly."
    },
    {
        id: "WAR_FELSTRIKE",
        name: "Felstrike Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 58,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Increases melee damage.",
        description: "Increases melee damage output."
    },
    {
        id: "WAR_FORTITUDE",
        name: "Fortitude Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 8,
        maxDurationSeconds: 8,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 59,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Increases avoidance.",
        description: "Increases chance to evade attacks."
    },
    {
        id: "WAR_AGGRESSIVE",
        name: "Aggressive Discipline",
        class: "WAR",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 1620,
        notes: "+30% damage, take more damage.",
        description: "Increases damage output by 30% but increases damage taken."
    }
];

// ===============================
// WARRIOR DISCIPLINE LIST UI
// ===============================
(function loadWarriorDisciplineList() {

    const container = document.createElement("div");
    container.id = "warSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Warrior ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_WAR.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "warSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// MONK DISCIPLINE DATA
// ===============================
window.SpellData_MNK = [
    {
        id: "MNK_RESISTANT",
        name: "Resistant Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 30,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "+3 to +10 all resists.",
        description: "Grants resistance to all magic types."
    },
    {
        id: "MNK_FEARLESS",
        name: "Fearless Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 40,
        spellLevelMax: 60,
	reuseSeconds: 2400,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "MNK_STONESTANCE",
        name: "Stonestance Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 240,
        notes: "60% melee damage reduction.",
        description: "Greatly decreases melee damage taken."
    },
    {
        id: "MNK_THUNDERKICK",
        name: "Thunderkick Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 180, // next flying kick or 3 min
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 52,
        spellLevelMax: 60,
	reuseSeconds: 240,
        notes: "Empowers next Flying Kick.",
        description: "Focuses energy into feet for a powerful Flying Kick."
    },
    {
        id: "MNK_WHIRLWIND",
        name: "Whirlwind Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 9,
        maxDurationSeconds: 9,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 53,
        spellLevelMax: 60,
	reuseSeconds: 3180,
        notes: "Ripostes all attacks.",
        description: "Ripostes every attack from the front."
    },
    {
        id: "MNK_VOIDDANCE",
        name: "Voiddance Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 8,
        maxDurationSeconds: 8,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3240,
        notes: "Avoids all melee attacks.",
        description: "Allows avoidance of all melee attacks from any angle."
    },
    {
        id: "MNK_INNERFLAME",
        name: "Innerflame Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 12,
        maxDurationSeconds: 12,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 56,
        spellLevelMax: 60,
	reuseSeconds: 1560,
        notes: "100% melee damage increase.",
        description: "Greatly increases melee damage output."
    },
    {
        id: "MNK_HUNDRED_FISTS",
        name: "Hundred Fists Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 15,
        maxDurationSeconds: 15,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 57,
        spellLevelMax: 60,
	reuseSeconds: 1800,
        notes: "Increased attack speed.",
        description: "Increases attack rate and damage."
    },
    {
        id: "MNK_SILENTFIST",
        name: "Silentfist Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 59,
        spellLevelMax: 60,
	reuseSeconds: 480,
        notes: "Empowers next Dragon Punch.",
        description: "Focuses rage into hands for a powerful Dragon Punch."
    },
    {
        id: "MNK_ASHENHAND",
        name: "Ashenhand Discipline",
        class: "MNK",
        category: "Discipline",
        minDurationSeconds: 180,
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Empowers next Eagle Strike.",
        description: "Focuses energy into hands for a powerful Eagle Strike."
    }
];

// ===============================
// MONK DISCIPLINE LIST UI
// ===============================
(function loadMonkDisciplineList() {

    const container = document.createElement("div");
    container.id = "mnkSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Monk ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    // Grid wrapper
    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    // Add each discipline
    SpellData_MNK.forEach(spell => {

        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "mnkSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

<!-- === SPELL TIMER SYSTEM: RANGER TEST SPELLS (BLOCK #3) === -->

// ===============================
// RANGER TEST SPELL DATA
// ===============================
// ===============================
// RANGER DISCIPLINE DATA
// ===============================
window.SpellData_RNG = [
    {
        id: "RNG_RESISTANT",
        name: "Resistant Discipline",
        class: "RNG",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300, // patch note: increased to 5 min
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+10 all resists.",
        description: "Increases all resistances by 10."
    },
    {
        id: "RNG_FEARLESS",
        name: "Fearless Discipline",
        class: "RNG",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "RNG_TRUESHOT",
        name: "Trueshot Discipline",
        class: "RNG",
        category: "Discipline",
        minDurationSeconds: 120,
        maxDurationSeconds: 120,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "+105% bow damage, +accuracy.",
        description: "Imbues bow with energy, increasing damage and accuracy."
    },
    {
        id: "RNG_WEAPON_SHIELD",
        name: "Weapon Shield Discipline",
        class: "RNG",
        category: "Discipline",
        minDurationSeconds: 20,
        maxDurationSeconds: 20,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Parry all frontal melee attacks.",
        description: "Allows parrying of all melee attacks from the front."
    }
];


// ===============================
// RANGER SPELL LIST UI
// ===============================
// ===============================
// RANGER DISCIPLINE LIST UI
// ===============================
(function loadRangerDisciplineList() {

    const container = document.createElement("div");
    container.id = "rngSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Ranger ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_RNG.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "rngSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// SHADOW KNIGHT DISCIPLINE DATA
// ===============================
window.SpellData_SHD = [
    {
        id: "SHD_RESISTANT",
        name: "Resistant Discipline",
        class: "SHD",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+10 all resists.",
        description: "Increases all resistances by 10."
    },
    {
        id: "SHD_FEARLESS",
        name: "Fearless Discipline",
        class: "SHD",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "SHD_UNHOLY_AURA",
        name: "Unholy Aura Discipline",
        class: "SHD",
        category: "Discipline",
        minDurationSeconds: 180, // Next Harm Touch or 3 min
        maxDurationSeconds: 180,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "+50% Harm Touch damage, nearly unresistable.",
        description: "Empowers Harm Touch with increased damage and resist adjust."
    },
    {
        id: "SHD_LEECHCURSE",
        name: "Leechcurse Discipline",
        class: "SHD",
        category: "Discipline",
        minDurationSeconds: 20,
        maxDurationSeconds: 20,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Heal for every melee hit.",
        description: "Converts melee damage dealt into healing."
    }
];

// ===============================
// SHADOW KNIGHT DISCIPLINE LIST UI
// ===============================
(function loadShadowKnightDisciplineList() {

    const container = document.createElement("div");
    container.id = "shdSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Shadow Knight ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_SHD.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "shdSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// PALADIN DISCIPLINE DATA
// ===============================
window.SpellData_PAL = [
    {
        id: "PAL_RESISTANT",
        name: "Resistant Discipline",
        class: "PAL",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+10 all resists.",
        description: "Increases all resistances by 10."
    },
    {
        id: "PAL_FEARLESS",
        name: "Fearless Discipline",
        class: "PAL",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear.",
        description: "Grants immunity to fear effects."
    },
    {
        id: "PAL_HOLYFORGE",
        name: "Holyforge Discipline",
        class: "PAL",
        category: "Discipline",
        minDurationSeconds: 120,
        maxDurationSeconds: 300, // patch note: increased to 5 min
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Crits vs all, crippling vs undead.",
        description: "Increases critical hit chance and crippling blows vs undead."
    },
    {
        id: "PAL_SANCTIFICATION",
        name: "Sanctification Discipline",
        class: "PAL",
        category: "Discipline",
        minDurationSeconds: 15,
        maxDurationSeconds: 15,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "100% spell resist.",
        description: "Resists all spells that are not unresistable."
    }
];

// ===============================
// PALADIN DISCIPLINE LIST UI
// ===============================
(function loadPaladinDisciplineList() {

    const container = document.createElement("div");
    container.id = "palSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Paladin ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    SpellData_PAL.forEach(spell => {
        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "palSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

// ===============================
// BARD DISCIPLINE DATA
// ===============================
window.SpellData_BRD = [
    {
        id: "BRD_RESISTANT",
        name: "Resistant Discipline",
        class: "BRD",
        category: "Discipline",
        minDurationSeconds: 60,
        maxDurationSeconds: 300, // patch note: increased to 5 minutes
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 51,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "+10 all resists. Bard must stop singing before activating.",
        description: "Increases all resistances by 10. Cancels if songs are active."
    },
    {
        id: "BRD_FEARLESS",
        name: "Fearless Discipline",
        class: "BRD",
        category: "Discipline",
        minDurationSeconds: 11,
        maxDurationSeconds: 11,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 54,
        spellLevelMax: 60,
	reuseSeconds: 3600,
        notes: "Immunity to fear. Bard must stop singing before activating.",
        description: "Grants immunity to fear effects. Cancels if songs are active."
    },
    {
        id: "BRD_DEFTDANCE",
        name: "Deftdance Discipline",
        class: "BRD",
        category: "Discipline",
        minDurationSeconds: 15, // patch note: increased to 15 seconds
        maxDurationSeconds: 15,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 55,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Auto-dodge frontal attacks + auto dual-wield. Bard must stop singing.",
        description: "Allows automatic dodging of frontal attacks and auto dual-wield."
    },
    {
        id: "BRD_PURETONE",
        name: "Puretone Discipline",
        class: "BRD",
        category: "Discipline",
        minDurationSeconds: 240, // patch note: increased to 4 minutes
        maxDurationSeconds: 240,
        breakable: false,
        scalesWithLevel: false,
        spellLevelMin: 60,
        spellLevelMax: 60,
	reuseSeconds: 4320,
        notes: "Acts as best instrument of every type (28 mod). Works on singing mod.",
        description: "Makes all songs behave as if using the best instrument of each type."
    }
];

// ===============================
// BARD DISCIPLINE LIST UI
// ===============================
(function loadBardDisciplineList() {

    const container = document.createElement("div");
    container.id = "brdSpellList";
    container.style.marginTop = "15px";
    container.style.padding = "10px";
    container.style.border = "1px solid #444";
    container.style.background = "#111";
    container.style.color = "white";
    container.style.borderRadius = "6px";

    const title = document.createElement("h4");
    title.textContent = "Bard ‚Äî Disciplines";
    title.style.marginTop = "0";
    container.appendChild(title);

    // Grid wrapper
    const grid = document.createElement("div");
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(3, 1fr)";
    grid.style.gap = "6px 20px";
    grid.style.marginTop = "10px";
    container.appendChild(grid);

    // Add each discipline
    SpellData_BRD.forEach(spell => {

        const cell = document.createElement("div");
        cell.style.display = "flex";
        cell.style.alignItems = "center";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.spellId = spell.id;
        checkbox.style.marginRight = "6px";

        const label = document.createElement("span");
        label.textContent = spell.name;

        cell.appendChild(checkbox);
        cell.appendChild(label);
        grid.appendChild(cell);

        checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
                createSpellTimerUI(spell, "brdSpellList");
            } else {
                removeSpellTimerUI(spell.id);
            }
        });
    });

    document.body.appendChild(container);
})();

__DBG("past BARD DISCIPLINE LIST UI()66644431111333");
// ===============================
// SPELL REGISTRY BOOTSTRAPPER (FULLY INSTRUMENTED)
// ===============================

__DBG("ENTER: SPELL REGISTRY BOOTSTRAPPER");

//window.SpellRegistry = {};
//window.UserOverrides = {};
//window.UserCustomSpells = [];
//window.SpellClassAvailable = {};

//let SpellRegistry = window.SpellRegistry;
//let UserOverrides = window.UserOverrides;
//let UserCustomSpells = window.UserCustomSpells;
//let SpellClassAvailable = window.SpellClassAvailable;


(function bootstrapSpellRegistry() {
    __DBG("ENTER: bootstrapSpellRegistry()");

    let foundClasses = 0;
    let skippedNonArrays = 0;
    let skippedInvalidSpells = 0;

    for (const key in window) {

        // Only process SpellData_*
        if (!key.startsWith("SpellData_")) {
            continue;
        }

        __DBG("FOUND SpellData KEY: " + key);

        const classCode = key.replace("SpellData_", "");
        const spellArray = window[key];

        // Validate array
        if (!Array.isArray(spellArray)) {
            __DBG("SKIP: " + key + " is NOT an array.");
            skippedNonArrays++;
            continue;
        }

        __DBG("PASS: " + key + " is a valid spell array.");
        foundClasses++;

        // Mark class as available
        SpellClassAvailable[classCode] = true;
        __DBG("CLASS AVAILABLE: " + classCode);

        // Clone spells safely
        SpellRegistry[classCode] = [];

        spellArray.forEach((spell, idx) => {
            if (spell && typeof spell === "object") {
                SpellRegistry[classCode].push({ ...spell });
            } else {
                __DBG("SKIP INVALID SPELL: " + key + " index=" + idx);
                skippedInvalidSpells++;
            }
        });

        __DBG("CLASS " + classCode + " LOADED: " + SpellRegistry[classCode].length + " spells.");
    }

    __DBG("BOOTSTRAP SUMMARY:");
    __DBG("  Classes found: " + foundClasses);
    __DBG("  Non-arrays skipped: " + skippedNonArrays);
    __DBG("  Invalid spells skipped: " + skippedInvalidSpells);

    __DBG("EXIT: bootstrapSpellRegistry()");
})();

__DBG("PASS: SPELL REGISTRY BOOTSTRAPPER COMPLETE");


__DBG("past SPELL REGISTRY BOOTSTRAPPER (SAFE VERSION)()66611144431111333");
// <<keep this below all abilitys but above swoosh panel menu // swoosh
// keep this below the boot strapper above the swoosh pannel >>

// ===============================
// AUTO-GENERATE FIRST SWOOSH SAVE (FIRST RUN) ‚Äî FULLY INSTRUMENTED
// ===============================

// REMOVE auto-first-run swoosh entirely.
// It conflicts with manual swoosh loading.


__DBG("EXIT: autoFirstRunSwoosh()");


// keep above swoosh panel, below swoosh load by text

function triggerSwooshLoadDialog() {
    __DBG("ENTER: triggerSwooshLoadDialog()");

    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".txt,.log,.json";

    input.addEventListener("change", () => {
        const file = input.files && input.files[0];
        if (!file) {
            __DBG("SKIP: No file selected in triggerSwooshLoadDialog().");
            return;
        }

        __DBG("PASS: File selected: " + file.name);

        const reader = new FileReader();

        reader.onload = () => {
            const text = reader.result || "";
            __DBG("PASS: File read complete, length=" + text.length);
            try {
                swooshLoadFromText(text);
                __DBG("PASS: swooshLoadFromText() CALL RETURNED.");
            } catch (e) {
                __DBG("ERROR: swooshLoadFromText() threw: " + e.message);
            }
        };

        reader.onerror = () => {
            __DBG("ERROR: FileReader failed in triggerSwooshLoadDialog().");
            logLine("Failed to read swoosh file.");
        };

        reader.readAsText(file);
    });

    input.click();
}


window.addEventListener("DOMContentLoaded", () => {
    window.updateSwooshListUI = function(timestamp) {
        const listDiv = document.getElementById("swooshList");
        if (!listDiv) {
            __DBG("updateSwooshListUI: #swooshList not found.");
            return;
        }

        const label = timestamp
            ? `Loaded Swoosh: ${new Date(timestamp).toLocaleString()}`
            : "Loaded Swoosh: Loaded (no timestamp)";

        listDiv.textContent = label;
        __DBG("updateSwooshListUI: " + label);
    };
});

__DBG("ENTER: SWOOSH PANEL");
// ===============================
// SWOOSH PANEL (FULLY INSTRUMENTED + DOWNLOAD BUTTON)
// ===============================
// ===============================
// SWOOSH PANEL (SAVE / LOAD / DOWNLOAD / SYNC)
// ===============================
window.addEventListener("DOMContentLoaded", () => {
    (function createSwooshPanel() {
        __DBG("ENTER: createSwooshPanel()");

        // --- PANEL CONTAINER ---
        const panel = document.createElement("div");
        panel.id = "swooshPanel";
        panel.style.marginTop = "25px";
        panel.style.padding = "12px";
        panel.style.border = "1px solid #888";
        panel.style.background = "#111";
        panel.style.color = "white";
        panel.style.borderRadius = "6px";
        __DBG("PASS: Created swooshPanel DIV.");

        // --- TITLE ---
        const title = document.createElement("h3");
        title.textContent = "Swoosh System ‚Äî Save / Load";
        panel.appendChild(title);
        __DBG("PASS: Title appended to panel.");

        // --- INFO TEXT ---
        const info = document.createElement("div");
        info.style.fontSize = "13px";
        info.style.opacity = "0.8";
        info.style.marginBottom = "10px";
info.innerHTML = `
    The Swoosh System saves your entire spell database, including overrides and custom spells.<br>
    Load or download your swoosh log to restore your personalized spell system. Save first, then download.<br>
    It will also save and restore your Long Term Timers.
`;

        panel.appendChild(info);
        __DBG("PASS: Info block appended to panel.");

        // --- BUTTON ROW ---
        const btnRow = document.createElement("div");
        btnRow.style.display = "flex";
        btnRow.style.gap = "10px";
        btnRow.style.marginBottom = "12px";
        __DBG("PASS: Created swooshPanel BUTTON ROW.");

        // ===============================
        // SAVE BUTTON
        // ===============================
        const saveBtn = document.createElement("button");
        saveBtn.textContent = "Swoosh Save";
        saveBtn.style.padding = "6px 12px";

        saveBtn.addEventListener("click", () => {
            __DBG("EVENT: Swoosh Save button CLICKED.");
            try {
                swooshSave();
                __DBG("PASS: swooshSave() CALL RETURNED.");
            } catch (e) {
                __DBG("ERROR: swooshSave() threw: " + e.message);
            }
        });

        btnRow.appendChild(saveBtn);
        __DBG("PASS: Save button appended.");

        // ===============================
        // LOAD BUTTON
        // ===============================
        const loadBtn = document.createElement("button");
        loadBtn.textContent = "Swoosh Load";
        loadBtn.style.padding = "6px 12px";

        loadBtn.addEventListener("click", () => {
            __DBG("EVENT: Swoosh Load button CLICKED.");
            try {
                triggerSwooshLoadDialog();
                __DBG("PASS: triggerSwooshLoadDialog() CALL RETURNED.");
            } catch (e) {
                __DBG("ERROR: triggerSwooshLoadDialog() threw: " + e.message);
            }
        });

        btnRow.appendChild(loadBtn);
        __DBG("PASS: Load button appended.");

        // ===============================
        // DOWNLOAD FULL LOG BUTTON
        // ===============================
        const downloadBtn = document.createElement("button");
        downloadBtn.textContent = "Download Full Log";
        downloadBtn.style.padding = "6px 12px";

        downloadBtn.addEventListener("click", () => {
            __DBG("EVENT: Download Full Log button CLICKED.");

            try {
                const logEl = document.getElementById("log");
                if (!logEl) {
                    __DBG("ERROR: #log element NOT FOUND.");
                    alert("Log element not found ‚Äî cannot download.");
                    return;
                }

                const text = logEl.value || logEl.innerText || "";
                __DBG("DOWNLOAD: Retrieved log text length=" + text.length);

                const blob = new Blob([text], { type: "text/plain" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
                a.href = url;
                a.download = `swoosh_log_${timestamp}.txt`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                __DBG("PASS: Log download triggered.");
            } catch (e) {
                __DBG("ERROR: Download failed: " + e.message);
                alert("Failed to download log: " + e.message);
            }
        });

        btnRow.appendChild(downloadBtn);
        __DBG("PASS: Download button appended.");

        // ===============================
        // SYNC ALL TIMERS BUTTON (NEW)
        // ===============================
        const syncBtn = document.createElement("button");
        syncBtn.textContent = "Sync All Timers";
        syncBtn.style.padding = "6px 12px";
        syncBtn.style.opacity = "0.4";
        syncBtn.style.pointerEvents = "none"; // disabled until swoosh loaded

        syncBtn.addEventListener("click", () => {
            __DBG("EVENT: Sync All Timers button CLICKED.");

            try {
                const engine = (typeof SpellTimerEngine !== "undefined") ? SpellTimerEngine : null;

                if (!engine) {
                    __DBG("SYNC ERROR: SpellTimerEngine not ready (global not defined).");
                    alert("Engine not ready ‚Äî cannot sync timers.");
                    return;
                }

                // Resolve timers collection safely
                let timersMap = null;

                if (typeof timers !== "undefined") {
                    timersMap = timers;
                } else if (engine.timers && typeof engine.timers.forEach === "function") {
                    timersMap = engine.timers;
                }

                if (!timersMap || typeof timersMap.forEach !== "function") {
                    __DBG("SYNC ERROR: timers collection not available.");
                    alert("Timers not available ‚Äî nothing to sync.");
                    return;
                }

                timersMap.forEach((t, spellId) => {
                    __DBG("SYNC: Resetting " + spellId + " to override/computed duration.");
                    engine.resetTimer(spellId);
                });

                __DBG("PASS: All timers synced.");
                alert("All timers synced to overrides.");

            } catch (e) {
                __DBG("ERROR: Sync failed: " + e.message);
                alert("Sync failed: " + e.message);
            }
        });

        btnRow.appendChild(syncBtn);
        __DBG("PASS: Sync button appended (initially disabled).");

        panel.appendChild(btnRow);

        // ===============================
        // LOADED SWOOSH TITLE + DISPLAY
        // ===============================
        const listTitle = document.createElement("h4");
        listTitle.textContent = "Loaded Swoosh:";
        panel.appendChild(listTitle);

        const swooshList = document.createElement("div");
        swooshList.id = "swooshList";
        swooshList.style.fontSize = "13px";
        swooshList.style.opacity = "0.9";
        swooshList.textContent = "None loaded.";
        panel.appendChild(swooshList);

        // ===============================
        // HOOK INTO updateSwooshListUI
        // ===============================
        const oldUpdate = window.updateSwooshListUI;

        window.updateSwooshListUI = function (timestamp) {
            __DBG("HOOK: updateSwooshListUI called ‚Äî enabling Sync button.");

            if (typeof oldUpdate === "function") {
                try {
                    oldUpdate(timestamp);
                } catch (e) {
                    __DBG("WARNING: old updateSwooshListUI crashed early: " + e.message);
                }
            }

            syncBtn.style.opacity = "1";
            syncBtn.style.pointerEvents = "auto";
        };

        // ===============================
        // APPEND PANEL TO BODY
        // ===============================
        document.body.appendChild(panel);
        __DBG("PASS: swooshPanel appended to document.body.");
        __DBG("EXIT: createSwooshPanel() COMPLETE.");
    })();
});

__DBG("past SWOOSH PANEL (FULLY INSTRUMENTED)");  

// ===============================
// AUTO‚ÄëENABLE CLASSES BASED ON SPELL DATA (BLOCK 3.99)
// ===============================

// Map class codes to the expected spell data variable name
const SpellDataSources = {
    NEC: "SpellData_NEC",
    RNG: "SpellData_RNG",
    SHM: "SpellData_SHM",
    ENC: "SpellData_ENC",
    MAG: "SpellData_MAG",
    WIZ: "SpellData_WIZ",
    CLR: "SpellData_CLR",
    DRU: "SpellData_DRU",
    BRD: "SpellData_BRD",
    MNK: "SpellData_MNK",
    ROG: "SpellData_ROG",
    PAL: "SpellData_PAL",
    SHD: "SpellData_SHD",
    WAR: "SpellData_WAR"
};

// Enable only classes that have spell data arrays
window.addEventListener("DOMContentLoaded", () => {

    Object.entries(SpellDataSources).forEach(([classCode, varName]) => {

        const exists = (typeof window[varName] !== "undefined");

        if (exists) {
            // Enable this class in the selector
            enableSpellClass(classCode);
        } else {
            // Disable this class in the selector
            const selector = document.querySelectorAll("#spellTimerClassSelector input[type='checkbox']");
            selector.forEach(cb => {
                if (cb.dataset.classCode === classCode) {
                    cb.disabled = true;
                    cb.nextSibling.style.opacity = "0.4"; // fade label
                }
            });
        }
    });

});


// ===============================
// SPELL TIMER SYSTEM: CLASS VISIBILITY CONTROL (BLOCK #4)
// ===============================

// Map class codes to their spell list container IDs
const SpellListContainers = {
    NEC: "necSpellList",
    ROG: "rogSpellList",
    WAR: "warSpellList",
    MNK: "mnkSpellList",
    RNG: "rngSpellList",
    SHD: "shdSpellList",
    PAL: "palSpellList",
    BRD: "brdSpellList",
};


// Hide all spell lists AFTER they are created
window.addEventListener("DOMContentLoaded", () => {
    setTimeout(() => {
        Object.values(SpellListContainers).forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = "none";
        });
    }, 50);
});

// Show/hide spell lists when class selection changes
document.addEventListener("SpellClassSelectionChanged", (e) => {
    const flags = e.detail.flags;

    Object.entries(SpellListContainers).forEach(([classCode, elementId]) => {
        const el = document.getElementById(elementId);
        if (!el) return;

        el.style.display = flags[classCode] ? "block" : "none";
    });
});

// notes push


function formatTime(seconds) {
    seconds = Math.max(0, Math.floor(seconds));

    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;

    if (h > 0) {
        return `${h}:${m.toString().padStart(2,"0")}:${s.toString().padStart(2,"0")}`;
    }
    return `${m}:${s.toString().padStart(2,"0")}`;
}

// === SPELL TIMER SYSTEM: BLOCK #5 ‚Äî CORE TIMER ENGINE (UPDATED WITH COOLDOWNS) ===
const SpellTimerEngine = (function () {

    // ===============================
    // INTERNAL STATE
    // ===============================
    const timers = new Map();      // spellId -> timerState
    const history = new Map();     // spellId -> [entries]
    const activeClasses = new Set();

    const listeners = {
        timerUpdate: [],
        timerRemove: [],
        historyUpdate: [],
        activeClassesChange: []
    };

    // ===============================
    // INTERNAL HELPERS
    // ===============================

    function emit(event, payload) {
        const list = listeners[event];
        if (!list) return;
        list.forEach(fn => {
            try { fn(payload); } catch (e) {
                console.error("SpellTimerEngine listener error:", e);
            }
        });
    }

    function getActiveClasses() {
        return Array.from(activeClasses);
    }

    function recalcActiveClassesFor(classCode) {
        if (!classCode) return;
        let stillHas = false;
        timers.forEach(t => {
            if (t.classCode === classCode) stillHas = true;
        });
        if (!stillHas) {
            activeClasses.delete(classCode);
        }
        emit("activeClassesChange", getActiveClasses());
    }

    function ensureSpellId(spell) {
        if (!spell) return null;
        if (!spell.id) {
            const cls = spell.class || "GEN";
            const base = (spell.name || "SPELL").replace(/\s+/g, "_").toUpperCase();
            spell.id = `${cls}_${base}`;
        }
        return spell.id;
    }

    function captureNotes(t) {
        const ui = t.ui;
        if (ui?.notesArea) {
            updateNotes(t.spellId, ui.notesArea.value);
        }
    }

    // ===============================
    // CORE ENGINE FUNCTIONS
    // ===============================

    function ensureTimer(spell) {
        __DBG("ENTER: ensureTimer(" + (spell?.id || spell?.name || "UNKNOWN") + ")");

        if (!spell) {
            __DBG("ensureTimer: No spell provided ‚Äî ABORT.");
            return null;
        }

        const spellId = ensureSpellId(spell);
        if (!spellId) {
            __DBG("ensureTimer: Failed to resolve spellId ‚Äî ABORT.");
            return null;
        }

        let t = timers.get(spellId);

        if (!t) {
            __DBG("ensureTimer: Creating NEW timer for " + spellId);

            let baseDur;

            if (UserOverrides[spellId] &&
                typeof UserOverrides[spellId].baseDuration === "number") {

                baseDur = UserOverrides[spellId].baseDuration;
                __DBG("ensureTimer: Using OVERRIDE duration for " + spellId + " => " + baseDur);

            } else {
                baseDur = SpellTimerEngine.computeDuration(spell);
                __DBG("ensureTimer: Using COMPUTED duration for " + spellId + " => " + baseDur);
            }

            t = {
                spellId,
                spellName: spell.name || spellId,
                classCode: spell.class || null,
                spell,
                baseDuration: baseDur,
                remaining: baseDur,
                running: false,
                startedAt: null,
                elapsedAccum: 0,
                notes: "",
                levelOverride: null
            };

            timers.set(spellId, t);

            if (t.classCode) {
                activeClasses.add(t.classCode);
                emit("activeClassesChange", getActiveClasses());
                __DBG("ensureTimer: Added active class " + t.classCode);
            }

            __DBG("ensureTimer: NEW timer created for " + spellId);
        } else {
            __DBG("ensureTimer: Existing timer found for " + spellId);
        }

        __DBG("EXIT: ensureTimer(" + spellId + ")");
        return t;
    }

    function createTimer(spell) {
        const t = ensureTimer(spell);
        if (!t) return null;
        emit("timerUpdate", { type: "create", timer: { ...t } });
        return t;
    }

    function removeTimer(spellId) {
        const t = timers.get(spellId);
        if (!t) {
            emit("timerRemove", { spellId });
            return;
        }
        timers.delete(spellId);
        recalcActiveClassesFor(t.classCode);
        emit("timerRemove", { spellId });
    }

    function internalUpdateState(t, type) {
        emit("timerUpdate", { type: type || "state", timer: { ...t } });
    }

    function startTimer(spellId) {
        const t = timers.get(spellId);
        if (!t || t.running) return;

        t.running = true;
        t.startedAt = performance.now();

        logLineWithRoster(`Started timer: ${t.spellName}`);
        internalUpdateState(t, "state");
    }

    function pauseTimer(spellId) {
        const t = timers.get(spellId);
        if (!t || !t.running) return;

        const now = performance.now();
        const delta = (now - t.startedAt) / 1000;

        t.elapsedAccum += delta;
        t.startedAt = null;
        t.running = false;

        t.remaining = Math.max(0, t.baseDuration - t.elapsedAccum);

        logLineWithRoster(`Paused timer: ${t.spellName}`);
        internalUpdateState(t, "state");
    }

    function resetTimer(spellId) {
        __DBG("ENTER: resetTimer(" + spellId + ")");

        const t = timers.get(spellId);
        if (!t) {
            __DBG("RESET: No timer found ‚Äî ABORT.");
            return;
        }

        let newDur;

        if (typeof t.baseDuration === "number" && t.baseDuration > 0) {
            newDur = t.baseDuration;
        } else {
            newDur = SpellTimerEngine.computeDuration(t.spell, t.levelOverride);
        }

        t.baseDuration = newDur;
        t.remaining = newDur;
        t.running = false;
        t.startedAt = null;
        t.elapsedAccum = 0;

        internalUpdateState(t, "reset");
        __DBG("EXIT: resetTimer(" + spellId + ")");
    }

    function finalizeElapsed(t) {
        if (t.running) {
            const now = performance.now();
            const delta = (now - t.startedAt) / 1000;
            t.elapsedAccum += delta;
            t.startedAt = null;
            t.running = false;
        }

        if (t.baseDuration > 0 && t.elapsedAccum === 0) {
            t.elapsedAccum = t.baseDuration;
        }

        t.remaining = Math.max(0, t.baseDuration - t.elapsedAccum);
    }

    function completeTimer(spellId) {
        const t = timers.get(spellId);
        if (!t) return;

        captureNotes(t);
        finalizeElapsed(t);

        const actual = t.elapsedAccum || t.baseDuration || 0;

        logLineWithRoster(`Completed: ${t.spellName} (Duration: ${formatTime(actual)})`);
        logHistory(spellId, "Completed", actual, t.notes);

        resetTimer(spellId);
    }

    function fadeEarlyTimer(spellId) {
        const t = timers.get(spellId);
        if (!t) return;

        captureNotes(t);
        finalizeElapsed(t);

        const actual = t.elapsedAccum || 0;

        logLineWithRoster(`Faded Early: ${t.spellName} (Duration: ${formatTime(actual)})`);
        logHistory(spellId, "Faded Early", actual, t.notes);

        resetTimer(spellId);
    }

    function updateNotes(spellId, notes) {
        const t = timers.get(spellId);
        if (!t) return;

        t.notes = notes || "";
        logLineWithRoster(`Notes updated for ${t.spellName}: "${t.notes}"`);
        internalUpdateState(t, "notes");
    }

    function logHistory(spellId, result, durationSeconds, notes) {
        if (!history.has(spellId)) history.set(spellId, []);

        const entry = {
            timestamp: new Date(),
            result,
            durationSeconds: durationSeconds || 0,
            notes: notes || ""
        };

        history.get(spellId).push(entry);

        emit("historyUpdate", {
            spellId,
            entry,
            history: history.get(spellId).slice()
        });
    }

    function getHistory(spellId) {
        return history.has(spellId) ? history.get(spellId).slice() : [];
    }

    function getAverageDuration(spellId) {
        const h = history.get(spellId);
        if (!h || !h.length) return 0;
        const sum = h.reduce((acc, e) => acc + (e.durationSeconds || 0), 0);
        return sum / h.length;
    }

    function on(eventName, handler) {
        if (!listeners[eventName]) {
            console.warn("SpellTimerEngine.on: unknown event", eventName);
            return;
        }
        listeners[eventName].push(handler);
    }

    function spawnCooldownTimer(t) {
        const reuse = t.spell && t.spell.reuseSeconds;
        if (!reuse) return;

        const cdSpell = {
            id: t.spellId + "_COOLDOWN",
            name: t.spellName + " ‚Äî COOLDOWN REUSE TIMER",
            class: t.classCode,
            minDurationSeconds: reuse,
            maxDurationSeconds: reuse,
            scalesWithLevel: false
        };

        const newTimer = createTimer(cdSpell);
        if (newTimer) {
            startTimer(cdSpell.id);
        }
    }
// ===============================
// TICK LOOP
// ===============================
function tickLoop() {
    const now = performance.now();

    timers.forEach(t => {
        if (!t.running) return;

        const elapsed = t.elapsedAccum + (now - t.startedAt) / 1000;
        t.elapsed = elapsed;

        const remaining = Math.max(0, t.baseDuration - elapsed);
        t.remaining = remaining;

        const done = remaining <= 0.01;

        if (done) {
            t.running = false;
            t.startedAt = null;
            t.elapsedAccum = t.baseDuration;

            captureNotes(t);

if (t.cooldownId) {

    // Make cooldown timer visible in UI
    const cdBox = TimerUIMap.get(t.cooldownId);
    if (cdBox) cdBox.style.display = "block";

    const cdClone = CloneUIMap.get(t.cooldownId);
    if (cdClone) cdClone.style.display = "block";

    // Start the cooldown timer
    SpellTimerEngine.startTimer(t.cooldownId);
}


            logHistory(t.spellId, "Completed", t.baseDuration, t.notes);
            internalUpdateState(t, "auto-complete");

        } else {
            internalUpdateState(t, "tick");
        }
    });

    requestAnimationFrame(tickLoop);
}

    // ‚≠ê THIS MUST BE INDENTED ‚Äî INSIDE THE IIFE
    requestAnimationFrame(tickLoop);

    // ‚≠ê computeDuration MUST ALSO BE INSIDE THE IIFE
    function computeDuration(spell, levelOverride = null) {
        const min = spell.minDurationSeconds || 0;
        const max = spell.maxDurationSeconds || min;

        if (!spell.scalesWithLevel) return max;

        const lvlMin = spell.spellLevelMin || 1;
        const lvlMax = spell.spellLevelMax || lvlMin;

        const lvl = Math.max(lvlMin, Math.min(levelOverride || lvlMax, lvlMax));
        const pct = (lvl - lvlMin) / (lvlMax - lvlMin || 1);

        return Math.round(min + pct * (max - min));
    }

    return {
        timers,
        history,
        activeClasses,
        listeners,
        createTimer,
        removeTimer,
        startTimer,
        pauseTimer,
        resetTimer,
        completeTimer,
        fadeEarlyTimer,
        updateNotes,
        logHistory,
        getHistory,
        getAverageDuration,
        getActiveClasses,
        on,
        computeDuration
    };

})();  // END OF ENGINE




__DBG("past MAIN TICK LOOP ()999");

// ===============================
// SPELL TIMER SYSTEM: BLOCK #6 ()‚Äî UI BUILDER (UPDATED)
// ===============================

// Where the bottom panel will insert timers (Block 7 will create this container)
let SPELL_TIMER_MASTER_CONTAINER = null;

// Map spellId -> DOM container for the timer
const TimerUIMap = new Map();

// Helper: format seconds as mm:ss
function fmtTime(sec) {
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${s.toString().padStart(2, "0")}`;
}

// PUBLIC: Create a timer UI for a spell
function createSpellTimerUI(spell, parentContainerId) {
    if (!SPELL_TIMER_MASTER_CONTAINER) return;

    // ‚≠ê NEW: cooldown spells use the dual-timer UI
    if (spell.reuseSeconds) {
        return createDualTimerUI(spell);
    }

    // ‚≠ê OLD BEHAVIOR for normal spells
    const t = SpellTimerEngine.createTimer(spell);
    if (!t) return;

    if (TimerUIMap.has(spell.id)) return;

    const classSection = ensureClassSection(spell.class);

    const bottomBox = buildTimerBox(spell, t);
    classSection.appendChild(bottomBox);
    TimerUIMap.set(spell.id, bottomBox);

    const cloneBox = buildTimerBoxClone(spell, t);
    CloneUIMap.set(spell.id, cloneBox);

    const cloneContainer = document.getElementById("spellTimerPanelContainer_clone");
    if (cloneContainer) {
        cloneContainer.appendChild(cloneBox);
    }
}
function buildTimerBoxClone(spell, t) {
    __DBG("ENTER: buildTimerBoxClone(" + spell.id + ")");

    const box = document.createElement("div");
    box.className = "section";
    box.style.marginTop = "6px";

    // ===============================
    // Save & Update button (SPELL TIMERS)
    // ===============================
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Save & Update";
    saveBtn.style.marginBottom = "6px";

    saveBtn.addEventListener("click", () => {
        __DBG("EVENT: Save & Update clicked for spell timer: " + spell.id);

        // Spell timers do not have editable duration/label/notes fields,
        // so we pass nulls. The handler will update internal timer state + swoosh.
        saveAndUpdateTimer(t, {
            durationInput: null,
            labelInput: null,
            notesInput: null
        });
    });

    box.appendChild(saveBtn);

    // ===============================
    // Title
    // ===============================
    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = spell.name;
    box.appendChild(title);

    // ===============================
    // Duration Display (NEW ‚Äî shows override!)
    // ===============================
    const durRow = document.createElement("div");
    durRow.style.fontSize = "12px";
    durRow.style.color = "#ccc";
    durRow.style.marginBottom = "6px";

    // Always show the REAL duration: the override if present
    const effectiveDuration = t.baseDuration || SpellTimerEngine.computeDuration(spell);
    durRow.textContent = "Duration (sec): " + effectiveDuration;

    __DBG("CLONE UI: Duration display for " + spell.id + " = " + effectiveDuration);

    box.appendChild(durRow);

    // ===============================
    // Progress Bar
    // ===============================
    const progOuter = document.createElement("div");
    progOuter.style.width = "100%";
    progOuter.style.height = "14px";
    progOuter.style.background = "#333";
    progOuter.style.border = "1px solid #555";
    progOuter.style.marginBottom = "6px";

    const progFill = document.createElement("div");
    progFill.style.height = "100%";
    progFill.style.width = "0%";
    progFill.style.background = "#3cb371";

    progOuter.appendChild(progFill);
    box.appendChild(progOuter);

    // ===============================
    // Time Labels
    // ===============================
    const timeElapsed = document.createElement("div");
    timeElapsed.style.fontSize = "12px";
    timeElapsed.style.color = "#ccc";
    timeElapsed.style.marginBottom = "2px";
    timeElapsed.textContent = "Elapsed: 0s";
    box.appendChild(timeElapsed);

    const timeRemaining = document.createElement("div");
    timeRemaining.style.fontSize = "12px";
    timeRemaining.style.color = "#ccc";
    timeRemaining.style.marginBottom = "6px";
    timeRemaining.textContent = "Remaining: 0s";
    box.appendChild(timeRemaining);

    // ===============================
    // Buttons (LIVE)
    // ===============================
    const btnRow = document.createElement("div");

    btnRow.appendChild(makeBtn("Start", () => SpellTimerEngine.startTimer(spell.id)));
    btnRow.appendChild(makeBtn("Pause", () => SpellTimerEngine.pauseTimer(spell.id)));
    btnRow.appendChild(makeBtn("Reset", () => SpellTimerEngine.resetTimer(spell.id)));
    btnRow.appendChild(makeBtn("Completed", () => SpellTimerEngine.completeTimer(spell.id)));
    btnRow.appendChild(makeBtn("Faded Early", () => SpellTimerEngine.fadeEarlyTimer(spell.id)));

    // Cooldown button
    if (spell.reuseSeconds) {
        const btnStartCooldown = makeBtn("Start Cooldown Reuse Timer Now", () => {
            if (t.cooldownId) {
                const cdBox = TimerUIMap.get(t.cooldownId);
                if (cdBox) cdBox.style.display = "block";

                const cdClone = CloneUIMap.get(t.cooldownId);
                if (cdClone) cdClone.style.display = "block";

                SpellTimerEngine.startTimer(t.cooldownId);
            }
        });

        btnStartCooldown.style.marginLeft = "6px";
        btnRow.appendChild(btnStartCooldown);
    }

    // Hide button
    const hideBtn = makeBtn("Hide", () => {
        box.style.display = "none";
    });
    hideBtn.style.marginLeft = "6px";
    btnRow.appendChild(hideBtn);

    box.appendChild(btnRow);

    // ===============================
    // Store UI refs for updates
    // ===============================
    box._ui = {
        progFill,
        timeElapsed,
        timeRemaining,
        notesArea: null,
        durationRow: durRow   // NEW ‚Äî so live updates can refresh duration
    };

    t.cloneUi = box._ui;

    __DBG("EXIT: buildTimerBoxClone(" + spell.id + ")");
    return box;
}



__DBG("past block 6 ()999666");

// PUBLIC: Remove timer UI
function removeSpellTimerUI(spellId) {
    const box = TimerUIMap.get(spellId);
    if (box && box.parentNode) {
        box.parentNode.removeChild(box);
    }
    TimerUIMap.delete(spellId);

    SpellTimerEngine.removeTimer(spellId);

    cleanupEmptyClassSections();
}
function buildTimerBox(spell, t) {
    __DBG("ENTER: buildTimerBox(" + spell.id + ")");

    const box = document.createElement("div");
    box.className = "section";
    box.style.marginTop = "6px";

    // ===============================
    // Save & Update button
    // ===============================
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Save & Update";
    saveBtn.style.marginBottom = "6px";

    saveBtn.addEventListener("click", () => {
        __DBG("EVENT: Save & Update clicked for spell timer: " + spell.id);

        saveAndUpdateTimer(t, {
            durationInput: null,
            labelInput: null,
            notesInput: null
        });
    });

    box.appendChild(saveBtn);

    // ===============================
    // Title
    // ===============================
    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = spell.name;
    box.appendChild(title);

    // ===============================
    // Duration Row (OVERRIDE-AWARE)
    // ===============================
    const durRow = document.createElement("div");
    durRow.style.marginBottom = "6px";

    const durLabel = document.createElement("span");
    durLabel.textContent = "Duration (sec): ";
    durRow.appendChild(durLabel);

    const durInput = document.createElement("input");
    durInput.type = "number";
    durInput.style.width = "70px";

    // Use override if present
    const effectiveDuration =
        t.baseDuration ||
        (UserOverrides[spell.id]?.baseDuration) ||
        SpellTimerEngine.computeDuration(spell);

    durInput.value = effectiveDuration;

    __DBG("UI: Duration input for " + spell.id + " = " + effectiveDuration);

    durInput.addEventListener("change", () => {
        const newVal = Number(durInput.value) || 0;

        __DBG("EVENT: Duration changed for " + spell.id + " => " + newVal);

        // Update timer object
        t.baseDuration = newVal;
        t.remaining = newVal;

        // Persist override
        if (!UserOverrides[spell.id]) UserOverrides[spell.id] = {};
        UserOverrides[spell.id].baseDuration = newVal;

        __DBG("OVERRIDE STORED: UserOverrides[" + spell.id + "].baseDuration=" + newVal);

        SpellTimerEngine.resetTimer(spell.id);
    });

    durRow.appendChild(durInput);
    box.appendChild(durRow);

    // ===============================
    // Progress Bar
    // ===============================
    const progOuter = document.createElement("div");
    progOuter.style.width = "100%";
    progOuter.style.height = "14px";
    progOuter.style.background = "#333";
    progOuter.style.border = "1px solid #555";
    progOuter.style.marginBottom = "6px";

    const progFill = document.createElement("div");
    progFill.style.height = "100%";
    progFill.style.width = "0%";
    progFill.style.background = "#3cb371";

    progOuter.appendChild(progFill);
    box.appendChild(progOuter);

    // ===============================
    // Time Labels
    // ===============================
    const timeElapsed = document.createElement("div");
    timeElapsed.style.fontSize = "12px";
    timeElapsed.style.color = "#ccc";
    timeElapsed.style.marginBottom = "2px";
    timeElapsed.textContent = "Elapsed: 0s";
    box.appendChild(timeElapsed);

    const timeRemaining = document.createElement("div");
    timeRemaining.style.fontSize = "12px";
    timeRemaining.style.color = "#ccc";
    timeRemaining.style.marginBottom = "6px";
    timeRemaining.textContent = "Remaining: 0s";
    box.appendChild(timeRemaining);

    // ===============================
    // Buttons
    // ===============================
    const btnRow = document.createElement("div");

    btnRow.appendChild(makeBtn("Start", () => {
        __DBG("BTN: Start pressed for " + spell.id);
        SpellTimerEngine.startTimer(spell.id);
    }));

    btnRow.appendChild(makeBtn("Pause", () => {
        __DBG("BTN: Pause pressed for " + spell.id);
        SpellTimerEngine.pauseTimer(spell.id);
    }));

    btnRow.appendChild(makeBtn("Reset", () => {
        __DBG("BTN: Reset pressed for " + spell.id);
        SpellTimerEngine.resetTimer(spell.id);
    }));

    btnRow.appendChild(makeBtn("Completed", () => {
        __DBG("BTN: Completed pressed for " + spell.id);
        SpellTimerEngine.completeTimer(spell.id);
    }));

    btnRow.appendChild(makeBtn("Faded Early", () => {
        __DBG("BTN: Faded Early pressed for " + spell.id);
        SpellTimerEngine.fadeEarlyTimer(spell.id);
    }));

    // Cooldown button
    if (spell.reuseSeconds) {
        const btnStartCooldown = makeBtn("Start Cooldown Reuse Timer Now", () => {
            __DBG("BTN: Start Cooldown pressed for " + spell.id);

            if (t.cooldownId) {
                const cdBox = TimerUIMap.get(t.cooldownId);
                if (cdBox) cdBox.style.display = "block";

                const cdClone = CloneUIMap.get(t.cooldownId);
                if (cdClone) cdClone.style.display = "block";

                SpellTimerEngine.startTimer(t.cooldownId);
            }
        });

        btnStartCooldown.style.marginLeft = "6px";
        btnRow.appendChild(btnStartCooldown);
    }

    // Info button
    btnRow.appendChild(makeBtn("Info", () => {
        __DBG("BTN: Info pressed for " + spell.id);
        alert(
            `${spell.name}\n\n` +
            `${spell.description || "No description available."}\n\n` +
            `Notes: ${spell.notes || "None"}`
        );
    }));

    // Show in Top Panel
    btnRow.appendChild(makeBtn("Show Top", () => {
        __DBG("BTN: Show Top pressed for " + spell.id);
        const cloneBox = CloneUIMap.get(spell.id);
        if (cloneBox) cloneBox.style.display = "block";
    }));

    box.appendChild(btnRow);

    // ===============================
    // Notes
    // ===============================
    const notesLabel = document.createElement("div");
    notesLabel.textContent = "Notes:";
    notesLabel.style.marginTop = "6px";
    box.appendChild(notesLabel);

    const notesArea = document.createElement("textarea");
    notesArea.style.height = "50px";
    notesArea.value = t.notes || "";
    box.appendChild(notesArea);

    const saveNotesBtn = makeBtn("Save Notes", () => {
        __DBG("BTN: Save Notes pressed for " + spell.id);
        SpellTimerEngine.updateNotes(spell.id, notesArea.value);
    });
    saveNotesBtn.style.marginTop = "4px";
    box.appendChild(saveNotesBtn);

    // ===============================
    // History Table
    // ===============================
    const histTitle = document.createElement("div");
    histTitle.textContent = "History:";
    histTitle.style.marginTop = "6px";
    histTitle.style.fontWeight = "bold";
    box.appendChild(histTitle);

    const histTable = document.createElement("table");

    const hthead = document.createElement("thead");
    hthead.innerHTML = `
        <tr>
            <th>Time</th>
            <th>Result</th>
            <th>Duration</th>
            <th>Notes</th>
        </tr>`;
    histTable.appendChild(hthead);

    const htbody = document.createElement("tbody");
    histTable.appendChild(htbody);

    box.appendChild(histTable);

    // ===============================
    // Store UI references
    // ===============================
    box._ui = {
        progFill,
        timeElapsed,
        timeRemaining,
        notesArea,
        histBody: htbody,
        durationInput: durInput
    };

    t.ui = box._ui;

    __DBG("EXIT: buildTimerBox(" + spell.id + ")");
    return box;
}



__DBG("function buildTimerBox ()999777666");

function createDualTimerUI(spell) {
    __DBG("ENTER: createDualTimerUI(" + spell.id + ")");

    const classSection = ensureClassSection(spell.class);

    // ============================================================
    // MAIN TIMER
    // ============================================================
    __DBG("DUAL: Creating MAIN timer for " + spell.id);
    const mainTimer = SpellTimerEngine.createTimer(spell);

    const mainBox = buildTimerBox(spell, mainTimer);
    classSection.appendChild(mainBox);
    TimerUIMap.set(spell.id, mainBox);

    // ============================================================
    // COOLDOWN SPELL OBJECT
    // ============================================================
    const cdSpell = {
        id: spell.id + "_CD",
        name: spell.name + " ‚Äî Cooldown",
        class: spell.class,
        minDurationSeconds: spell.reuseSeconds,
        maxDurationSeconds: spell.reuseSeconds,
        scalesWithLevel: false
    };

    __DBG("DUAL: Creating COOLDOWN timer for " + cdSpell.id);

    // ============================================================
    // COOLDOWN TIMER (override-aware via ensureTimer + computeDuration)
    // ============================================================
    const cdTimer = SpellTimerEngine.createTimer(cdSpell);

    // Build cooldown UI
    const cdBox = buildTimerBox(cdSpell, cdTimer);
    cdBox.style.display = "none"; // hidden until needed
    classSection.appendChild(cdBox);
    TimerUIMap.set(cdSpell.id, cdBox);

    // ============================================================
    // LINK MAIN ‚Üí COOLDOWN
    // ============================================================
    mainTimer.cooldownId = cdSpell.id;
    __DBG("DUAL: Linked " + spell.id + " ‚Üí cooldown " + cdSpell.id);

    // ============================================================
    // CLONE PANEL
    // ============================================================
    const cloneContainer = document.getElementById("spellTimerPanelContainer_clone");

    __DBG("DUAL: Creating MAIN clone for " + spell.id);
    const mainClone = buildTimerBoxClone(spell, mainTimer);
    CloneUIMap.set(spell.id, mainClone);
    if (cloneContainer) cloneContainer.appendChild(mainClone);

    __DBG("DUAL: Creating COOLDOWN clone for " + cdSpell.id);
    const cdClone = buildTimerBoxClone(cdSpell, cdTimer);
    cdClone.style.display = "none";
    CloneUIMap.set(cdSpell.id, cdClone);
    if (cloneContainer) cloneContainer.appendChild(cdClone);

    __DBG("EXIT: createDualTimerUI(" + spell.id + ")");
    return mainBox;
}


// flash tracker

function flashButton(btn) {
    btn.classList.remove("button-flash");
    void btn.offsetWidth; // forces reflow so animation can restart
    btn.classList.add("button-flash");
}

document.addEventListener("click", (e) => {
    if (e.target.tagName === "BUTTON") {
        flashButton(e.target);
    }
});


// Helper: make a styled button
function makeBtn(label, onClick) {
    const btn = document.createElement("button");
    btn.textContent = label;

    btn.addEventListener("click", (e) => {
        flashButton(btn);   // ‚≠ê global flash
        onClick(e);         // original behavior
    });

    return btn;
}


// Ensure class section exists
function ensureClassSection(classCode) {
    const id = "timer_section_" + classCode;
    let sec = document.getElementById(id);
    if (sec) return sec;

    sec = document.createElement("div");
    sec.id = id;
    sec.className = "section";
    sec.style.marginTop = "10px";

    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = classCode + " Timers";
    sec.appendChild(title);

    SPELL_TIMER_MASTER_CONTAINER.appendChild(sec);
    return sec;
}

// Remove empty class sections
function cleanupEmptyClassSections() {
    if (!SPELL_TIMER_MASTER_CONTAINER) return;

    const children = [...SPELL_TIMER_MASTER_CONTAINER.children];
    children.forEach(sec => {
        if (sec.id && sec.id.startsWith("timer_section_")) {
            // A class section always has:
            //   1 child = the title only
            //   >1 children = title + timers
            if (sec.children.length <= 1) {
                SPELL_TIMER_MASTER_CONTAINER.removeChild(sec);
            }
        }
    });
}
__DBG("Remove empty class sections ()999888666");
// ENGINE EVENT LISTENERS
SpellTimerEngine.on("timerUpdate", payload => {
    const t = payload.timer;

    const bottomBox = TimerUIMap.get(t.spellId);
    const cloneBox  = CloneUIMap.get(t.spellId);

    const boxes = [bottomBox, cloneBox].filter(b => b && b._ui);
    if (boxes.length === 0) return;

    const spell = t.spell;

    let inBreakZone = false;
    if (spell.breakable) {
        if (spell.category?.includes("Charm") && (t.elapsed || 0) >= spell.minDurationSeconds) {
            inBreakZone = true;
        }
        if (spell.category?.includes("Fear") || spell.category?.includes("Root")) {
            inBreakZone = true;
        }
    }

    boxes.forEach(box => {
        const ui = box._ui;

        // Progress bar width
        if (t.baseDuration > 0) {
            const pct = ((t.baseDuration - t.remaining) / t.baseDuration) * 100;
            ui.progFill.style.width = pct + "%";
        } else {
            ui.progFill.style.width = "0%";
        }

        // Progress bar color
        if (!spell.breakable) ui.progFill.style.background = "#3cb371";
        else if (inBreakZone) ui.progFill.style.background = "#cc3333";
        else ui.progFill.style.background = "#e6c300";

        // ‚≠ê Time labels
        if (ui.timeElapsed) {
            ui.timeElapsed.textContent = "Elapsed: " + formatTime(t.elapsed || 0);
        }

        if (ui.timeRemaining) {
            ui.timeRemaining.textContent = "Remaining: " + formatTime(t.remaining || 0);
        }

    });
});   // ‚≠ê THIS WAS MISSING

__DBG("PAST  ENGINE EVENT LISTENERS ()9990011");
// Update history
SpellTimerEngine.on("historyUpdate", payload => {
    const { spellId, entry } = payload;
    const box = TimerUIMap.get(spellId);
    if (!box || !box._ui) return;

    const body = box._ui.histBody;
    const row = document.createElement("tr");

    row.innerHTML = `
        <td>${entry.timestamp.toLocaleTimeString()}</td>
        <td>${entry.result}</td>
        <td>${fmtTime(entry.durationSeconds)}</td>
        <td>${entry.notes}</td>
    `;

    body.appendChild(row);
});


<!-- === SPELL TIMER SYSTEM: BLOCK #7  ‚Äî BOTTOM TIMER PANEL === -->
// Creates the bottom Spell Timer panel and manages dynamic title updates

(function initBottomSpellTimerPanel() {

    // Create the master panel wrapper
    const panel = document.createElement("div");
    panel.id = "spellTimerPanel";
    panel.className = "section";
    panel.style.marginTop = "20px";

    // Title
    const title = document.createElement("div");
    title.id = "spellTimerPanelTitle";
    title.className = "section-title";
    title.textContent = "Spell Timers";
    panel.appendChild(title);

    // Container where class sections + timers will be inserted
    const container = document.createElement("div");
    container.id = "spellTimerPanelContainer";
    panel.appendChild(container);

    // Attach panel to bottom of page
    document.body.appendChild(panel);

    // IMPORTANT: Expose the correct container to the UI builder
    // This ensures all timers are inserted into #spellTimerPanelContainer
    SPELL_TIMER_MASTER_CONTAINER = container;

    // CLASS NAME MAP (for dynamic title updates)
    const CLASS_NAMES = {
        NEC: "Necromancer",
        RNG: "Ranger",
        SHM: "Shaman",
        ENC: "Enchanter",
        MAG: "Magician",
        WIZ: "Wizard",
        CLR: "Cleric",
        DRU: "Druid",
        BRD: "Bard",
        MNK: "Monk",
        ROG: "Rogue",
        PAL: "Paladin",
        SHD: "Shadow Knight",
        WAR: "Warrior"
    };

    // Update title when active classes change
    SpellTimerEngine.on("activeClassesChange", classList => {
        let base = "Spell Timers";

        if (classList.length > 0) {
            const names = classList
                .map(c => CLASS_NAMES[c] || c)
                .join(" + ");
            base += " + " + names;
        }

        title.textContent = base;

        // Also update cloned panel title (Block 8 will create it)
        const cloneTitle = document.getElementById("spellTimerPanelTitle_clone");
        if (cloneTitle) cloneTitle.textContent = base;
    });

})();
__DBG("PAST SPELL TIMER SYSTEM: BLOCK #7  ()1119990011");
<!-- === SPELL TIMER SYSTEM: BLOCK #8 ‚Äî TOP CLONED PANEL SYSTEM === -->

// ===============================
// TOP CLONED PANEL SYSTEM (CHECKBOX VERSION)
// - Creates a mirror of the bottom Spell Timer panel
// - Appears directly under the <h1> header
// - Fully synced with bottom panel
// - User enables it via checkbox toggle
// ===============================
(function initTopClonedPanelSystem() {

    // Locate the <h1> header
    const header = document.querySelector("h1");
    if (!header) {
        console.warn("Top clone panel: <h1> header not found.");
        return;
    }

    // Create the cloned panel container (initially hidden)
    const clonePanel = document.createElement("div");
    clonePanel.id = "spellTimerPanel_clone";
    clonePanel.className = "section";
    clonePanel.style.marginTop = "10px";
    clonePanel.style.display = "none";

    // Title
    const cloneTitle = document.createElement("div");
    cloneTitle.id = "spellTimerPanelTitle_clone";
    cloneTitle.className = "section-title";
    cloneTitle.textContent = "Spell Timers";
    clonePanel.appendChild(cloneTitle);

    // Container for cloned class sections
    const cloneContainer = document.createElement("div");
    cloneContainer.id = "spellTimerPanelContainer_clone";
    clonePanel.appendChild(cloneContainer);

    // Insert cloned panel directly under the header
    header.insertAdjacentElement("afterend", clonePanel);


    // ===============================
    // CHECKBOX TOGGLE IN BOTTOM PANEL
    // ===============================
    const bottomPanel = document.getElementById("spellTimerPanel");
    if (bottomPanel) {

        const wrapper = document.createElement("label");
        wrapper.style.display = "flex";
        wrapper.style.alignItems = "center";
        wrapper.style.cursor = "pointer";
        wrapper.style.marginBottom = "8px";

        const cloneCheckbox = document.createElement("input");
        cloneCheckbox.type = "checkbox";
        cloneCheckbox.style.marginRight = "6px";

        const cloneLabel = document.createElement("span");
        cloneLabel.textContent = "Clone Panel to Top (enables Show Top button)";

        wrapper.appendChild(cloneCheckbox);
        wrapper.appendChild(cloneLabel);

        // Insert at top of bottom panel
        bottomPanel.insertBefore(wrapper, bottomPanel.firstChild);

        // Toggle behavior
        cloneCheckbox.addEventListener("change", () => {
            if (cloneCheckbox.checked) {
                clonePanel.style.display = "block";
            } else {
                clonePanel.style.display = "none";
            }
        });
    }

})();
__DBG("PAST TOP CLONED PANEL SYSTEM   ()111110011");
// ===============================
// INSTRUMENT ALL FUNCTIONS
// ===============================
setTimeout(() => {
    instrumentAllFunctions(window);
    console.log("Function instrumentation complete.");
}, 0);


//
function saveAndUpdateTimer(timerObj, dom) {
    __DBG("ENTER: saveAndUpdateTimer()");

    // ===============================
    // Read DOM inputs safely
    // ===============================
    const newDuration = dom.durationInput
        ? Number(dom.durationInput.value) || timerObj.baseDuration || timerObj.durationSeconds || 0
        : (timerObj.baseDuration || timerObj.durationSeconds || 0);

    const newLabel = dom.labelInput
        ? dom.labelInput.value
        : (timerObj.label || "");

    const newNotes = dom.notesInput
        ? dom.notesInput.value
        : (timerObj.notes || "");

    __DBG("READ: newDuration=" + newDuration + ", newLabel=" + newLabel);

    // ===============================
    // Update timer object
    // ===============================
    timerObj.baseDuration = newDuration;
    timerObj.remaining = newDuration;
    timerObj.label = newLabel;
    timerObj.notes = newNotes;
    timerObj.startTimestamp = Date.now();

    // ===============================
    // Persist override for swoosh
    // ===============================
    const spellId = timerObj.spellId || timerObj.id;

    if (spellId) {
        if (!UserOverrides[spellId]) {
            UserOverrides[spellId] = {};
        }
        UserOverrides[spellId].baseDuration = newDuration;

        __DBG("OVERRIDE STORED: UserOverrides[" + spellId + "].baseDuration=" + newDuration);
    } else {
        __DBG("WARN: saveAndUpdateTimer() ‚Äî no spellId on timerObj, cannot persist override.");
    }

    // ===============================
    // Log + Save
    // ===============================
    logLine(`Timer updated: ${timerObj.label || spellId} ‚Üí ${newDuration} sec`);
    swooshSave();

    __DBG("EXIT: saveAndUpdateTimer()");
}

// ===============================
// LONG TERM TIMERS MODULE (FINAL + LOGGING)
// ===============================
(function LongTermTimersModule() {

    __DBG("ENTER: LongTermTimersModule");

    let LTT = [];
    let lttClockOverride = null;

    const wrap = document.createElement("div");
    wrap.style.marginTop = "40px";
    wrap.style.padding = "10px";
    wrap.style.border = "2px solid #444";
    wrap.style.background = "#222";
    wrap.style.color = "#fff";
    wrap.style.fontFamily = "monospace";

    // ===============================
    // HEADER WITH CLOCK + SET TIME
    // ===============================
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "10px";

    header.innerHTML = `
        <div style="font-size:20px; font-weight:bold;">Long Term Timers</div>
        <div style="text-align:right;">
            <div id="lttClock" style="font-size:16px; color:#0f0;">00:00</div>
            <button id="lttSetTimeBtn" style="margin-top:4px;">Set Time</button>
        </div>
    `;

    wrap.appendChild(header);
    document.body.appendChild(wrap);

    const clockEl = header.querySelector("#lttClock");

    // ===============================
    // CLOCK UPDATE (RESPECT OVERRIDE)
    // ===============================
    function updateLTTClock() {
        //__DBG("ENTER: updateLTTClock"); // weird bug messes up duration change saves with save & update

        try {
            if (lttClockOverride) {
                clockEl.textContent = `${lttClockOverride.hh}:${lttClockOverride.mm}`;
                return;
            }

            const now = new Date();
            const hh = now.getHours().toString().padStart(2, "0");
            const mm = now.getMinutes().toString().padStart(2, "0");
            clockEl.textContent = `${hh}:${mm}`;
            clockEl.style.opacity = "1";

        } catch (e) {
            clockEl.textContent = "00:00";
            clockEl.style.opacity = clockEl.style.opacity === "1" ? "0.3" : "1";
        }
    }

    setInterval(updateLTTClock, 1000);
    updateLTTClock();

    // ===============================
    // MANUAL CLOCK OVERRIDE
    // ===============================
    header.querySelector("#lttSetTimeBtn").onclick = () => {
        __DBG("ENTER: lttSetTimeBtn.onclick");

        const current = clockEl.textContent;
        const newTime = prompt("Set time (HH:MM):", current);
        if (!newTime) return;

        const parts = newTime.split(":");
        if (parts.length !== 2) return;

        const hh = parseInt(parts[0]);
        const mm = parseInt(parts[1]);

        if (isNaN(hh) || isNaN(mm) || hh < 0 || hh > 23 || mm < 0 || mm > 59) return;

        const now = new Date();
        const sysHH = now.getHours();
        const sysMM = now.getMinutes();
        const diffMin = (hh - sysHH) * 60 + (mm - sysMM);

        logLine(`LTT Clock override: system=${sysHH}:${sysMM} user=${hh}:${mm} (offset ${diffMin} min)`);

        lttClockOverride = {
            hh: hh.toString().padStart(2, "0"),
            mm: mm.toString().padStart(2, "0")
        };

        clockEl.textContent = `${lttClockOverride.hh}:${lttClockOverride.mm}`;
        clockEl.style.color = "#ff0";
        setTimeout(() => clockEl.style.color = "#0f0", 1500);
    };

    // ===============================
    // ADD FORM
    // ===============================
    const form = document.createElement("div");
    form.innerHTML = `
        <input id="lttName" placeholder="Timer Name" style="width:200px;">
        <input id="lttDays" type="number" min="0" placeholder="Days" style="width:60px;">
        <input id="lttHours" type="number" min="0" max="23" placeholder="Hours" style="width:60px;">
        <input id="lttMin" type="number" min="0" max="59" placeholder="Min" style="width:60px;">
        <input id="lttSec" type="number" min="0" max="59" placeholder="Sec" style="width:60px;">
        <button id="lttAdd">Add</button>
    `;
    wrap.appendChild(form);

    const list = document.createElement("div");
    wrap.appendChild(list);

    // ===============================
    // ADD TIMER
    // ===============================
    document.getElementById("lttAdd").onclick = () => {
        __DBG("ENTER: lttAdd.onclick");

        const name = document.getElementById("lttName").value.trim();
        const d = parseInt(document.getElementById("lttDays").value) || 0;
        const h = parseInt(document.getElementById("lttHours").value) || 0;
        const m = parseInt(document.getElementById("lttMin").value) || 0;
        const s = parseInt(document.getElementById("lttSec").value) || 0;

        if (!name) return;

        const totalMs = (d*86400 + h*3600 + m*60 + s) * 1000;
        if (totalMs <= 0) return;

        const obj = {
            id: "LTT_" + Math.random().toString(36).slice(2),
            name,
            target: Date.now() + totalMs,
            note: "",
            history: []
        };

        LTT.push(obj);

        logLine(`LTT Created: ${name} (${d}d ${h}h ${m}m ${s}s)`);

        render();
    };

    // ===============================
    // RENDER (STATIC PARTS ONLY)
    // ===============================
    function render() {
        __DBG("ENTER: render");

        list.innerHTML = "";

        LTT.forEach(t => {
            const div = document.createElement("div");
            div.style.margin = "10px 0";
            div.style.padding = "10px";
            div.style.border = "1px solid #555";

            div.innerHTML = `
                <b>${t.name}</b>
                <button class="edit" style="float:right;">Edit</button>
                <br><br>

                Remaining: <span id="ltt_rem_${t.id}"></span><br>
                Ends On: <span id="ltt_end_${t.id}" style="color:#0af"></span>
                <br><br>

                <textarea class="note" style="width:100%;height:40px;">${t.note}</textarea><br>
                <button class="saveNote">Save Note</button>

                <br><br>
                <button class="toggleHist">Show History</button>
                <div class="hist" style="display:none; margin-top:10px; border-top:1px solid #555; padding-top:10px;">
                    ${t.history.length === 0 ? "<i>No edits yet</i>" : ""}
                </div>

                <br><br>
                <label><input type="checkbox" class="chk1"> Confirm</label>
                <label><input type="checkbox" class="chk2"> Really?</label>
                <button class="delete" style="margin-left:10px;">Delete</button>
            `;

            // ===============================
            // SAVE NOTE
            // ===============================
            div.querySelector(".saveNote").onclick = () => {
                __DBG("ENTER: saveNote.onclick");

                t.note = div.querySelector(".note").value;
logLine(`LTT Note Updated: ${t.name} ‚Üí "${t.note}"`);

            };

            // ===============================
            // TOGGLE HISTORY
            // ===============================
            div.querySelector(".toggleHist").onclick = () => {
                __DBG("ENTER: toggleHist.onclick");

                const h = div.querySelector(".hist");
                h.style.display = h.style.display === "none" ? "block" : "none";
            };

            // ===============================
            // EDIT TIMER
            // ===============================
            div.querySelector(".edit").onclick = () => {
                __DBG("ENTER: edit.onclick");

                const newD = prompt("Days:");
                const newH = prompt("Hours:");
                const newM = prompt("Minutes:");
                const newS = prompt("Seconds:");

                const totalMs = ((+newD||0)*86400 + (+newH||0)*3600 + (+newM||0)*60 + (+newS||0)) * 1000;
                if (totalMs <= 0) return;

                const oldTarget = t.target;
                t.target = Date.now() + totalMs;

                logLine(`LTT Edited: ${t.name} ‚Üí ${newD}d ${newH}h ${newM}m ${newS}s`);

                // Force immediate Ends On update
                const endEl = document.getElementById("ltt_end_" + t.id);
                if (endEl) {
                    let now = new Date();
                    if (lttClockOverride) {
                        now = new Date(
                            now.getFullYear(),
                            now.getMonth(),
                            now.getDate(),
                            parseInt(lttClockOverride.hh),
                            parseInt(lttClockOverride.mm),
                            0
                        );
                    }

                    const endDate = new Date(now.getTime() + totalMs);

                    const options = {
                        year: "numeric",
                        month: "short",
                        day: "numeric",
                        hour: "2-digit",
                        minute: "2-digit",
                        hour12: true
                    };

                    endEl.textContent = endDate.toLocaleString(undefined, options);
                }

                t.history.push({
                    when: new Date().toLocaleString(),
                    oldRemaining: oldTarget - Date.now(),
                    newRemaining: totalMs
                });

                render();
            };

            // ===============================
            // DELETE TIMER
            // ===============================
            div.querySelector(".delete").onclick = () => {
                __DBG("ENTER: delete.onclick");

                const c1 = div.querySelector(".chk1").checked;
                const c2 = div.querySelector(".chk2").checked;
                if (!c1 || !c2) return;

                logLine(`LTT Deleted: ${t.name}`);

                LTT = LTT.filter(x => x.id !== t.id);
                render();
            };

            // ===============================
            // HISTORY RENDER
            // ===============================
            const histDiv = div.querySelector(".hist");
            t.history.forEach(h => {
                const row = document.createElement("div");
                row.style.marginBottom = "6px";
                row.innerHTML = `
                    <b>${h.when}</b><br>
                    Old: ${(h.oldRemaining/1000).toFixed(0)} sec<br>
                    New: ${(h.newRemaining/1000).toFixed(0)} sec<br>
                `;
                histDiv.appendChild(row);
            });

            list.appendChild(div);
        });
    }

// ===============================
// PARTIAL UPDATE LOOP (ONLY REMAINING TIME)
// ===============================
setInterval(() => {
    LTT.forEach(t => {
        const el = document.getElementById("ltt_rem_" + t.id);
        if (!el) return;

        const remaining = t.target - Date.now();
        const ready = remaining <= 0;

        const days = Math.max(0, Math.floor(remaining / 86400000));
        const hours = Math.max(0, Math.floor((remaining % 86400000) / 3600000));
        const mins = Math.max(0, Math.floor((remaining % 3600000) / 60000));
        const secs = Math.max(0, Math.floor((remaining % 60000) / 1000));

        el.innerHTML = ready
            ? `<span style="color:#ff0">READY</span>`
            : `<span style="color:#0f0">${days}d ${hours}h ${mins}m ${secs}s</span>`;

        const endEl = document.getElementById("ltt_end_" + t.id);
        if (endEl) {
            let now = new Date();
            if (lttClockOverride) {
                now = new Date(
                    now.getFullYear(),
                    now.getMonth(),
                    now.getDate(),
                    parseInt(lttClockOverride.hh),
                    parseInt(lttClockOverride.mm),
                    0
                );
            }

            const endDate = new Date(now.getTime() + remaining);

            const options = {
                year: "numeric",
                month: "short",
                day: "numeric",
                hour: "2-digit",
                minute: "2-digit",
                hour12: true
            };

            endEl.textContent = endDate.toLocaleString(undefined, options);
        }
    });
}, 1000);

// ===============================
// API EXPORT
// ===============================
window.LongTermTimersAPI = {
    getAll: () => LTT,
    loadAll: arr => { LTT = arr || []; render(); }
};

})();
// ===============================
// TIME CONVERTER (UPGRADED)
// ===============================
(function TimeConverterModule() {

    const wrap = document.createElement("div");
    wrap.style.marginTop = "40px";
    wrap.style.padding = "10px";
    wrap.style.border = "2px solid #444";
    wrap.style.background = "#111";
    wrap.style.color = "#fff";
    wrap.style.fontFamily = "monospace";
    wrap.innerHTML = "<h2>Time Converter <span style='color:#0f0'>(BETA)</span></h2>";
    document.body.appendChild(wrap);

    const addBtn = document.createElement("button");
    addBtn.textContent = "Add Converter";
    addBtn.style.marginBottom = "10px";
    wrap.appendChild(addBtn);

    const list = document.createElement("div");
    wrap.appendChild(list);

    let converters = [];

    addBtn.onclick = () => {
        const id = "TC_" + Math.random().toString(36).slice(2);
        converters.push({ id });
        render();
    };

    function render() {
        list.innerHTML = "";

        converters.forEach(conv => {
            const box = document.createElement("div");
            box.style.margin = "10px 0";
            box.style.padding = "10px";
            box.style.border = "1px solid #555";
            box.style.background = "#222";

            box.innerHTML = `
                <b>Converter</b>
                <button class="delete" style="float:right;">Delete</button>
                <br><br>

                <input class="tick" type="number" placeholder="Ticks (6 sec each)" style="width:160px;"> ‚Üí
                <span class="outTick"></span><br>

                <input class="sec" type="number" placeholder="Seconds" style="width:120px;"> ‚Üí
                <span class="out1"></span><br>

                <input class="min" type="number" placeholder="Minutes" style="width:120px;"> ‚Üí
                <span class="out2"></span><br>

                <input class="hr" type="number" placeholder="Hours" style="width:120px;"> ‚Üí
                <span class="out3"></span><br>

                <input class="day" type="number" placeholder="Days" style="width:120px;"> ‚Üí
                <span class="out4"></span><br>
            `;

            // Delete converter
            box.querySelector(".delete").onclick = () => {
                converters = converters.filter(x => x.id !== conv.id);
                render();
            };

            // Inputs
            const tick = box.querySelector(".tick");
            const sec  = box.querySelector(".sec");
            const min  = box.querySelector(".min");
            const hr   = box.querySelector(".hr");
            const day  = box.querySelector(".day");

            // Outputs
            const outTick = box.querySelector(".outTick");
            const out1 = box.querySelector(".out1");
            const out2 = box.querySelector(".out2");
            const out3 = box.querySelector(".out3");
            const out4 = box.querySelector(".out4");

            // ===============================
            // TOTAL OUTPUT COLUMN
            // ===============================
            const totalOut = document.createElement("div");
            totalOut.style.marginTop = "6px";
            totalOut.style.color = "#0f0";
            totalOut.style.fontWeight = "bold";
            box.appendChild(totalOut);

            function updateTotal() {
                const s = parseFloat(sec.value) || 0;
                const m = (parseFloat(min.value) || 0) * 60;
                const h = (parseFloat(hr.value)  || 0) * 3600;
                const d = (parseFloat(day.value) || 0) * 86400;
                const t = (parseFloat(tick.value) || 0) * 6;

                const total = s + m + h + d + t;
                const totalTicks = total / 6;

                const hh = Math.floor(total / 3600);
                const mm = Math.floor((total % 3600) / 60);
                const ss = Math.floor(total % 60);

                const hhmmss =
                    hh > 0
                        ? `${hh.toString().padStart(2,"0")}:${mm.toString().padStart(2,"0")}:${ss.toString().padStart(2,"0")}`
                        : `${mm.toString().padStart(2,"0")}:${ss.toString().padStart(2,"0")}`;

                totalOut.textContent =
                    `Total: ${hhmmss} (${total} sec) | ${totalTicks.toFixed(2)} ticks`;
            }

            // ===============================
            // TICKS INPUT
            // ===============================
            tick.oninput = () => {
                const t = parseFloat(tick.value) || 0;
                const seconds = t * 6;

                outTick.textContent =
                    `${seconds} sec | ${(seconds/60).toFixed(2)} min | ${(seconds/3600).toFixed(2)} hr | ${(seconds/86400).toFixed(2)} days`;

                updateTotal();
            };

            // ===============================
            // SECONDS
            // ===============================
            sec.oninput = () => {
                const s = parseFloat(sec.value) || 0;

                out1.textContent =
                    `${(s/60).toFixed(2)} min | ${(s/3600).toFixed(2)} hr | ${(s/86400).toFixed(2)} days | ${(s/6).toFixed(2)} ticks`;

                updateTotal();
            };

            // ===============================
            // MINUTES
            // ===============================
            min.oninput = () => {
                const m = parseFloat(min.value) || 0;
                const secVal = m * 60;

                out2.textContent =
                    `${secVal} sec | ${(m/60).toFixed(2)} hr | ${(m/1440).toFixed(2)} days | ${(m*10).toFixed(2)} ticks`;

                updateTotal();
            };

            // ===============================
            // HOURS
            // ===============================
            hr.oninput = () => {
                const h = parseFloat(hr.value) || 0;

                out3.textContent =
                    `${h*3600} sec | ${h*60} min | ${(h/24).toFixed(2)} days | ${(h*600).toFixed(2)} ticks`;

                updateTotal();
            };

            // ===============================
            // DAYS
            // ===============================
            day.oninput = () => {
                const d = parseFloat(day.value) || 0;

                out4.textContent =
                    `${d*86400} sec | ${d*1440} min | ${d*24} hr | ${(d*14400).toFixed(2)} ticks`;

                updateTotal();
            };

            // Initialize
            updateTotal();
            list.appendChild(box);
        });
    }

})();

// ======================================================
// ITEM SYSTEM ‚Äî UUID SAFE, SAVE/LOAD SAFE, RESTORE SAFE
// ======================================================

// GLOBAL REGISTRY
window.ItemRegistry = [];

// ------------------------------
// VALIDATION
// ------------------------------
function validateItemLink(url) {
    const BASE = "https://wiki.project1999.com/";
    if (!url.startsWith(BASE)) return false;

    const tail = url.slice(BASE.length);
    if (!tail) return false;
    if (tail.includes("/")) return false;
    if (tail.includes(".")) return false;
    if (tail.trim() !== tail) return false;

    return true;
}

function validateImageUrl(url) {
    const BASE = "https://wiki.project1999.com/images/";
    return url.startsWith(BASE);
}

// ------------------------------
// TOKEN ENGINE
// ------------------------------
let tokenCounter = 1000;
function makeTokenId() { return tokenCounter++; }

function wrapToken(word) {
    const id = makeTokenId();
    return `{{${id}[[~~ ${word} ~~]]${id}}}`;
}
// ======================================================
// SEAL BUTTON HANDLER ‚Äî NOW WITH UUID
// ======================================================
document.getElementById("itemSealBtn").onclick = () => {

    const title = document.getElementById("itemTitleInput").value.trim();
    const rawUrl = document.getElementById("itemUrlInput").value;
    const rawImg = document.getElementById("itemImgInput").value;

    const cleanUrl = sanitizeUrl(rawUrl, "https://wiki.project1999.com/");
    const cleanImg = sanitizeUrl(rawImg, "https://wiki.project1999.com/images/");

    // If user chose NOT to continue, abort seal creation
    if (cleanUrl === "__ABORT__" || cleanImg === "__ABORT__") {
        alert("Please correct the URL and try again.");
        return;
    }

    const effectEnabled = document.getElementById("itemEffectToggle").checked;
    const effectSeconds = parseInt(document.getElementById("itemEffectInput").value, 10) || 0;
    const note = document.getElementById("itemNoteInput").value.trim();

    if (!title) { alert("Enter item title."); return; }
    if (!note) { alert("Paste item text first."); return; }

    // Lock textarea
    const ta = document.getElementById("itemNoteInput");
    ta.readOnly = true;
    ta.style.opacity = "0.5";

    // Tokenize + log
    const rawTokens = note.split(/\s+/);
    const wrappedTokens = rawTokens.map(wrapToken);

    logRaw("=== ITEM_SEAL_START ===");
    logRaw(`title: ${title}`);
    logRaw(`link: ${cleanUrl || "none"}`);
    logRaw(`image: ${cleanImg || "none"}`);
    logRaw(`effect_enabled: ${effectEnabled}`);
    logRaw(`effect_seconds: ${effectSeconds}`);
    logRaw("tokens:");
    wrappedTokens.forEach(t => logRaw(t));
    logRaw("=== ITEM_SEAL_END ===");

    logLine(`[ITEM] Seal complete for: ${title}`);
    logLine(`[ITEM] Item saved. Ready for swoosh.`);

    // ------------------------------
    // CREATE ITEM OBJECT WITH UUID
    // ------------------------------
    const newItem = {
        id: crypto.randomUUID(),
        title,
        url: cleanUrl,
        imgUrl: cleanImg,
        effectEnabled,
        effectSeconds,
        note,
        timer: {
            running: false,
            remaining: effectSeconds,
            savedAt: Date.now(),
            completed: false
        }
    };

    window.ItemRegistry.push(newItem);
    __DBG("ITEM: Added to ItemRegistry. Count = " + window.ItemRegistry.length);

    createItemPanel(newItem);

    // Switch clear button to reuse mode
    const clearBtn = document.getElementById("itemClearBtn");
    clearBtn.textContent = "Use Again";
    clearBtn.dataset.mode = "reuse";
// Disable Create Seal until Use Again is clicked
const sealBtn = document.getElementById("itemSealBtn");
sealBtn.disabled = true;
sealBtn.style.opacity = "0.4";
sealBtn.style.cursor = "not-allowed";
    document.getElementById("itemSealArea").style.display = "none";
};

function createItemPanel(item) {
    __DBG("UI: createItemPanel ENTER id=" + item.id + " title=" + item.title);

    const container = document.createElement("div");
    container.className = "section";
    container.style.border = "2px solid #555";
    container.style.marginTop = "10px";

    // Title
    const header = document.createElement("div");
    header.style.fontWeight = "bold";
    header.style.fontSize = "14px";
    header.style.marginBottom = "5px";
    header.textContent = item.title;
    container.appendChild(header);

    // Image
    if (item.imgUrl) {
        const img = document.createElement("img");
        img.src = item.imgUrl;
        img.style.maxWidth = "120px";
        img.style.display = "block";
        img.style.marginBottom = "10px";
        container.appendChild(img);
    }

    // Timer section
    if (item.effectEnabled) {
        const timerDiv = document.createElement("div");
        timerDiv.style.marginTop = "10px";

        timerDiv.innerHTML = `
            <div>Effect Timer:
                <span class="item-timer-display" id="itemTimer_${item.id}">
                    ${item.effectSeconds}s
                </span>
            </div>
            <button data-id="${item.id}" class="itemTimerStart">Start</button>
            <button data-id="${item.id}" class="itemTimerPause">Pause</button>
            <button data-id="${item.id}" class="itemTimerReset">Reset</button>
<button data-id="${item.id}" class="itemTimerRestart">Restart</button>
        `;

        container.appendChild(timerDiv);

        // Duration editor
        const editWrap = document.createElement("div");
        editWrap.style.marginTop = "5px";

        editWrap.innerHTML = `
            <label>
                <input type="checkbox" class="itemEditToggle" data-id="${item.id}">
                Change Duration
            </label>
            <input type="number" id="itemEditInput_${item.id}" style="width:80px;" disabled>
            <button class="itemEditSave" data-id="${item.id}" disabled>Save</button>
        `;

        container.appendChild(editWrap);

        // ===============================
        // Save + Show at Top + Delete Controls
        // ===============================
        const controlRow = document.createElement("div");
        controlRow.style.marginTop = "8px";

        // Save button
        const saveBtn = document.createElement("button");
        saveBtn.textContent = "Save";
        saveBtn.className = "itemSaveBtn";
        saveBtn.dataset.id = item.id;
        saveBtn.style.marginRight = "10px";
        controlRow.appendChild(saveBtn);

        // Show at top checkbox
        const showTopLabel = document.createElement("label");
        showTopLabel.style.marginRight = "10px";
        showTopLabel.innerHTML = `<input type="checkbox" class="itemShowTop" data-id="${item.id}"> Show at top`;
        controlRow.appendChild(showTopLabel);

        // Delete checkbox
        const delLabel = document.createElement("label");
        delLabel.style.marginRight = "10px";
delLabel.innerHTML = `<input type="checkbox" class="itemSealDeleteToggle" data-id="${item.id}"> Delete?`;
        controlRow.appendChild(delLabel);

        // Delete button
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
delBtn.className = "itemSealDeleteBtn";
        delBtn.dataset.id = item.id;
        delBtn.disabled = true;
        delBtn.style.opacity = "0.4";
        controlRow.appendChild(delBtn);

        container.appendChild(controlRow);
    }

    // Info toggle
    const infoBtn = document.createElement("button");
    infoBtn.textContent = "Show Item Info";
    infoBtn.dataset.id = item.id;
    infoBtn.className = "itemInfoToggle";
    container.appendChild(infoBtn);

    // Info area
    const infoArea = document.createElement("div");
    infoArea.id = `itemInfo_${item.id}`;
    infoArea.style.display = "none";
    infoArea.style.marginTop = "10px";
    infoArea.style.fontFamily = "monospace";
    infoArea.style.whiteSpace = "pre-line";
    infoArea.style.fontSize = "12px";
    infoArea.style.borderTop = "1px solid #444";
    infoArea.style.paddingTop = "5px";

    infoArea.textContent =
        "Item Link: " + item.url + "\n\n" +
        "Item Notes:\n" + (item.note || "(none)");

    container.appendChild(infoArea);

    document.body.appendChild(container);

    __DBG("UI: createItemPanel EXIT id=" + item.id + " title=" + item.title);
    return container;
}

// ======================================================
// TIMER LOGIC ‚Äî UPDATED TO USE UUID // global click handler
// ======================================================

document.addEventListener("click", e => {
    const id = e.target.dataset.id;

    // ===============================
    // INFO TOGGLE
    // ===============================
    if (e.target.classList.contains("itemInfoToggle")) {
        const area = document.getElementById(`itemInfo_${id}`);
        if (area.style.display === "none") {
            area.style.display = "block";
            e.target.textContent = "Hide Item Info";
        } else {
            area.style.display = "none";
            e.target.textContent = "Show Item Info";
        }
        return;
    }

    // ===============================
    // START
    // ===============================
    if (e.target.classList.contains("itemTimerStart")) {
        startItemTimer(id);
        return;
    }

    // ===============================
    // PAUSE
    // ===============================
    if (e.target.classList.contains("itemTimerPause")) {
        pauseItemTimer(id);
        return;
    }

// ===============================
// RESTART
// ===============================
if (e.target.classList.contains("itemTimerRestart")) {
    restartItemTimer(id);
    return;
}



    // ===============================
    // EDIT TOGGLE
    // ===============================
    if (e.target.classList.contains("itemEditToggle")) {
        const input = document.getElementById(`itemEditInput_${id}`);
        const saveBtn = document.querySelector(`.itemEditSave[data-id="${id}"]`);

        const enabled = e.target.checked;
        input.disabled = !enabled;
        saveBtn.disabled = !enabled;
        return;
    }

    // ===============================
    // EDIT SAVE
    // ===============================
    if (e.target.classList.contains("itemEditSave")) {
        const input = document.getElementById(`itemEditInput_${id}`);
        const newVal = parseInt(input.value, 10);
        const display = document.getElementById(`itemTimer_${id}`);
        const item = ItemRegistry.find(x => x.id === id);

        if (!isNaN(newVal) && item) {
            item.effectSeconds = newVal;
            item.timer.remaining = newVal;
            display.textContent = newVal + "s";
            logLine(`[ITEM] Updated duration for ${item.title} ‚Üí ${newVal}s`);
        }
        return;
    }

    // ===============================
    // SAVE BUTTON
    // ===============================
    if (e.target.classList.contains("itemSaveBtn")) {
        const item = ItemRegistry.find(x => x.id === id);
        if (item) logLine(`[ITEM] Saved item: ${item.title}`);
        return;
    }
// ===============================
// ITEM SEAL DELETE TOGGLE
// ===============================
if (e.target.classList.contains("itemSealDeleteToggle")) {
    const delBtn = document.querySelector(`.itemSealDeleteBtn[data-id="${id}"]`);
    const enabled = e.target.checked;
    delBtn.disabled = !enabled;
    delBtn.style.opacity = enabled ? "1" : "0.4";
    return;
}

// ===============================
// ITEM SEAL DELETE BUTTON
// ===============================
if (e.target.classList.contains("itemSealDeleteBtn")) {
    // Remove from registry
    ItemRegistry = ItemRegistry.filter(x => x.id !== id);

    // Remove main panel
    const panel = e.target.closest(".section");
    if (panel) panel.remove();

    // Remove top clone if it exists
    const clone = document.getElementById(`itemClone_${id}`);
    if (clone) clone.remove();

    logLine(`[ITEM] Deleted item id=${id}`);
    return;
}
    // ===============================
    // SHOW AT TOP
    // ===============================
    if (e.target.classList.contains("itemShowTop")) {
        const item = ItemRegistry.find(x => x.id === id);

        if (e.target.checked) {
            const clone = buildItemCloneBox(item);
            document.getElementById("topTimersArea").appendChild(clone);
        } else {
            const clone = document.getElementById(`itemClone_${id}`);
            if (clone) clone.remove();
        }
        return;
    }
// ===============================
// CLONE START
// ===============================
if (e.target.classList.contains("itemCloneStart")) {
    const id = e.target.dataset.id;
    startItemTimer(id);
    return;
}

// ===============================
// CLONE PAUSE
// ===============================
if (e.target.classList.contains("itemClonePause")) {
    const id = e.target.dataset.id;
    pauseItemTimer(id);
    return;
}

// CLONE RESTART
if (e.target.classList.contains("itemCloneRestart")) {
    restartItemTimer(id);
    return;
}

});

// ======================================================
// RESTORE LOGIC ‚Äî UUID SAFE
// ======================================================
function restoreItemTimer(panel, item) {
    __DBG("RESTORE_TIMER: ENTER id=" + item.id + " title=" + item.title);

    const timerDisplay = panel.querySelector(`#itemTimer_${item.id}`);
    if (!timerDisplay) {
        __DBG("RESTORE_TIMER: No timerDisplay for id=" + item.id);
        return;
    }

    if (!item.timer) {
        __DBG("RESTORE_TIMER: No timer object for id=" + item.id);
        return;
    }

    if (item.timer.completed) {
        timerDisplay.textContent = "DONE";
        timerDisplay.classList.add("flash");
        __DBG("RESTORE_TIMER: Marked DONE id=" + item.id);
        return;
    }

    if (item.timer.running) {
        const now = Date.now();
        const elapsed = now - item.timer.savedAt;
        const remaining = Math.max(0, item.timer.remaining - elapsed);
        timerDisplay.textContent = remaining + "s";
        __DBG("RESTORE_TIMER: Running restore id=" + item.id + " remaining=" + remaining);
    } else {
        timerDisplay.textContent = (item.timer.remaining || item.effectSeconds) + "s";
        __DBG("RESTORE_TIMER: Static restore id=" + item.id + " remaining=" + (item.timer.remaining || item.effectSeconds));
    }

    __DBG("RESTORE_TIMER: EXIT id=" + item.id);
}
function restoreAllItemsFromRegistry() {
    __DBG("RESTORE: Starting item restore from ItemRegistry");
    __DBG("RESTORE: ItemRegistry length = " + (window.ItemRegistry ? window.ItemRegistry.length : "NULL"));

    if (!window.ItemRegistry || window.ItemRegistry.length === 0) {
        __DBG("RESTORE: No items to restore.");
        return;
    }

    window.ItemRegistry.forEach((item, index) => {
        __DBG("RESTORE: [" + index + "] id=" + item.id + " title=" + item.title + " type=" + item.type);

        // Normal item panel
        if (!item.type || item.type === "item") {
            const panel = createItemPanel(item);
            __DBG("RESTORE: Item panel created for id=" + item.id);

            restoreItemTimer(panel, item);
            __DBG("RESTORE: Item timer restored for id=" + item.id);
            return;
        }

        // CH Chain panel
        if (item.type === "chchain") {
            createChChainPanel(item);
            __DBG("RESTORE: CH Chain panel created for id=" + item.id);
            return;
        }

        // Unknown future types
        __DBG("RESTORE: Unknown item type '" + item.type + "' ‚Äî skipping.");
    });

    const sections = document.querySelectorAll(".section");
    __DBG("RESTORE: Total .section panels in DOM after restore = " + sections.length);

    __DBG("RESTORE: Item restore complete.");
}

function rebuildCycleRotation() {
    chain._cycleRotation = getActiveRotation().slice();
    chain.lastCycleStart = Date.now();
    chain._lastCasterIndex = -1;
}

function buildItemCloneBox(item) {
    const box = document.createElement("div");
    box.className = "section";
    box.id = `itemClone_${item.id}`;
    box.style.border = "2px solid #777";
    box.style.marginTop = "6px";
    box.style.background = "#222";
    box.style.padding = "6px";

    // Title
    const title = document.createElement("div");
    title.style.fontWeight = "bold";
    title.style.marginBottom = "4px";
    title.textContent = item.title;
    box.appendChild(title);

    // ===============================
    // OPTIONAL IMAGE (if not default)
    // ===============================
    if (item.imgUrl && item.imgUrl !== "https://wiki.project1999.com/images/") {
        const img = document.createElement("img");
        img.src = item.imgUrl;
        img.style.maxWidth = "80px";
        img.style.display = "block";
        img.style.marginBottom = "6px";
        img.style.border = "1px solid #444";
        img.style.borderRadius = "4px";
        box.appendChild(img);
    }

    // Timer display
    const timerDisplay = document.createElement("span");
    timerDisplay.id = `itemCloneTimer_${item.id}`;
    timerDisplay.textContent = `${item.effectSeconds}s`;

    const timerRow = document.createElement("div");
    timerRow.textContent = "Effect Timer: ";
    timerRow.appendChild(timerDisplay);
    box.appendChild(timerRow);

    // Buttons
    const btnRow = document.createElement("div");
    btnRow.style.marginTop = "6px";

    const startBtn = document.createElement("button");
    startBtn.textContent = "Start";
    startBtn.dataset.id = item.id;
    startBtn.className = "itemCloneStart";
    btnRow.appendChild(startBtn);

    const pauseBtn = document.createElement("button");
    pauseBtn.textContent = "Pause";
    pauseBtn.dataset.id = item.id;
    pauseBtn.className = "itemClonePause";
    btnRow.appendChild(pauseBtn);

    const restartBtn = document.createElement("button");
    restartBtn.textContent = "Restart";
    restartBtn.dataset.id = item.id;
    restartBtn.className = "itemCloneRestart";
    btnRow.appendChild(restartBtn);

    box.appendChild(btnRow);

    return box;
}


let itemTimers = {};

function startItemTimer(id) {
    const item = ItemRegistry.find(x => x.id === id);
    const display = document.getElementById(`itemTimer_${id}`);
    const cloneDisplay = document.getElementById(`itemCloneTimer_${id}`);
    if (!item || !display) return;

    // Ensure timer object exists
    if (!itemTimers[id]) {
        itemTimers[id] = {
            remaining: item.effectSeconds,
            running: false
        };
    }

    const t = itemTimers[id];

    // If already running, do nothing
    if (t.running) return;

    t.running = true;
    t.start = performance.now();

    // Clear any old interval
    if (t.interval) clearInterval(t.interval);

    t.interval = setInterval(() => {
        const now = performance.now();
        const elapsed = Math.floor((now - t.start) / 1000);
        const left = t.remaining - elapsed;

        const text = left > 0 ? left + "s" : "0s";

        display.textContent = text;
        if (cloneDisplay) cloneDisplay.textContent = text;

        if (left <= 0) {
            clearInterval(t.interval);
            t.running = false;
            t.remaining = 0;
        }
    }, 250);
}

function pauseItemTimer(id) {
    const t = itemTimers[id];
    if (!t || !t.running) return;

    t.running = false;
    clearInterval(t.interval);

    const now = performance.now();
    const elapsed = Math.floor((now - t.start) / 1000);
    t.remaining -= elapsed;
}

function resetItemTimer(id) {
    const item = ItemRegistry.find(x => x.id === id);
    const display = document.getElementById(`itemTimer_${id}`);
    const cloneDisplay = document.getElementById(`itemCloneTimer_${id}`);
    if (!item || !display) return;

    // Stop everything
    if (itemTimers[id]?.interval) clearInterval(itemTimers[id].interval);

    // Reset but do NOT start
    itemTimers[id] = {
        running: false,
        remaining: item.effectSeconds
    };

    display.textContent = item.effectSeconds + "s";
    if (cloneDisplay) cloneDisplay.textContent = item.effectSeconds + "s";
}

function restartItemTimer(id) {
    const item = ItemRegistry.find(x => x.id === id);
    if (!item) return;

    // Hard reset
    if (itemTimers[id]?.interval) clearInterval(itemTimers[id].interval);

    itemTimers[id] = {
        running: false,
        remaining: item.effectSeconds
    };

    // Immediately start
    startItemTimer(id);
}
// ------------------------------
// CLEAR / USE AGAIN BUTTON
// ------------------------------
document.getElementById("itemClearBtn").onclick = () => {
    const btn = document.getElementById("itemClearBtn");

    // Reuse mode ‚Üí reset builder
    if (btn.dataset.mode === "reuse") {
        document.getElementById("itemNoteInput").readOnly = false;
        document.getElementById("itemNoteInput").style.opacity = "1";

        document.getElementById("itemTitleInput").value = "";
        document.getElementById("itemEffectInput").value = "";
        document.getElementById("itemUrlInput").value = "https://wiki.project1999.com/";
        document.getElementById("itemImgInput").value = "https://wiki.project1999.com/images/";
        document.getElementById("itemNoteInput").value = "";

        // Switch back to normal clear mode
        btn.textContent = "Clear";
        btn.dataset.mode = "clear";

        // ‚≠ê Re-enable Create Seal
        const sealBtn = document.getElementById("itemSealBtn");
        sealBtn.disabled = false;
        sealBtn.style.opacity = "1";
        sealBtn.style.cursor = "pointer";

        return;
    }

    // Normal clear mode
    document.getElementById("itemTitleInput").value = "";
    document.getElementById("itemEffectInput").value = "";
    document.getElementById("itemUrlInput").value = "https://wiki.project1999.com/";
    document.getElementById("itemImgInput").value = "https://wiki.project1999.com/images/";
    document.getElementById("itemNoteInput").value = "";
};

function sanitizeUrl(input, base) {
    const trimmed = (input || "").trim();

    // Blank or base path ‚Üí treat as blank
    if (trimmed === "" || trimmed === base) {
        return "";
    }

    // Valid: must start with base AND have something after it
    if (trimmed.startsWith(base) && trimmed.length > base.length) {
        return trimmed;
    }

    // Invalid ‚Üí ask user if they want to blank it out
    const proceed = confirm(
        "Invalid item link.\n\n" +
        "Would you like to continue and remove it (set to blank)?"
    );

    if (proceed) {
        return ""; // blank it out
    }

    // User wants to fix manually ‚Üí special abort token
    return "__ABORT__";
}



// ============================================================
// END ITEM BUILDER SYSTEM
// ============================================================


// ============================================================
// CH CHAIN TIMER PANEL SYSTEM
// ============================================================
document.getElementById("itemClearBtn").onclick = () => {
    const btn = document.getElementById("itemClearBtn");

    // Reuse mode ‚Üí reset builder
    if (btn.dataset.mode === "reuse") {
        document.getElementById("itemNoteInput").readOnly = false;
        document.getElementById("itemNoteInput").style.opacity = "1";

        document.getElementById("itemTitleInput").value = "";
        document.getElementById("itemEffectInput").value = "";
        document.getElementById("itemUrlInput").value = "https://wiki.project1999.com/";
        document.getElementById("itemImgInput").value = "https://wiki.project1999.com/images/";
        document.getElementById("itemNoteInput").value = "";

        // Switch back to normal clear mode
        btn.textContent = "Clear";
        btn.dataset.mode = "clear";

        // ‚≠ê Re-enable Create Seal
        const sealBtn = document.getElementById("itemSealBtn");
        sealBtn.disabled = false;
        sealBtn.style.opacity = "1";
        sealBtn.style.cursor = "pointer";

        return;
    }

    // Normal clear mode
    document.getElementById("itemTitleInput").value = "";
    document.getElementById("itemEffectInput").value = "";
    document.getElementById("itemUrlInput").value = "https://wiki.project1999.com/";
    document.getElementById("itemImgInput").value = "https://wiki.project1999.com/images/";
    document.getElementById("itemNoteInput").value = "";
};

function sanitizeUrl(input, base) {
    const trimmed = (input || "").trim();

    // Blank or base path ‚Üí treat as blank
    if (trimmed === "" || trimmed === base) {
        return "";
    }

    // Valid: must start with base AND have something after it
    if (trimmed.startsWith(base) && trimmed.length > base.length) {
        return trimmed;
    }

    // Invalid ‚Üí ask user if they want to blank it out
    const proceed = confirm(
        "Invalid item link.\n\n" +
        "Would you like to continue and remove it (set to blank)?"
    );

    if (proceed) {
        return ""; // blank it out
    }

    // User wants to fix manually ‚Üí special abort token
    return "__ABORT__";
}

// ADD CH CHAIN TIMER PANEL BUTTON HANDLER
document.getElementById("addChChainPanelBtn").onclick = () => {
    const title = prompt("Enter CH Chain Title:", "CH Chain Timer +") || "CH Chain Timer +";

    // Default macro text (needed here so newChain can use it)
    const DEFAULT_MACRO = `/pause 1, /stand
/cast 1
/cast 1
/pause 30, /shout ### CH on %t ###
/shout +++### Go (next in line) +++####`;

    const newChain = {
        id: crypto.randomUUID(),
        type: "chchain",
        title,
        tanks: [],
        currentTankIndex: 0,
        clerics: [],
        delayMs: 3000,
        macroTemplate: "/ooc {name} casting Complete Heal on {target} >>",
        channel: "/ooc",
        target: "tank",
        myName: "",
        chainRunning: false,
        log: [],

        // ‚≠ê NEW FIELD
        macroNotes: DEFAULT_MACRO,

        // NEW ENGINE FIELDS
        currentBlockIndex: null,
        currentBlockStartTime: null,
        _frozenBlockTime: null,
        _cycleRotation: null,
        _lastCasterIndex: -1
    };

    // Register the chain
    window.CHChains.push(newChain);
    window.ItemRegistry.push(newChain);

    // Build the panel UI
    createChChainPanel(newChain);
};

// ===============================
// CH CHAIN TIMER PANEL SYSTEM
// ===============================
function createChChainPanel(chain) {
    const container = document.getElementById("chChainPanelsContainer");
    if (!container) return;

    chain._frozenBlockTime = null;
    chain._cycleRotation = null;
    chain._lastCasterIndex = -1;
    chain.currentBlockIndex = null;
    chain.currentBlockStartTime = null;

    // PANEL WRAPPER
    const panel = document.createElement("div");
    panel.className = "section";
    panel.dataset.chId = chain.id;

    // TITLE BAR
    const titleDiv = document.createElement("div");
    titleDiv.className = "section-title";
    titleDiv.textContent = chain.title;

    const controlsRow = document.createElement("div");
    controlsRow.style.marginBottom = "8px";

    // ============================================================
    // TEMPO CHANGE (NEW ENGINE SAFE)
    // ============================================================
    function applyNewDelay(newDelayMs) {
        chain.delayMs = newDelayMs; // affects only future blocks

        if (window.CHDebug) {
            console.log(SWOOSH_START);
            console.log("[CH] TEMPO CHANGE", {
                chainId: chain.id,
                title: chain.title,
                newDelayMs,
                delayMs_after: chain.delayMs,
                frozenBlockTime: chain._frozenBlockTime,
                currentBlockIndex: chain.currentBlockIndex,
                currentBlockStartTime: chain.currentBlockStartTime
            });
            console.log(SWOOSH_END);
        }

        renderOnce();
    }

    // ============================================================
    // DELAY CONTROLS
    // ============================================================
    const delayLabel = document.createElement("span");
    delayLabel.textContent = "Delay: ";

    const btn3 = document.createElement("button");
    btn3.textContent = "3s";

    const btn4 = document.createElement("button");
    btn4.textContent = "4s";

    const btn5 = document.createElement("button");
    btn5.textContent = "5s";

    const delayInput = document.createElement("input");
    delayInput.type = "number";
    delayInput.min = "2";
    delayInput.max = "20";
    delayInput.value = (chain.delayMs / 1000) || 3;
    delayInput.style.width = "50px";
    delayInput.style.marginLeft = "4px";

    btn3.onclick = () => { delayInput.value = 3; applyNewDelay(3000); };
    btn4.onclick = () => { delayInput.value = 4; applyNewDelay(4000); };
    btn5.onclick = () => { delayInput.value = 5; applyNewDelay(5000); };

    delayInput.onchange = () => {
const v = Math.max(2, Math.min(20, parseInt(delayInput.value, 10) || 3));
        delayInput.value = v;
        applyNewDelay(v * 1000);
    };

    // ============================================================
    // MY CLERIC NAME
    // ============================================================
    const myLabel = document.createElement("span");
    myLabel.textContent = "  My Cleric: ";
    myLabel.style.marginLeft = "16px";

    const myInput = document.createElement("input");
    myInput.type = "text";
    myInput.placeholder = "YourName";
    myInput.style.width = "120px";
    myInput.value = chain.myName || "";

    myInput.onchange = () => {
        chain.myName = myInput.value.trim();
        renderOnce();
    };

// ============================================================
// MACRO NOTES SYSTEM
// ============================================================

// ‚≠ê Default macro text
const DEFAULT_MACRO = `/pause 1, /stand
/cast 1
/cast 1
/pause 30, /shout ### CH on %t ###
/shout +++### Go (next in line) +++####`;

// ‚≠ê Ensure chain has macroNotes field
chain.macroNotes = chain.macroNotes || DEFAULT_MACRO;

// ‚≠ê Notes toggle button
const notesToggleBtn = document.createElement("button");
notesToggleBtn.textContent = "[ ] Notes";
notesToggleBtn.style.marginLeft = "6px";
notesToggleBtn.style.fontSize = "12px";
notesToggleBtn.style.padding = "2px 6px";
controlsRow.appendChild(notesToggleBtn);

// ‚≠ê Notes panel container
const notesPanel = document.createElement("div");
notesPanel.style.display = "none";
notesPanel.style.marginTop = "6px";
notesPanel.style.border = "1px solid #666";
notesPanel.style.padding = "6px";
notesPanel.style.background = "#111";
notesPanel.style.color = "#ddd";
notesPanel.style.fontSize = "12px";
notesPanel.style.whiteSpace = "pre-wrap";
panel.appendChild(notesPanel);

// ‚≠ê Notes editor
const notesEditor = document.createElement("textarea");
notesEditor.style.width = "100%";
notesEditor.style.height = "120px";
notesEditor.style.background = "#000";
notesEditor.style.color = "#0f0";
notesEditor.style.fontFamily = "monospace";
notesEditor.style.fontSize = "12px";
notesEditor.style.marginBottom = "6px";
notesEditor.value = chain.macroNotes;

// ‚≠ê Save button
const saveNotesBtn = document.createElement("button");
saveNotesBtn.textContent = "Save Macro Notes";
saveNotesBtn.style.fontSize = "12px";
saveNotesBtn.style.padding = "4px 8px";

// ‚≠ê Add editor + button to panel
notesPanel.appendChild(notesEditor);
notesPanel.appendChild(saveNotesBtn);

// ‚≠ê Toggle logic
let notesVisible = false;
notesToggleBtn.onclick = () => {
    notesVisible = !notesVisible;
    notesPanel.style.display = notesVisible ? "block" : "none";
    notesToggleBtn.textContent = notesVisible ? "[x] Notes" : "[ ] Notes";
};

// ‚≠ê Save logic (persists via swoosh save)
saveNotesBtn.onclick = () => {
    chain.macroNotes = notesEditor.value;
    chLogLine("Macro notes saved.");

    if (typeof chain._saveState === "function") {
        chain._saveState(); // swoosh save
    }
};

    // ============================================================
    // START / STOP BUTTON
    // ============================================================
    const startStopBtn = document.createElement("button");
    startStopBtn.textContent = chain.chainRunning ? "STOP CHAIN" : "START CHAIN";
    startStopBtn.style.marginLeft = "16px";

    startStopBtn.onclick = () => {
        if (!chain.chainRunning) {
            const rotation = getActiveRotation();
            if (!rotation.length) {
                chLogLine("Cannot start chain: no active clerics.");
                return;
            }

            chain._cycleRotation = rotation.slice();
            chain.currentBlockIndex = 0;
            chain.currentBlockStartTime = Date.now();
            chain._frozenBlockTime = chain.delayMs;
            chain._lastCasterIndex = -1;
            chain.chainRunning = true;

            chLogLine("CH Chain started.");
        } else {
            chain.chainRunning = false;
            chain._lastCasterIndex = -1;
            chLogLine("CH Chain stopped.");
        }

        startStopBtn.textContent = chain.chainRunning ? "STOP CHAIN" : "START CHAIN";
        renderOnce();
    };

    // ============================================================
    // RESET BUTTON
    // ============================================================
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset";
    resetBtn.style.marginLeft = "4px";

    resetBtn.onclick = () => {
        if (!chain._cycleRotation || !chain._cycleRotation.length) return;

        chain.currentBlockIndex = 0;
        chain.currentBlockStartTime = Date.now();
        chain._frozenBlockTime = chain.delayMs;
        chain._lastCasterIndex = -1;

        chLogLine("CH Chain reset.");
        renderOnce();
    };

    // ============================================================
    // DELETE PANEL BUTTON
    // ============================================================
    const deleteBtn = document.createElement("button");
    deleteBtn.textContent = "Delete Panel";
    deleteBtn.style.marginLeft = "4px";

    deleteBtn.onclick = () => {
        if (!confirm("Delete this CH Chain panel?")) return;

        panel.remove();
        window.ItemRegistry = window.ItemRegistry.filter(x => x.id !== chain.id);
        window.CHChains = window.CHChains.filter(x => x.id !== chain.id);
        window.CHPanels.delete(chain.id);

        chLogLine(`Deleted CH Chain panel: ${chain.title}`);
    };

    // ============================================================
    // SYNC / UPDATE BUTTON
    // ============================================================
    const syncUpdateBtn = document.createElement("button");
    syncUpdateBtn.textContent = "Sync / Update Chain";
    syncUpdateBtn.style.marginLeft = "4px";

    syncUpdateBtn.onclick = () => {
        if (!chain.chainRunning) {
            chLogLine("Chain not running ‚Äî nothing to sync.");
            return;
        }

        const oldRotation = chain._cycleRotation;
        if (!oldRotation || !oldRotation.length) return;

        const currentIdx = chain.currentBlockIndex;
        const currentCleric = oldRotation[currentIdx];
        if (!currentCleric) return;

        const newRotation = getActiveRotation();
        if (!newRotation.length) {
            chLogLine("Cannot sync: no active clerics.");
            return;
        }

        let newIndex = newRotation.findIndex(c => c.name === currentCleric.name);
        if (newIndex === -1) newIndex = 0;

        chain._cycleRotation = newRotation.slice();
        chain.currentBlockIndex = newIndex;
        chain._lastCasterIndex = -1;

        chLogLine("Chain synced to current cleric.");
        renderOnce();
    };

    // ============================================================
    // ADD CONTROLS TO ROW
    // ============================================================
    controlsRow.append(
        delayLabel, btn3, btn4, btn5, delayInput,
        myLabel, myInput,
        startStopBtn, resetBtn, deleteBtn, syncUpdateBtn
    );

    // ============================================================
    // MACRO AREA
    // ============================================================
    const macroWrap = document.createElement("div");
    macroWrap.style.marginBottom = "8px";
    macroWrap.style.fontSize = "12px";

    const macroLabel = document.createElement("div");
    macroLabel.textContent = "Macro Template:";

    const macroTopRow = document.createElement("div");
    macroTopRow.style.marginBottom = "4px";

    const channelInput = document.createElement("input");
    channelInput.style.width = "70px";
    channelInput.value = chain.channel || "/ooc";

    const targetInput = document.createElement("input");
    targetInput.style.width = "100px";
    targetInput.style.marginLeft = "4px";
    targetInput.value = chain.target || "tank";

    const macroTextarea = document.createElement("textarea");
    macroTextarea.style.width = "100%";
    macroTextarea.style.height = "40px";
    macroTextarea.value = chain.macroTemplate || "/ooc {name} casting Complete Heal on {target} >>";

    channelInput.onchange = () => chain.channel = channelInput.value.trim() || "/ooc";
    targetInput.onchange = () => chain.target = targetInput.value.trim() || "tank";
    macroTextarea.onchange = () => chain.macroTemplate = macroTextarea.value.trim();

    macroTopRow.append(
        document.createTextNode("Channel: "), channelInput,
        document.createTextNode("  Target: "), targetInput
    );

    macroWrap.append(macroLabel, macroTopRow, macroTextarea);

    // ============================================================
    // FINAL ASSEMBLY (NO CLOSING BRACE HERE!)
    // ============================================================
    panel.append(titleDiv, controlsRow, macroWrap);
    container.append(panel);

    // --- TANK ROTATION UI ---
    const tankWrap = document.createElement("div");
    tankWrap.style.marginTop = "10px";

    const tankLabel = document.createElement("div");
    tankLabel.textContent = "Tank Rotation:";
    tankLabel.style.fontSize = "12px";
    tankLabel.style.marginBottom = "4px";

    const tankListDiv = document.createElement("div");
    tankListDiv.style.marginBottom = "6px";
tankListDiv.style.display = "flex";
tankListDiv.style.flexWrap = "wrap";
tankListDiv.style.alignItems = "center";
tankListDiv.style.gap = "6px";
    const addTankBtn = document.createElement("button");
    addTankBtn.textContent = "+ Tank";
    addTankBtn.style.marginRight = "4px";

    const nextTankBtn = document.createElement("button");
    nextTankBtn.textContent = "Next Tank";

    const removeTankBtn = document.createElement("button");
    removeTankBtn.textContent = "Remove Tank";
    removeTankBtn.style.marginLeft = "4px";

    tankWrap.append(tankLabel, tankListDiv, addTankBtn, nextTankBtn, removeTankBtn);

    // IMPORTANT: macroWrap must already exist above this line
    macroWrap.append(tankWrap);

    function renderTankList() {
        tankListDiv.innerHTML = "";

        chain.tanks.forEach((tankName, idx) => {
            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.alignItems = "center";
            row.style.marginBottom = "4px";

            const chk = document.createElement("input");
            chk.type = "checkbox";
            chk.checked = (idx === chain.currentTankIndex);

            chk.onchange = () => {
                chain.currentTankIndex = idx;
                chain.target = chain.tanks[idx];
                targetInput.value = chain.tanks[idx];
                renderTankList();
                chLogLine(`Switched tank to: ${chain.tanks[idx]}`);
            };

            const nameInput = document.createElement("input");
            nameInput.type = "text";
            nameInput.value = tankName;
            nameInput.style.marginLeft = "6px";
            nameInput.style.width = "120px";
            nameInput.style.fontSize = "12px";

            nameInput.oninput = () => {
                chain.tanks[idx] = nameInput.value;

                if (idx === chain.currentTankIndex) {
                    chain.target = nameInput.value;
                    targetInput.value = nameInput.value;
                }
            };

            row.append(chk, nameInput);
            tankListDiv.appendChild(row);
        });
    }

    addTankBtn.onclick = () => {
        const nextNum = chain.tanks.length + 1;
        const name = `Tank${nextNum}`;

        chain.tanks.push(name);

        if (chain.tanks.length === 1) {
            chain.currentTankIndex = 0;
            chain.target = name;
            targetInput.value = name;
        }

        renderTankList();
    };

    nextTankBtn.onclick = () => {
        if (chain.tanks.length === 0) return;

        chain.currentTankIndex = (chain.currentTankIndex + 1) % chain.tanks.length;

        const newTank = chain.tanks[chain.currentTankIndex];
        chain.target = newTank;
        targetInput.value = newTank;

        chLogLine(`Switched to next tank: ${newTank}`);
        renderTankList();
    };

    removeTankBtn.onclick = () => {
        if (chain.tanks.length === 0) return;

        chain.tanks.splice(chain.currentTankIndex, 1);

        if (chain.currentTankIndex >= chain.tanks.length) {
            chain.currentTankIndex = chain.tanks.length - 1;
        }

        if (chain.tanks.length > 0) {
            const newTank = chain.tanks[chain.currentTankIndex];
            chain.target = newTank;
            targetInput.value = newTank;
            chLogLine(`Removed tank. Now targeting: ${newTank}`);
        } else {
            chain.target = "";
            targetInput.value = "";
            chLogLine("Removed last tank. No tanks remain.");
        }

        renderTankList();
    };

    // Cleric list
    const clericListDiv = document.createElement("div");
    clericListDiv.style.marginBottom = "8px";

    const clericButtonsRow = document.createElement("div");
    const addClericBtn = document.createElement("button");
    addClericBtn.textContent = "+ Cleric";
    const removeClericBtn = document.createElement("button");
    removeClericBtn.textContent = "- Last";
    clericButtonsRow.append(addClericBtn, removeClericBtn);

    // Timeline bar
    const timelineWrap = document.createElement("div");
    timelineWrap.style.margin = "8px 0";
    const timelineLabel = document.createElement("div");
    timelineLabel.textContent = "Chain Flow (10s CH Cast):";
    timelineLabel.style.fontSize = "12px";
    timelineLabel.style.marginBottom = "4px";

    const timelineBar = document.createElement("div");
    timelineBar.style.height = "30px";
    timelineBar.style.background = "#333";
    timelineBar.style.border = "1px solid #555";
    timelineBar.style.position = "relative";
    timelineBar.style.overflow = "hidden";

    const headerBar = document.createElement("div");
    headerBar.style.height = "20px";
    headerBar.style.position = "relative";
    headerBar.style.marginBottom = "4px";
    headerBar.style.background = "#222";
    headerBar.style.border = "1px solid #555";
    headerBar.style.overflow = "hidden";

    timelineWrap.prepend(headerBar);
    timelineWrap.append(timelineLabel, timelineBar);

    // Log
    const logDiv = document.createElement("div");
    logDiv.style.background = "#000";
    logDiv.style.color = "#0f0";
    logDiv.style.fontFamily = "'Courier New', monospace";
    logDiv.style.fontSize = "11px";
    logDiv.style.height = "150px";
    logDiv.style.overflowY = "auto";
    logDiv.style.padding = "5px";
logDiv.style.border = '1px solid #555';
    logDiv.style.whiteSpace = "pre-line";

    // Assemble panel
    panel.append(titleDiv, controlsRow, macroWrap, clericListDiv, clericButtonsRow, timelineWrap, logDiv);

    // Register panel
    window.CHPanels.set(chain.id, { panel, chain });

// --------------------
// STATE + HELPERS
// --------------------
chain._logDiv = logDiv;
chain._timelineBar = timelineBar;
chain._clericListDiv = clericListDiv;
chain._headerBar = headerBar;
// ‚≠ê Make cleric header bar wider and prevent clipping
headerBar.style.whiteSpace = "nowrap";
headerBar.style.overflowX = "auto";
headerBar.style.display = "flex";
headerBar.style.gap = "12px";
headerBar.style.padding = "2px 4px";
// ‚≠ê PATCH: Make cleric list flow horizontally and wrap like text
clericListDiv.style.display = "flex";
clericListDiv.style.flexWrap = "wrap";
clericListDiv.style.alignItems = "center";
clericListDiv.style.gap = "6px";

    function chLogLine(text) {
        const stamp = new Date().toLocaleTimeString();
        const line = `[${stamp}] ${text}\n`;
        chain.log.push(line);
        chain._logDiv.textContent += line;
        chain._logDiv.scrollTop = chain._logDiv.scrollHeight;
    }

function getActiveRotation() {
    return chain.clerics
        .filter(c => c.active)
        .sort((a, b) => a.slotId - b.slotId);   // ‚≠ê FIXED: permanent order
}

function renderClericList() {
    chain._clericListDiv.innerHTML = "";

    // ‚≠ê Always use permanent slot order
    const clericsInOrder = chain.clerics
        .slice()
        .sort((a, b) => a.slotId - b.slotId);

    clericsInOrder.forEach((cleric) => {
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.marginBottom = "4px";
        row.style.fontSize = "12px";
        row.style.gap = "6px";

        // ===============================
        // ACTIVE CHECKBOX
        // ===============================
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = cleric.active;

        chk.onchange = () => {
            cleric.active = chk.checked;
            updateRotationAfterChange();
            renderOnce();
        };

// ===============================
// EDITABLE NAME INPUT
// ===============================
const nameInput = document.createElement("input");
nameInput.type = "text";
nameInput.value = cleric.name;
nameInput.style.width = "100px";

// Update the cleric object live, but DO NOT re-render
nameInput.oninput = () => {
    cleric.name = nameInput.value;
    // no renderOnce() here
};

// ===============================
// EDITABLE PATTERN INPUT
// ===============================
const patternInput = document.createElement("input");
patternInput.type = "text";
patternInput.value = cleric.pattern || "";
patternInput.style.width = "60px";
patternInput.placeholder = "####";

// Update pattern live, but DO NOT re-render
patternInput.oninput = () => {
    cleric.pattern = patternInput.value;
    // no renderOnce() here
};

        // ===============================
        // SYNC BUTTON ("Just Fired!")
        // ===============================
        const syncBtn = document.createElement("button");
        syncBtn.textContent = "Just Fired!";
        syncBtn.style.fontSize = "10px";

        syncBtn.onclick = () => {
            const rotation = chain._cycleRotation || getActiveRotation();
            const rotIdx = rotation.findIndex(c => c.slotId === cleric.slotId);

            if (rotIdx >= 0) {
                chain.currentBlockIndex = rotIdx;
                chain.currentBlockStartTime = Date.now();
                chain._frozenBlockTime = chain.delayMs;
                chain._lastCasterIndex = rotIdx - 1;

                chLogLine(`Synced to cleric: ${cleric.name}`);
                renderOnce();
            }
        };

        // ===============================
        // BUILD ROW
        // ===============================
        row.append(chk, nameInput, patternInput, syncBtn);
        chain._clericListDiv.appendChild(row);
    });
}


function renderTimeline() {
    const rotation = chain._cycleRotation || getActiveRotation();

    // Clear old UI
    chain._timelineBar.innerHTML = "";
    chain._headerBar.innerHTML = "";

    const now = Date.now();

    // If chain is idle or missing state, show idle message
    if (!chain.chainRunning ||
        !rotation || rotation.length === 0 ||
        chain.currentBlockIndex === null ||
        chain.currentBlockStartTime === null) {

        const idle = document.createElement("div");
        idle.style.position = "absolute";
        idle.style.left = "4px";
        idle.style.top = "6px";
        idle.style.fontSize = "11px";
        idle.style.color = "#aaa";
        idle.textContent = "Chain idle or no active clerics.";
        chain._timelineBar.appendChild(idle);
        return;
    }

    // Compute timing
    const currentIdx = chain.currentBlockIndex;
    const blockTime = chain._frozenBlockTime || chain.delayMs;
    const elapsed = now - chain.currentBlockStartTime;

    // Clamp progress between 0 and 1
    const blockProgress = Math.max(0, Math.min(1, elapsed / blockTime));

    // Row container
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.width = "100%";
    row.style.height = "100%";
    row.style.position = "relative";

    rotation.forEach((cleric, idx) => {
        // Block container
        const block = document.createElement("div");
        block.style.flex = "1";
        block.style.borderRight = "1px solid #555";
        block.style.position = "relative";
        block.style.overflow = "hidden";

        // Fill bar
        const fill = document.createElement("div");
        fill.style.position = "absolute";
        fill.style.left = "0";
        fill.style.top = "0";
        fill.style.bottom = "0";

        if (idx < currentIdx) {
            // Completed blocks
            fill.style.width = "100%";
            fill.style.background = "#3cb371";
        } else if (idx === currentIdx) {
            // Current block
            fill.style.width = (blockProgress * 100) + "%";
            fill.style.background = "#ff8c00";
        } else {
            // Future blocks
            fill.style.width = "0%";
            fill.style.background = "#3cb371";
        }

        block.appendChild(fill);
        row.appendChild(block);

        // Header label
        const header = document.createElement("div");
        header.style.position = "absolute";
        header.style.left = ((idx + 0.5) * (100 / rotation.length)) + "%";
        header.style.top = "2px";
        header.style.transform = "translateX(-50%)";
        header.style.fontSize = "10px";
        header.style.color = "#ffd700";
        header.style.textAlign = "center";
        header.innerHTML = `${cleric.name}<br>${cleric.pattern || ""}`;

        chain._headerBar.appendChild(header);
    });

    chain._timelineBar.appendChild(row);
}

    function renderOnce() {
        renderClericList();
        renderTankList();
        renderTimeline();
    }

// --------------------
// ADD / REMOVE CLERIC
// --------------------
// Ensure this exists somewhere in your chain object:
if (chain.nextSlotId === undefined) chain.nextSlotId = 0;

// ===============================
// ADD CLERIC (permanent slotId)
// ===============================
addClericBtn.onclick = () => {
    const slotId = chain.nextSlotId++;

    // ‚≠ê Names & patterns based on slotId, not length
    const name = `Cleric${slotId + 1}`;
    const pattern = `${slotId + 1}${slotId + 1}${slotId + 1}${slotId + 1}`;

    chain.clerics.push({
        slotId,       // ‚≠ê permanent identity
        name,
        pattern,
        active: true
    });

    chLogLine(`Added cleric: ${name} (slot ${slotId})`);

    updateRotationAfterChange();
    renderOnce();
};


// ===============================
// REMOVE LAST CLERIC
// ===============================
removeClericBtn.onclick = () => {
    if (chain.clerics.length === 0) return;

    const removed = chain.clerics.pop();
    chLogLine(`Removed cleric: ${removed.name} (slot ${removed.slotId})`);

    updateRotationAfterChange();
    renderOnce();
};


// ===============================
// UPDATE ROTATION AFTER ANY CHANGE
// ===============================
function updateRotationAfterChange() {
    const now = Date.now();
    let elapsed = 0;

    // Preserve elapsed time if chain is running
    if (chain.chainRunning &&
        chain.currentBlockStartTime !== null &&
        chain._frozenBlockTime !== null) {
        elapsed = now - chain.currentBlockStartTime;
    }

    // Who is currently casting? (slotId-based)
    let currentSlot = null;
    if (chain._cycleRotation &&
        chain.currentBlockIndex !== null &&
        chain._cycleRotation[chain.currentBlockIndex]) {
        currentSlot = chain._cycleRotation[chain.currentBlockIndex].slotId;
    }

    // Build new rotation (slotId order ONLY)
    const newRotation = chain.clerics
        .filter(c => c.active)
        .sort((a, b) => a.slotId - b.slotId);

    chain._cycleRotation = newRotation.slice();

    // If chain is stopped, just reset index and exit
    if (!chain.chainRunning) {
        chain._lastCasterIndex = -1;
        chain.currentBlockIndex = 0;
        return;
    }

    // If no clerics left ‚Üí stop chain
    if (!newRotation.length) {
        chLogLine("No active clerics left. Stopping chain.");
        chain.chainRunning = false;
        chain._cycleRotation = [];
        chain._lastCasterIndex = -1;
        startStopBtn.textContent = "START CHAIN";
        return;
    }

    // Try to keep the same cleric casting (slotId match)
    let newIndex = 0;
    if (currentSlot !== null) {
        const idx = newRotation.findIndex(c => c.slotId === currentSlot);
        if (idx >= 0) newIndex = idx;
    }

    // Restore timing + block index
    chain.currentBlockIndex = newIndex;
    chain.currentBlockStartTime = now - elapsed;
    chain._frozenBlockTime = chain.delayMs;
    chain._lastCasterIndex = newIndex - 1;
}


// ===============================
// TICK LOOP (per-panel)
// ===============================
function tick() {
    if (!chain.chainRunning) return;

    const rotation = chain._cycleRotation || [];
    if (!rotation.length) return;

    const now = Date.now();

    if (chain.currentBlockIndex === null || chain.currentBlockStartTime === null) {
        chain.currentBlockIndex = 0;
        chain.currentBlockStartTime = now;
        chain._frozenBlockTime = chain.delayMs;
        chain._lastCasterIndex = -1;
    }

    const currentIdx = chain.currentBlockIndex;
    const currentCleric = rotation[currentIdx];
    if (!currentCleric) return;

    const elapsed = now - chain.currentBlockStartTime;
    const blockTime = chain._frozenBlockTime || chain.delayMs;

    // ===============================
    // MACRO FIRING (new cleric)
    // ===============================
    if (currentIdx !== chain._lastCasterIndex) {
        const tmpl = chain.macroTemplate || "/ooc {name} casting Complete Heal on {target} >>";
        let msg = tmpl.replace("{name}", currentCleric.name)
                      .replace("{pattern}", currentCleric.pattern || "")
                      .replace("{target}", chain.target);

        const delaySec = (chain.delayMs / 1000).toFixed(1);

        if (msg.startsWith(chain.channel)) {
            chLogLine(`${currentCleric.name} (${currentCleric.pattern || "?"}) firing [delay ${delaySec}s]: ${msg}`);
        } else {
            chLogLine(`${currentCleric.name} (${currentCleric.pattern || "?"}) firing [delay ${delaySec}s]: ${chain.channel} ${msg}`);
        }

        // YOUR TURN BEEP
        const myNameLower = (chain.myName || "").toLowerCase();
        if (currentCleric.name.toLowerCase() === myNameLower) {
            if (typeof makeBeep === "function") makeBeep();
            chLogLine("YOUR TURN! Cast CH NOW!");
        }

        // EARLY WARNINGS (slotId-based)
        if (rotation.length > 2) {
            const myIndex = rotation.findIndex(c => c.name.toLowerCase() === myNameLower);

            if (myIndex >= 0) {
                const warn2 = (myIndex - 2 + rotation.length) % rotation.length;
                const warn1 = (myIndex - 1 + rotation.length) % rotation.length;

                if (rotation[warn2].slotId === currentCleric.slotId) {
                    chLogLine(`‚ö†Ô∏è Early Warning: ${currentCleric.name} fired. You are coming up soon!`, "yellow");
                }

                if (rotation[warn1].slotId === currentCleric.slotId) {
                    chLogLine(`‚ö†Ô∏è Final Warning: ${currentCleric.name} fired. YOU ARE NEXT!`, "yellow");
                }
            }
        }

        chain._lastCasterIndex = currentIdx;
    }



        // ADVANCE TO NEXT BLOCK
        if (elapsed >= blockTime) {
            const newRotation = getActiveRotation();
            if (!newRotation || newRotation.length === 0) {
                chLogLine("Chain stopped: no active clerics.");
                chain.chainRunning = false;
                startStopBtn.textContent = "START CHAIN";
                return;
            }

            chain._cycleRotation = newRotation.slice();
            chain.currentBlockIndex = (currentIdx + 1) % newRotation.length;
            chain.currentBlockStartTime = now;
            chain._frozenBlockTime = chain.delayMs;
            chain._lastCasterIndex = -1;
        }

        renderTimeline();
    }

    // Start per-panel tick
    setInterval(tick, window.CHTickRate || 50);

    // Initial render
    renderOnce();
}

// itemlord chritem itemchr chrlord letsgo

// =======================================
// CB2: CHARACTER CREATION + PANEL LOGIC
// =======================================

// -------------------------------
// Initialize CB2 from swoosh
// -------------------------------
function cb2_init() {
    if (CB2.initialized) return;

    // If swooshLoad already populated CB2, keep it
    if (!Array.isArray(CB2.characters)) CB2.characters = [];
    if (!Array.isArray(CB2.items)) CB2.items = [];
    if (!Array.isArray(CB2.tokens)) CB2.tokens = [];

    cb2_renderCharacterList();
    cb2_renderCharacterDeck();

    CB2.initialized = true;
    cb2_log("CB2 Initialized.");
}

//

// -------------------------------
// RACE SELECTOR RENDERING
// -------------------------------
//function cb2_renderRaceSelector() {
//    const box = document.getElementById("cb2_panel_raceSelector");
//    if (!box) return;

//    box.innerHTML = "";

//    Object.entries(CB2_RACE_CLASS_STATS).forEach(([race, enabled]) => {
 //       const btn = document.createElement("button");
 //       btn.textContent = race;

 //       if (enabled) {
 //           btn.className = "cb2_race_enabled";
 //           btn.onclick = () => {
 //               CB2.selectedRace = race;
 //               cb2_log("Selected race: " + race);
//            };
//        } else {
//            btn.className = "cb2_race_disabled";
 //           btn.disabled = true;
 //           btn.title = "Race not available yet";
 //       }

//        btn.style.margin = "2px";
 //       box.appendChild(btn);
 //   });
//}

// -------------------------------
// CREATE CHARACTER
// -------------------------------
CB2.currentCharacterDraft = null;
const CB2_RACE_CLASS_STATS = {
    human: {
        Bard:        { STR:80, STA:75, AGI:75, DEX:85, WIS:75, INT:75, CHA:85, bonus:25 },
        Cleric:      { STR:80, STA:80, AGI:75, DEX:75, WIS:85, INT:75, CHA:75, bonus:30 },
        Druid:       { STR:75, STA:85, AGI:75, DEX:75, WIS:85, INT:75, CHA:75, bonus:30 },
        Enchanter:   { STR:75, STA:75, AGI:75, DEX:75, WIS:75, INT:85, CHA:85, bonus:30 },
        Magician:    { STR:75, STA:85, AGI:75, DEX:75, WIS:75, INT:85, CHA:75, bonus:30 },
        Monk:        { STR:80, STA:80, AGI:85, DEX:85, WIS:75, INT:75, CHA:75, bonus:20 },
        Necromancer: { STR:75, STA:75, AGI:75, DEX:85, WIS:75, INT:85, CHA:75, bonus:30 },
        Paladin:     { STR:85, STA:80, AGI:75, DEX:75, WIS:80, INT:75, CHA:85, bonus:20 },
        Ranger:      { STR:80, STA:85, AGI:75, DEX:75, WIS:80, INT:75, CHA:75, bonus:20 },
        Rogue:       { STR:75, STA:75, AGI:85, DEX:85, WIS:75, INT:75, CHA:75, bonus:30 },
        "Shadow Knight": { STR:80, STA:75, AGI:75, DEX:75, WIS:75, INT:85, CHA:80, bonus:20 },
        Warrior:     { STR:85, STA:85, AGI:80, DEX:75, WIS:75, INT:75, CHA:75, bonus:25 },
        Wizard:      { STR:75, STA:85, AGI:75, DEX:75, WIS:75, INT:85, CHA:75, bonus:30 }
    },

    iksar: {
        Monk:        { STR:75, STA:75, AGI:100, DEX:95, WIS:80, INT:75, CHA:55, bonus:20 },
        Necromancer: { STR:70, STA:70, AGI:90,  DEX:95, WIS:80, INT:85, CHA:55, bonus:30 },
        "Shadow Knight": { STR:80, STA:75, AGI:90, DEX:85, WIS:80, INT:85, CHA:60, bonus:20 },
        Shaman:      { STR:70, STA:75, AGI:90,  DEX:85, WIS:90, INT:75, CHA:60, bonus:30 },
        Warrior:     { STR:80, STA:80, AGI:95,  DEX:85, WIS:80, INT:75, CHA:55, bonus:25 }
    }
};

function cb2_getBaseStatsForRaceClass(race, className) {
    if (!race || !className) return null;

    const raceKey = race.toLowerCase(); // "human", "iksar"
    const raceData = CB2_RACE_CLASS_STATS[raceKey];
    if (!raceData) return null;

    // Normalize class name to match keys exactly
    const classKey = Object.keys(raceData).find(
        key => key.toLowerCase() === className.toLowerCase()
    );

    if (!classKey) return null;

    // Clone so we don't mutate the master table
    return { ...raceData[classKey] };
}

// ---------------------------------------
// IMPORT SCRAPED ITEM ‚Üí APPROVED LIST
// ---------------------------------------
function cb2_importScraperItem(scraped) {
    if (!scraped) {
        cb2_log("[CB2 Import] ERROR: No scraped item provided.");
        return;
    }

    cb2_log("[CB2 Import] Importing scraped item: " + scraped.name);

    // Convert scraped ‚Üí CB2 format
    const item = cb2_convertScraperItem(scraped);

    // Load existing approved items
    const items = cb2_swooshLoad("cb2_items", []);

    // Add new item
    items.push(item);

    // Save back to storage
    cb2_swooshSave("cb2_items", items);

    cb2_log("[CB2 Import] Saved item: " + item.name);
}

// =============================================================
// function cb2_renderCharacterCreatorStats
// =============================================================
function cb2_renderCharacterCreatorStats(chr) {
    const panel = document.getElementById("cb2_chrStatPanel");
    if (!panel) return;

    const stats = ["STR","STA","AGI","DEX","WIS","INT","CHA"];

    panel.innerHTML = `
        <div style="font-size:12px; margin-bottom:6px;">
            Points remaining: <strong>${chr.bonusPool}</strong>
        </div>

        <table style="font-size:12px;">
            <tr><th>Stat</th><th>Value</th><th>Adjust</th></tr>

            ${stats.map(stat => `
                <tr>
                    <td>${stat}</td>
                    <td>${chr.baseStats[stat]}</td>
                    <td>
                        <button class="cb2-stat-minus" data-stat="${stat}">-</button>
                        <button class="cb2-stat-plus" data-stat="${stat}">+</button>
                    </td>
                </tr>
            `).join("")}
        </table>
    `;

    panel.querySelectorAll(".cb2-stat-plus").forEach(btn => {
        btn.onclick = () => {
            cb2_addBonusPoint(chr, btn.getAttribute("data-stat"));
            cb2_renderCharacterCreatorStats(chr);
        };
    });

    panel.querySelectorAll(".cb2-stat-minus").forEach(btn => {
        btn.onclick = () => {
            cb2_removeBonusPoint(chr, btn.getAttribute("data-stat"));
            cb2_renderCharacterCreatorStats(chr);
        };
    });
}

// =============================================================
// function cb2_addBonusPoint
// =============================================================
function cb2_addBonusPoint(chr, stat) {
    if (chr.bonusPool <= 0) return;
    chr.baseStats[stat]++;
    chr.bonusPool--;
}

// =============================================================
// function cb2_removeBonusPoint
// =============================================================
function cb2_removeBonusPoint(chr, stat) {
    if (chr.baseStats[stat] <= chr.originalBaseStats[stat]) return;
    chr.baseStats[stat]--;
    chr.bonusPool++;
}

// ------------------------------------------------------------
// Character Creator: Draft Builder
// ------------------------------------------------------------
// =============================================================
// function cb2_startCharacterDraft
// =============================================================
function cb2_finalizeCharacterCreation() {
    const chr = CB2.currentCharacterDraft;

    if (!chr) {
        cb2_log("No character draft exists.");
        return;
    }

    if (chr.bonusPool > 0) {
        cb2_log("Assign all bonus points before creating the character.");
        return;
    }

    // Lock in the true base stats
    chr.originalBaseStats = { ...chr.baseStats };

    // REQUIRED FIELDS FOR PANELS
    chr.id = "chr_" + Date.now();
    chr.visible = true;          // ‚Üê THIS IS THE FIX
    chr.collapsed = false;
    chr.equipment = {};
    chr.finalStats = { ...chr.baseStats };

    // Save character
    CB2.characters.push(chr);
    cb2_swooshSave("characters", CB2.characters);

    cb2_log("Created character: " + chr.name);

    // Update both panels
    cb2_renderCharacterDeck();
    cb2_renderCharacterList?.();

    CB2.currentCharacterDraft = null;
}


// -------------------------------
// DELETE CHARACTER (SAFE RITUAL)
// -------------------------------
document.getElementById("cb2_btn_deleteOne").onclick = () => {
    const selected = CB2.characters.filter(chr => chr.visible);

    if (selected.length === 0) {
        cb2_log("Delete failed: No character selected.");
        return;
    }

    if (selected.length > 1) {
        cb2_log("Delete failed: Select only ONE character to delete.");
        return;
    }

    const chr = selected[0];
    const confirmText = prompt(`Type DELETE to confirm deleting: ${chr.name}`);

    if (confirmText !== "DELETE") {
        cb2_log("Delete cancelled.");
        return;
    }

    CB2.characters = CB2.characters.filter(c => c.id !== chr.id);
cb2_swooshSave("characters", CB2.characters);

    cb2_log("Deleted character: " + chr.name);

    cb2_renderCharacterList();
    cb2_renderCharacterDeck();
};

// -------------------------------
// AUTO-INIT
// -------------------------------
cb2_init();


function cb2_renderCharacterList() {
    const box = document.getElementById("cb2_characterListBox");
    if (!box) return;

    box.innerHTML = "";

    CB2.characters.forEach(chr => {
        const id = "cb2_chk_characterVisible_" + chr.id;

        const row = document.createElement("div");
        row.style.marginBottom = "4px";

        row.innerHTML = `
            <label>
                <input type="checkbox" id="${id}" ${chr.visible ? "checked" : ""}>
                ${chr.name}
            </label>
        `;

        box.appendChild(row);

        setTimeout(() => {
            const chk = document.getElementById(id);
            if (chk) {
                chk.onchange = () => {
                    chr.visible = chk.checked;
                    cb2_swooshSave("characters", CB2.characters);
                    cb2_renderCharacterDeck();
                };
            }
        }, 0);
    });
}
// =======================================
// CB2: MANUAL ITEM ENTRY LOGIC (CHECKBOX VERSION)
// =======================================

// EverQuest class short codes (canonical)
const CB2_ALL_CLASSES = [
    "WAR","CLR","PAL","RNG","SHD",
    "DRU","MNK","BRD","ROG","SHM",
    "NEC","WIZ","MAG","ENC"
];

// Full names for UI labels
const CB2_CLASS_FULLNAME = {
    "WAR":"Warrior",
    "CLR":"Cleric",
    "PAL":"Paladin",
    "RNG":"Ranger",
    "SHD":"Shadow Knight",
    "DRU":"Druid",
    "MNK":"Monk",
    "BRD":"Bard",
    "ROG":"Rogue",
    "SHM":"Shaman",
    "NEC":"Necromancer",
    "WIZ":"Wizard",
    "MAG":"Magician",
    "ENC":"Enchanter"
};

// EverQuest race short codes (canonical)
const CB2_ALL_RACES = [
    "HUM","BAR","ERU","ELF","HEF","DEF",
    "HFL","DWF","TRL","OGR","GNM","IKS"
];

// Full names for UI labels
const CB2_RACE_FULLNAME = {
    "HUM":"Human",
    "BAR":"Barbarian",
    "ERU":"Erudite",
    "ELF":"Wood Elf",
    "HEF":"High Elf",
    "DEF":"Dark Elf",
    "HFL":"Halfling",
    "DWF":"Dwarf",
    "TRL":"Troll",
    "OGR":"Ogre",
    "GNM":"Gnome",
    "IKS":"Iksar"
};

// EverQuest slot list (already canonical)
const CB2_ALL_SLOTS = [
    "PRIMARY","SECONDARY","RANGE","AMMO",
    "HEAD","FACE","NECK","SHOULDERS",
    "ARMS","BACK","WRISTS","HANDS",
    "FINGER","CHEST","WAIST","LEGS","FEET",
    "EAR","RING","CHARM"
];

// Render class checkboxes (short code value, full name label)
function cb2_renderManualItemClasses() {
    const box = document.getElementById("cb2_panel_manualItem_classes");
    if (!box) return;

    box.innerHTML = "";

    CB2_ALL_CLASSES.forEach(code => {
        const id = "cb2_manualItem_class_" + code;
        box.innerHTML += `
            <label style="display:block;">
                <input type="checkbox" id="${id}" value="${code}">
                ${CB2_CLASS_FULLNAME[code]}
            </label>
        `;
    });
}

// Render race checkboxes (short code value, full name label)
function cb2_renderManualItemRaces() {
    const box = document.getElementById("cb2_panel_manualItem_races");
    if (!box) return;

    box.innerHTML = "";

    CB2_ALL_RACES.forEach(code => {
        const id = "cb2_manualItem_race_" + code;
        box.innerHTML += `
            <label style="display:block;">
                <input type="checkbox" id="${id}" value="${code}">
                ${CB2_RACE_FULLNAME[code]}
            </label>
        `;
    });
}

// Render slot checkboxes (slots already match EQ format)
function cb2_renderManualItemSlots() {
    const box = document.getElementById("cb2_panel_manualItem_slots");
    if (!box) return;

    box.innerHTML = "";

    CB2_ALL_SLOTS.forEach(slot => {
        const id = "cb2_manualItem_slot_" + slot;
        box.innerHTML += `
            <label style="display:block;">
                <input type="checkbox" id="${id}" value="${slot}">
                ${slot}
            </label>
        `;
    });
}
function cb2_buildManualItem() {

    const nameEl = document.getElementById("cb2_manual_name");
    const name = nameEl ? nameEl.value.trim() : "";
    if (!name) {
        cb2_log("Manual Item Error: Name is required.");
        return null;
    }

    const typeEl = document.getElementById("cb2_manual_itemType");
    const itemType = typeEl ? typeEl.value : "Misc";

    const stats = {
        str: parseInt(cb2_manual_str.value) || 0,
        sta: parseInt(cb2_manual_sta.value) || 0,
        agi: parseInt(cb2_manual_agi.value) || 0,
        dex: parseInt(cb2_manual_dex.value) || 0,
        int: parseInt(cb2_manual_int.value) || 0,
        wis: parseInt(cb2_manual_wis.value) || 0,
        cha: parseInt(cb2_manual_cha.value) || 0,
        hp:  parseInt(cb2_manual_hp.value)  || 0,
        mana:parseInt(cb2_manual_mana.value)|| 0,
        end: parseInt(cb2_manual_end.value) || 0
    };

    const resists = {
        fire:    parseInt(cb2_manual_fire.value)    || 0,
        cold:    parseInt(cb2_manual_cold.value)    || 0,
        magic:   parseInt(cb2_manual_magic.value)   || 0,
        disease: parseInt(cb2_manual_disease.value) || 0,
        poison:  parseInt(cb2_manual_poison.value)  || 0
    };

    const dmg   = parseInt(cb2_manual_dmg.value)   || 0;
    const delay = parseInt(cb2_manual_delay.value) || 0;
    const ac    = parseInt(cb2_manual_ac.value)    || 0;

    // SLOTS (short codes)
    const slot = [];
    document.querySelectorAll("#cb2_panel_manualItem_slots input[type=checkbox]")
        .forEach(chk => { if (chk.checked) slot.push(chk.value); });

    // CLASSES (short codes)
    const classes = [];
    document.querySelectorAll("#cb2_panel_manualItem_classes input[type=checkbox]")
        .forEach(chk => { if (chk.checked) classes.push(chk.value); });

    // RACES (short codes)
    const races = [];
    document.querySelectorAll("#cb2_panel_manualItem_races input[type=checkbox]")
        .forEach(chk => { if (chk.checked) races.push(chk.value); });

    return {
        id: "cb2_item_" + Date.now(),
        name,
        itemType,
        stats,
        resists,
        dmg,
        delay,
        ac,
        slot,
        classes,   // SHORT CODES
        races,     // SHORT CODES

        // ‚≠ê PRESERVE IMAGE FROM SCRAPER
        image: window.CB2_manualEditorImage || null,

        rawText: null,
        effect: null,
        effectType: null,
        equipped: false
    };
}

// Send manual item to preview panel
document.getElementById("cb2_btn_manualItem_approve").onclick = () => {
    const item = cb2_buildManualItem();
    if (!item) return;

    // Render manual item in preview panel
    cb2_renderScrapedItemPreview(item);

    // Update global preview state
    window.CB2_currentPreviewItem = item;

    cb2_log("Manual item sent to preview.");

    // OPEN the preview panel body
    const previewBody = document.getElementById("cb2_panel_itemPreview_body");
    if (previewBody) previewBody.style.display = "block";

    // SCROLL to the preview panel
    const previewPanel = document.getElementById("cb2_panel_itemPreview");
    if (previewPanel) previewPanel.scrollIntoView({ behavior: "smooth" });
};

// Initialize UI
cb2_renderManualItemClasses();
cb2_renderManualItemRaces();
cb2_renderManualItemSlots();

//blockk

// Render item preview in the right panel
function cb2_renderItemPreview(item) {
    const box = document.getElementById("cb2_itemPreviewBox");
    if (!box) return;

    box.innerHTML = `
        <div style="border:1px solid #333; padding:10px; margin-bottom:10px;">
            <h4>${item.name}</h4>

            ${item.image && item.image.startsWith("http")
                ? `<img src="${item.image}" style="width:64px;height:64px;">`
                : `<div style="font-size:48px;">‚ú®</div>`
            }

            <pre style="white-space:pre-wrap; background:#111; color:#0f0; padding:10px; margin-top:10px;">
${JSON.stringify(item, null, 2)}
            </pre>
        </div>
    `;
}

// APPROVE MANUAL SEND TO PREVIEW CLICK BUT

document.getElementById("cb2_btn_manualItem_approve").onclick = () => {
    const item = cb2_buildManualItem();
    if (!item) return;

    // Render manual item in preview panel
    cb2_renderItemPreview(item);

    // Update global preview state
    window.CB2_currentPreviewItem = item;

    cb2_log("Manual item sent to preview.");

    // OPEN the preview panel body
    const previewBody = document.getElementById("cb2_panel_itemPreview_body");
    if (previewBody) previewBody.style.display = "block";

    // SCROLL to the preview panel
    const previewPanel = document.getElementById("cb2_panel_itemPreview");
    if (previewPanel) previewPanel.scrollIntoView({ behavior: "smooth" });
};


// Initialize manual item entry UI
cb2_renderManualItemClasses();
cb2_renderManualItemRaces();

// =======================================
// CB2: ITEM EQUIP LOGIC
// =======================================

// -------------------------------
// Render all items inside a character panel
// -------------------------------
function cb2_renderCharacterGear(chr) {
    const gearBox = document.getElementById("cb2_panel_chrGear_" + chr.id);
    if (!gearBox) return;

    gearBox.innerHTML = "";

    for (const slot in chr.equipment) {
        const item = chr.equipment[slot];
        if (!item) continue;

        const idx = item.id || `${chr.id}_${slot}`;

        const wrapper = document.createElement("div");
        wrapper.style.border = "1px solid #333";
        wrapper.style.padding = "8px";
        wrapper.style.marginBottom = "8px";
        wrapper.style.background = "#1a1a1a";

        wrapper.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center;">
<div style="display:flex; align-items:center; gap:6px;">
${
    item.image && item.image.startsWith("http")
        ? `<img src="${item.image}" style="width:20px; height:20px; object-fit:contain;">`
        : `<div style="
                width:20px;
                height:20px;
                background:#333;
                border:1px solid #555;
                border-radius:3px;
            "></div>`
}
    <strong>${item.name}</strong>
</div>

                <div>
                    <button class="cb2-gear-toggle" data-id="${idx}" style="margin-right:6px;">Show</button>
                    <button class="cb2-gear-unequip" data-slot="${slot}" data-chr="${chr.id}">‚úï</button>
                </div>
            </div>

            <div id="cb2_gear_details_${idx}" style="display:none; margin-top:6px;">
                <div style="font-size:12px; line-height:1.4; padding:6px; background:#111; border:1px solid #333; border-radius:4px;">
                    <div><strong>Name:</strong> ${item.name}</div>

                    <div style="margin-top:4px;">
                        <strong>Image:</strong>
${
    item.image && item.image.startsWith("http")
        ? `<img src="${item.image}" style="width:32px; height:32px; object-fit:contain; vertical-align:middle; margin-left:4px;">`
        : `<div style="
                width:32px;
                height:32px;
                background:#333;
                border:1px solid #555;
                border-radius:4px;
                display:inline-block;
                margin-left:4px;
            "></div>`
}
                    </div>

                    <div style="margin-top:8px;"><strong>Stats:</strong></div>
                    <ul style="margin:0 0 6px 15px; padding:0;">
                        ${Object.entries(item.stats || {})
                            .map(([k,v]) => `<li>${k.toUpperCase()}: ${v}</li>`)
                            .join("")}
                    </ul>

                    <div><strong>Resists:</strong></div>
                    <ul style="margin:0 0 6px 15px; padding:0;">
                        ${Object.entries(item.resists || {})
                            .map(([k,v]) => `<li>${k.toUpperCase()}: ${v}</li>`)
                            .join("")}
                    </ul>

                    <div><strong>Damage / AC:</strong> ${item.dmg || "‚Äî"}</div>
                    <div><strong>AC Line:</strong> ${item.ac || "‚Äî"}</div>

                    <div style="margin-top:6px;"><strong>Slot:</strong> ${item.slot?.join(", ")}</div>
                    <div><strong>Classes:</strong> ${item.classes?.join(", ")}</div>

                    <div style="margin-top:6px;"><strong>Effect:</strong> ${item.effect || "None"}</div>
                </div>
            </div>
        `;

        gearBox.appendChild(wrapper);
    }

    // Toggle details
    gearBox.querySelectorAll(".cb2-gear-toggle").forEach(btn => {
        btn.onclick = () => {
            const id = btn.getAttribute("data-id");
            const box = document.getElementById(`cb2_gear_details_${id}`);

            if (box.style.display === "none") {
                box.style.display = "block";
                btn.textContent = "Hide";
            } else {
                box.style.display = "none";
                btn.textContent = "Show";
            }
        };
    });

    // Unequip button
    gearBox.querySelectorAll(".cb2-gear-unequip").forEach(btn => {
        btn.onclick = () => {
            const slot = btn.getAttribute("data-slot");
            const chrId = btn.getAttribute("data-chr");

            const chr = CB2.characters.find(c => c.id === chrId);
            if (!chr) return;

            chr.equipment[slot] = null;

            cb2_swooshSave("characters", CB2.characters);
            cb2_renderCharacterDeck();
        };
    });
}
// -------------------------------
// Equip / Unequip item
// -------------------------------
function cb2_toggleEquipItem(chr, item, isEquipped) {
    const slot = item.slot[0] || null;

    if (!slot) {
        cb2_log("Item has no slot: " + item.name);
        return;
    }

    // Unequip previous item in this slot
    if (isEquipped) {
        for (const s in chr.equipment) {
            if (s === slot && chr.equipment[s]) {
                chr.equipment[s].equipped = false;
            }
        }
        chr.equipment[slot] = item;
        item.equipped = true;
    } else {
        if (chr.equipment[slot] && chr.equipment[slot].id === item.id) {
            chr.equipment[slot] = null;
        }
        item.equipped = false;
    }

    cb2_recalculateCharacterStats(chr);
    cb2_swooshSave("characters", CB2.characters);
    cb2_swooshSave("cb2_items", CB2.items);

    cb2_renderCharacterDeck();
}

// -------------------------------
// Recalculate final stats
// -------------------------------
function cb2_recalculateCharacterStats(chr) {
    const base = chr.originalBaseStats || chr.baseStats || {};
    const finalStats = { ...base };

    const eq = chr.equipment || {};
    for (const slot in eq) {
        const item = eq[slot];
        if (!item) continue;

        // Primary stats
        for (const [stat, val] of Object.entries(item.stats || {})) {
            const key = stat.toUpperCase();
            finalStats[key] = (finalStats[key] || 0) + val;
        }

        // Resist stats
        for (const [res, val] of Object.entries(item.resists || {})) {
            const key = "SV_" + res.toUpperCase();
            finalStats[key] = (finalStats[key] || 0) + val;
        }

        // HP / MANA
        if (item.stats?.hp)   finalStats.HP   = (finalStats.HP   || 0) + item.stats.hp;
        if (item.stats?.mana) finalStats.MANA = (finalStats.MANA || 0) + item.stats.mana;
    }

    chr.finalStats = finalStats;
}


// -------------------------------
// Update character deck to include gear
// -------------------------------
function cb2_renderCharacterDeck() {
    const deck = document.getElementById("cb2_panel_characterDeck");
    if (!deck) return;

    deck.innerHTML = "";

    CB2.characters.forEach(chr => {
        if (!chr.visible) return;

        const panel = document.createElement("div");
        panel.className = "cb2_characterCard";
        panel.style.border = "1px solid #444";
        panel.style.padding = "10px";
        panel.style.marginBottom = "15px";

        const collapseBtnId = "cb2_btn_collapse_" + chr.id;

        panel.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3>${chr.name} (${chr.class} ${chr.level})</h3>
                <button id="${collapseBtnId}">
                    ${chr.collapsed ? "Expand Panel" : "Collapse Panel"}
                </button>
            </div>

            <div id="cb2_panel_chrBody_${chr.id}" style="${chr.collapsed ? "display:none;" : ""}">
                <h4>Base Stats</h4>
                <pre>${JSON.stringify(chr.baseStats, null, 2)}</pre>

                <h4>Final Stats</h4>
                <pre>${JSON.stringify(chr.finalStats, null, 2)}</pre>

                <h4>Equipped Items</h4>
                <div id="cb2_panel_chrGear_${chr.id}"></div>

                <h4>Inventory</h4>
                <div id="cb2_panel_chrInventory_${chr.id}"
                     style="margin-top:6px; padding:6px; background:#111; border:1px solid #333; border-radius:4px; max-height:200px; overflow-y:auto;">
                </div>
            </div>
        `;

        deck.appendChild(panel);

        // Collapse logic
        setTimeout(() => {
            const btn = document.getElementById(collapseBtnId);
            const body = document.getElementById("cb2_panel_chrBody_" + chr.id);

            if (btn && body) {
                btn.onclick = () => {
                    chr.collapsed = !chr.collapsed;
                    cb2_swooshSave("characters", CB2.characters);
                    cb2_renderCharacterDeck();
                };
            }
        }, 0);

        // Render gear
        setTimeout(() => {
            cb2_renderCharacterGear(chr);
        }, 0);

        // Render inventory
        setTimeout(() => {
            cb2_renderCharacterInventory(chr);
        }, 0);
    });
}

function cb2_updateClassDropdown(race) {
    const classSelect = document.getElementById("cb2_input_newCharacterClass");
    classSelect.innerHTML = "";

    const raceKey = race.toLowerCase();
    const raceData = CB2_RACE_CLASS_STATS[raceKey];
    if (!raceData) return;

    Object.keys(raceData).forEach(cls => {
        const opt = document.createElement("option");
        opt.value = cls;
        opt.textContent = cls;
        classSelect.appendChild(opt);
    });
}


// =======================================
// CB2: IMPORT ITEMS FROM function cb2_loadItemIntoManualEditor(item) {

// =======================================

// ---------------------------------------
// Convert scraper item ‚Üí CB2 item format
// ---------------------------------------
function cb2_convertScraperItem(scraped) {
    cb2_log("[CB2 Import] Converting scraped item‚Ä¶");

    if (!scraped) return null;

    // Parse DMG
    let dmg = 0;
    if (scraped.dmgLine) {
        const m = scraped.dmgLine.match(/DMG:\s*(\d+)/i);
        if (m) dmg = parseInt(m[1]);
    }

    // Parse Delay
    let delay = 0;
    if (scraped.skillLine) {
        const m = scraped.skillLine.match(/Delay:\s*(\d+)/i);
        if (m) delay = parseInt(m[1]);
    }

    // Parse AC
    let ac = 0;
    if (scraped.acLine) {
        const m = scraped.acLine.match(/AC:\s*(\d+)/i);
        if (m) ac = parseInt(m[1]);
    }

    return {
        id: "cb2_item_" + Date.now(),
        name: scraped.name || "Unknown Item",
        image: scraped.image || null,
        rawText: null,
        stats: scraped.stats || {},
        resists: scraped.resists || {},
        dmg,
        delay,
        ac,
        slot: scraped.slot || [],
        classes: scraped.classes || [],
        races: scraped.races || [],
        effect: scraped.effect || null,
        effectType: scraped.effectType || null,
        equipped: false
    };
}

// render manual item into preview panel

function cb2_renderScrapedItemPreview(item) {
    const box = document.getElementById("cb2_itemPreviewBox");
    if (!box) return;

    box.innerHTML = `
        <h3>${item.name}</h3>
        <img src="${item.image || ""}" style="max-width:64px; margin-bottom:10px;">
        <pre style="white-space:pre-wrap;">${JSON.stringify(item, null, 2)}</pre>
    `;

    // Update global preview state
    window.CB2_currentPreviewItem = item;

    // Open preview panel
    const previewBody = document.getElementById("cb2_panel_itemPreview_body");
    if (previewBody) previewBody.style.display = "block";

    // Scroll to preview panel
    const previewPanel = document.getElementById("cb2_panel_itemPreview");
    if (previewPanel) previewPanel.scrollIntoView({ behavior: "smooth" });
}
// ---------------------------------------
// Render scraped item into preview panel
// ---------------------------------------
function cb2_renderScrapedItemPreview(scraped) {

    // If this is a scraped item, convert it first
    const item = scraped.dmgLine || scraped.skillLine || scraped.acLine
        ? cb2_convertScraperItem(scraped)
        : scraped;

    const box = document.getElementById("cb2_itemPreviewBox");
    if (!box) return;

    box.innerHTML = `
        <h3>${item.name}</h3>
        <img src="${item.image}" style="max-width:64px; margin-bottom:10px;">
        <pre style="white-space:pre-wrap;">${JSON.stringify(item, null, 2)}</pre>
    `;

    // Update global preview state
    window.CB2_currentPreviewItem = item;

    // Open preview panel
    const previewBody = document.getElementById("cb2_panel_itemPreview_body");
    if (previewBody) previewBody.style.display = "block";

    // Scroll to preview panel
    const previewPanel = document.getElementById("cb2_panel_itemPreview");
    if (previewPanel) previewPanel.scrollIntoView({ behavior: "smooth" });
}

function cb2_deleteApprovedItem(index) {
    const items = cb2_swooshLoad("cb2_items", []);
    const item = items[index];

    if (!confirm(`Delete "${item.name}" from approved items?`)) {
        return;
    }

    items.splice(index, 1);
    cb2_swooshSave("cb2_items", items);
    cb2_updateApprovedList();
}

function cb2_updateApprovedList() {
    const listBox = document.getElementById("cb2_approvedItemsList");
    if (!listBox) return;

    const items = cb2_swooshLoad("cb2_items", []);

    listBox.innerHTML = items.map((it, index) => `
        <div class="cb2-approved-item" 
             style="padding:8px; border-bottom:1px solid #333;">

            <div style="display:flex; justify-content:space-between; align-items:center;">
                
                <!-- Clickable name -->
<div class="cb2-approved-item-name" 
     data-index="${index}" 
     style="cursor:pointer; flex:1; display:flex; align-items:center; gap:6px;">
     
    <img src="${it.image}" 
         style="width:20px; height:20px; object-fit:contain;">

    <strong>${it.name}</strong>
</div>

                <!-- Show/Hide button -->
                <button class="cb2-approved-item-toggle" 
                        data-index="${index}"
                        style="margin-left:10px; padding:2px 6px; font-size:12px;">
                    Show
                </button>

                <!-- Equip button -->
                <button class="cb2-approved-item-equip"
                        data-index="${index}"
                        style="margin-left:10px; padding:2px 6px; font-size:12px;">
                    Equip
                </button>

                <!-- ‚≠ê INLINE EQUIP LIST (NEW) ‚≠ê -->
                <div id="cb2_item_equipList_${index}" 
                     style="display:none; margin-left:10px; font-size:12px; color:#ccc;">
                </div>

                <!-- Delete button -->
                <button class="cb2-approved-item-delete" 
                        data-index="${index}"
                        style="margin-left:10px; padding:2px 6px; font-size:12px;">
                    ‚úï
                </button>
            </div>

            <!-- Hidden details -->
            <div id="cb2_item_details_${index}" 
                 style="display:none; margin-top:6px;">

                <div class="cb2-item-details-block" 
                     style="font-size:12px; line-height:1.4; padding:6px; background:#1a1a1a; border:1px solid #333; border-radius:4px;">

                    <div><strong>Name:</strong> ${it.name}</div>

                    <div style="margin-top:4px;">
                        <strong>Image:</strong>
                        <img src="${it.image}" style="width:32px; vertical-align:middle; margin-left:4px;">
                    </div>

                    <div style="margin-top:8px;"><strong>Stats:</strong></div>
                    <ul style="margin:0 0 6px 15px; padding:0;">
                        ${Object.entries(it.stats || {})
                            .map(([k,v]) => `<li>${k.toUpperCase()}: ${v}</li>`)
                            .join("")}
                    </ul>

                    <div><strong>Resists:</strong></div>
                    <ul style="margin:0 0 6px 15px; padding:0;">
                        ${Object.entries(it.resists || {})
                            .map(([k,v]) => `<li>${k.toUpperCase()}: ${v}</li>`)
                            .join("")}
                    </ul>

                    <div><strong>Damage / AC:</strong> ${it.dmg || "‚Äî"}</div>
                    <div><strong>AC Line:</strong> ${it.ac || "‚Äî"}</div>

                    <div style="margin-top:6px;"><strong>Slot:</strong> ${it.slot?.join(", ")}</div>
                    <div><strong>Classes:</strong> ${it.classes?.join(", ")}</div>
                    <div><strong>Races:</strong> ${it.races?.join(", ")}</div>

                    <div style="margin-top:6px;"><strong>Effect:</strong> ${it.effect || "None"}</div>

                </div>
            </div>

        </div>
    `).join("");

    // Click name ‚Üí load into preview
    document.querySelectorAll(".cb2-approved-item-name").forEach(el => {
        el.onclick = () => {
            const idx = el.getAttribute("data-index");
            const items = cb2_swooshLoad("cb2_items", []);
            cb2_renderScrapedItemPreview(items[idx]);
            window.CB2_currentPreviewItem = items[idx];
        };
    });

    // Toggle details
    document.querySelectorAll(".cb2-approved-item-toggle").forEach(btn => {
        btn.onclick = (e) => {
            e.stopPropagation();
            const idx = btn.getAttribute("data-index");
            const box = document.getElementById(`cb2_item_details_${idx}`);

            if (box.style.display === "none") {
                box.style.display = "block";
                btn.textContent = "Hide";
            } else {
                box.style.display = "none";
                btn.textContent = "Show";
            }
        };
    });

    // ‚≠ê INLINE EQUIP HANDLER ‚≠ê
    document.querySelectorAll(".cb2-approved-item-equip").forEach(btn => {
        btn.onclick = (e) => {
            e.stopPropagation();

            const idx = btn.getAttribute("data-index");
            const box = document.getElementById(`cb2_item_equipList_${idx}`);
            const chars = cb2_swooshLoad("characters", []);

            // Toggle visibility
            if (box.style.display === "block") {
                box.style.display = "none";
                return;
            }

            box.style.display = "block";

            // Equip actions
            box.querySelectorAll(".cb2-equip-choose").forEach(btn2 => {
                btn2.onclick = (e) => {
                    e.stopPropagation();

                    const itemIndex = parseInt(btn2.getAttribute("data-item"), 10);
                    const charIndex = parseInt(btn2.getAttribute("data-char"), 10);

                    cb2_equipItemToCharacter(itemIndex, charIndex);

                    // Hide list after equip
                    box.style.display = "none";
                };
            });
        };
    });

    // Delete with confirm
    document.querySelectorAll(".cb2-approved-item-delete").forEach(btn => {
        btn.onclick = (e) => {
            e.stopPropagation();
            const idx = btn.getAttribute("data-index");
            cb2_deleteApprovedItem(idx);
        };
    });
}

function cb2_equipItemToCharacter(itemIndex, charIndex) {
    console.log("=== EQUIP DEBUG START ===");

    console.log("Raw itemIndex:", itemIndex, "type:", typeof itemIndex);
    console.log("Raw charIndex:", charIndex, "type:", typeof charIndex);

    // Normalize indexes
    itemIndex = parseInt(itemIndex, 10);
    charIndex = parseInt(charIndex, 10);

    console.log("Parsed itemIndex:", itemIndex);
    console.log("Parsed charIndex:", charIndex);

    const items = cb2_swooshLoad("cb2_items", []);
    const chars = cb2_swooshLoad("characters", []);

    console.log("Loaded items:", items);
    console.log("Loaded chars:", chars);

    const item = items[itemIndex];
    const chr = chars[charIndex];

    console.log("Selected item:", item);
    console.log("Selected character:", chr);

    if (!item) {
        console.log("ERROR: Item not found at index", itemIndex);
        return;
    }
    if (!chr) {
        console.log("ERROR: Character not found at index", charIndex);
        return;
    }

    // Ensure equipment object exists
    if (!chr.equipment) {
        console.log("Character had NO equipment object ‚Äî creating one.");
        chr.equipment = {};
    }

    console.log("Item slot array:", item.slot);
    console.log("Primary slot:", item.slot ? item.slot[0] : "(none)");

    const slot = item.slot ? item.slot[0] : null;

    if (!slot) {
        console.log("ERROR: Item has no slot ‚Äî cannot equip.");
        return;
    }

    // Equip item
    chr.equipment[slot] = item;
    console.log("Updated equipment object:", chr.equipment);

    // Save to storage
    cb2_swooshSave("characters", chars);
    console.log("Saved updated characters to storage.");

    // Update in-memory
    if (CB2.characters && CB2.characters[charIndex]) {
        CB2.characters[charIndex].equipment = { ...chr.equipment };
        console.log("Updated in-memory CB2.characters entry:", CB2.characters[charIndex]);
    } else {
        console.log("WARNING: CB2.characters missing or index not found.");
        console.log("CB2.characters =", CB2.characters);
    }

    console.log(`[Equip] Equipped ${item.name} to ${chr.name}`);

    // Re-render deck
    console.log("Calling cb2_renderCharacterDeck()...");
    cb2_renderCharacterDeck();

    console.log("=== EQUIP DEBUG END ===");
}
// =======================================
// CB2-SAFE P99 ITEM PARSER
// =======================================
function parseP99HTML(html) {
    cb2_log("[Parser] Starting parseP99HTML‚Ä¶");

    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");

    // -----------------------------------
    // TITLE
    // -----------------------------------
    const title = doc.querySelector(".itemtitle")?.textContent.trim() || "Unknown Item";
    cb2_log("[Parser] Title: " + title);

    // -----------------------------------
    // ICON
    // -----------------------------------
    const iconEl = doc.querySelector(".itemicon img");
    let iconUrl = null;

    if (iconEl) {
        const iconFile = iconEl.getAttribute("src").split("/").pop();
        iconUrl = "https://wiki.project1999.com/images/" + iconFile;
        cb2_log("[Parser] Icon found: " + iconUrl);
    } else {
        cb2_log("[Parser] No icon found.");
    }

    // -----------------------------------
    // DATA BLOCK
    // -----------------------------------
    const block = doc.querySelector(".itemdata p")?.innerText || "";
    const lines = block.split("\n").map(l => l.trim());

    cb2_log("[Parser] Data block lines: " + lines.length);

    // -----------------------------------
    // FLAGS
    // -----------------------------------
    const flags = lines[0]
        .split("  ")
        .map(f => f.trim())
        .filter(f => f.length > 0);

    cb2_log("[Parser] Flags: " + JSON.stringify(flags));

    // -----------------------------------
    // SLOT
    // -----------------------------------
    const slotLine = lines.find(l => l.startsWith("Slot:"));
    const slot = slotLine
        ? slotLine.replace("Slot:", "").trim().split(" ")
        : [];

    cb2_log("[Parser] Slot(s): " + JSON.stringify(slot));

    // -----------------------------------
    // SKILL / DELAY
    // -----------------------------------
    const skillLine = lines.find(l => l.startsWith("Skill:")) || "";
    cb2_log("[Parser] Skill line: " + skillLine);

    // -----------------------------------
    // DMG / AC
    // -----------------------------------
    const dmgLine = lines.find(l => l.startsWith("DMG:")) || "";
    const acLine = lines.find(l => l.startsWith("AC:")) || "";

    cb2_log("[Parser] DMG line: " + dmgLine);
    cb2_log("[Parser] AC line: " + acLine);

    // -----------------------------------
    // STATS
    // -----------------------------------
    const stats = {};
    const statRegex = /(STR|STA|DEX|AGI|WIS|INT|CHA|HP|MANA): \+?(\d+)/g;
    let match;

    while ((match = statRegex.exec(block)) !== null) {
        stats[match[1].toLowerCase()] = parseInt(match[2], 10);
    }

    cb2_log("[Parser] Stats: " + JSON.stringify(stats));

    // -----------------------------------
    // RESISTS
    // -----------------------------------
    const resists = {};
    const resistRegex = /SV (FIRE|COLD|MAGIC|POISON|DISEASE): \+?(\d+)/g;

    while ((match = resistRegex.exec(block)) !== null) {
        resists[match[1].toLowerCase()] = parseInt(match[2], 10);
    }

    cb2_log("[Parser] Resists: " + JSON.stringify(resists));

    // -----------------------------------
    // WEIGHT / SIZE
    // -----------------------------------
    const wtLine = lines.find(l => l.startsWith("WT:"));
    const sizeLine = lines.find(l => l.startsWith("Size:"));

    const weight = wtLine ? parseFloat(wtLine.replace("WT:", "").trim()) : null;
    const size = sizeLine ? sizeLine.replace("Size:", "").trim() : null;

    cb2_log("[Parser] Weight: " + weight + " | Size: " + size);

    // -----------------------------------
    // CLASS / RACE
    // -----------------------------------
    const classLine = lines.find(l => l.startsWith("Class:"));
    const raceLine = lines.find(l => l.startsWith("Race:"));

    const classes = classLine
        ? classLine.replace("Class:", "").trim().split(" ")
        : [];

    const races = raceLine
        ? raceLine.replace("Race:", "").trim().split(" ")
        : [];

    cb2_log("[Parser] Classes: " + JSON.stringify(classes));
    cb2_log("[Parser] Races: " + JSON.stringify(races));

// -----------------------------------
// FINAL SCRAPED OBJECT
// -----------------------------------
const item = {
    name: title,
    image: iconUrl,
    flags,
    slot,
    skillLine,
    dmgLine,
    acLine,
    stats,
    resists,
    weight,
    size,
    classes,
    races
};

cb2_log("[Parser] Final scraped item built.");
// -----------------------------------
// DISPLAY IMAGE (legacy UI)
// -----------------------------------
const imgBox = document.getElementById("itemImageBox");
if (imgBox) {
    imgBox.innerHTML = "";

    if (item.image) {
        const img = document.createElement("img");
        img.src = item.image;
        img.style.width = "64px";
        img.style.height = "64px";
        imgBox.appendChild(img);
    } else {
        imgBox.textContent = "No image";
    }
}

// -----------------------------------
// STORE SCRAPED ITEM FOR APPROVAL
// -----------------------------------
window.CB2_lastScrapedItem = item;
cb2_log("[Parser] Scraped item stored for approval.");

// -----------------------------------
// SHOW PREVIEW IN CB2 UI
// -----------------------------------
cb2_renderScrapedItemPreview(item);

return item;
}
// -------------------------------
// Debug helper
// -------------------------------
function cb2_fetchLog(msg) {
    cb2_log("[Fetch] " + msg);
}

// -------------------------------
// Build proxy URL
// -------------------------------
function cb2_buildProxyUrl(proxyType, url) {
    cb2_fetchLog("Building proxy URL for type " + proxyType);

    switch (proxyType) {
        case 1:
            return "https://corsproxy.io/?" + url;
        case 2:
            return "https://api.allorigins.win/raw?url=" + url;
        case 3:
            return "https://thingproxy.freeboard.io/fetch/" + url;
        default:
            return url;
    }
}

// -------------------------------
// Direct fetch (no proxy)
// -------------------------------
async function cb2_fetchDirect(url) {
    cb2_fetchLog("Direct fetch: " + url);

    try {
        const response = await fetch(url);

        if (!response.ok) {
            cb2_fetchLog("HTTP Error: " + response.status + " " + response.statusText);
            return;
        }

        const html = await response.text();
        cb2_fetchLog("HTML loaded (" + html.length + " chars)");

        parseP99HTML(html);

    } catch (err) {
        cb2_fetchLog("FETCH FAILED: " + err);
    }
}

// -------------------------------
// Proxy fetch
// -------------------------------
async function cb2_runProxy(proxyType) {
    const url = document.getElementById("urlInput").value.trim();
    const finalUrl = cb2_buildProxyUrl(proxyType, url);

    cb2_fetchLog("Fetching via proxy " + proxyType + ": " + finalUrl);

    try {
        const response = await fetch(finalUrl);

        if (!response.ok) {
            cb2_fetchLog("HTTP Error: " + response.status + " " + response.statusText);
            return;
        }

        const html = await response.text();
        cb2_fetchLog("HTML loaded (" + html.length + " chars)");

        parseP99HTML(html);

    } catch (err) {
        cb2_fetchLog("FETCH FAILED: " + err);
    }
}

// -------------------------------
// Proxy checkbox logic
// -------------------------------
function cb2_initProxySelector() {
    const proxyBoxes = document.querySelectorAll(".proxyChoice");
    const runBtn = document.getElementById("runBtn");

    proxyBoxes.forEach(box => {
        box.addEventListener("change", () => {

            // Uncheck all other boxes
            proxyBoxes.forEach(other => {
                if (other !== box) other.checked = false;
            });

            // Enable button only if one is selected
            const anyChecked = [...proxyBoxes].some(b => b.checked);
            runBtn.disabled = !anyChecked;

            cb2_fetchLog("Proxy selected: " + (anyChecked ? box.value : "none"));
        });
    });
}

// -------------------------------
// Button hooks
// -------------------------------
function cb2_initFetchButtons() {
    const runBtn = document.getElementById("runBtn");
    const proxyBoxes = document.querySelectorAll(".proxyChoice");

    if (runBtn) {
        runBtn.disabled = false;
        runBtn.onclick = () => {
            const selected = [...proxyBoxes].find(b => b.checked);
            if (!selected) {
                cb2_fetchLog("No proxy selected.");
                return;
            }
            const proxyType = parseInt(selected.value, 10);
            cb2_runProxy(proxyType);
        };
    }

    document.getElementById("proxy1Btn").onclick = () => cb2_runProxy(1);
    document.getElementById("proxy2Btn").onclick = () => cb2_runProxy(2);
    document.getElementById("proxy3Btn").onclick = () => cb2_runProxy(3);

    cb2_fetchLog("Fetch buttons initialized.");
}


// keep above auto-init

function cb2_buildScraperConsole() {
    const parent = document.getElementById("p99_scraper_panel");
    if (!parent) return;

    const pre = document.createElement("pre");
    pre.id = "output";

    pre.style.whiteSpace = "pre-wrap";
    pre.style.background = "#000";
    pre.style.color = "#0f0";
    pre.style.padding = "12px";
    pre.style.maxHeight = "400px";
    pre.style.overflowY = "auto";
    pre.style.border = "1px solid #222";
    pre.style.fontSize = "14px";
    pre.style.lineHeight = "1.35";
    pre.style.margin = "10px 0 0 0";
    pre.style.boxSizing = "border-box";

    // keep it safe
    pre.style.maxWidth = "100%";
    pre.style.overflowX = "auto";
    pre.style.wordBreak = "break-word";

    // ‚≠ê append AFTER the panel
    parent.insertAdjacentElement("afterend", pre);
}
// -------------------------------
// AUTO-INIT FETCH SYSTEM
// -------------------------------
cb2_initProxySelector();
cb2_initFetchButtons();
cb2_fetchLog("Proxy + Fetch system ready.");


document.addEventListener("DOMContentLoaded", () => {
    cb2_log("[Init] DOM ready ‚Äî initializing CB2 systems‚Ä¶");

    // 1. Initialize CB2 core
    if (typeof cb2_init === "function") {
        cb2_init();
        cb2_log("[Init] CB2 core initialized.");
    }

    // 2. Build scraper console
    cb2_buildScraperConsole();

    // Debug check
    const out = document.getElementById("output");
    if (out) {
        __DBG("CHECK: scraper console successfully created.");
    } else {
        __DBG("CHECK: scraper console NOT created.");
    }

    // 3. Load approved items list
    //cb2_updateApprovedList();

    // 4. Wire toggle buttons
    document.querySelectorAll(".cb2_toggleBtn").forEach(btn => {
        const targetId = btn.getAttribute("data-target");
        const target = document.getElementById(targetId);
        if (!target) return;

        btn.onclick = () => {
            const isHidden = target.style.display === "none";
            target.style.display = isHidden ? "" : "none";
            btn.textContent = isHidden ? "[-]" : "[+]";
        };
    });

    // 5. Wire race dropdown
    const raceSelect = document.getElementById("raceSelect");
    if (raceSelect) {
        raceSelect.onchange = (e) => {
            cb2_updateClassDropdown(e.target.value);
            cb2_startCharacterDraft();
        };
    }

    // 6. Wire class dropdown
    const classSelect = document.getElementById("cb2_input_newCharacterClass");
    if (classSelect) {
        classSelect.onchange = cb2_startCharacterDraft;
    }

    // 7. Wire name input
    const nameInput = document.getElementById("cb2_input_newCharacterName");
    if (nameInput) {
        nameInput.oninput = cb2_startCharacterDraft;
    }

    // 8. Wire level input
    const levelInput = document.getElementById("cb2_input_newCharacterLevel");
    if (levelInput) {
        levelInput.onchange = cb2_startCharacterDraft;
    }

// 9. Wire Approve button
const approveBtn = document.getElementById("cb2_btn_approveScrapedItem");
if (approveBtn) {
approveBtn.onclick = () => {
    const item = window.CB2_currentPreviewItem;
    if (!item) {
        cb2_log("[CB2 Import] No item to approve.");
        return;
    }

    cb2_saveInventoryItem(item); // unified save
    cb2_updateApprovedList();
};
}
    // 10. Wire Create Character button
    const createBtn = document.getElementById("cb2_btn_createCharacter");
    if (createBtn) {
        createBtn.onclick = cb2_finalizeCharacterCreation;
    }

    cb2_log("[Init] System ready for testing.");
});
function cb2_finalizeCharacterCreation() {
    const chr = CB2.currentCharacterDraft;

    if (!chr) {
        cb2_log("No character draft exists.");
        return;
    }

    if (chr.bonusPool > 0) {
        cb2_log("Assign all bonus points before creating the character.");
        return;
    }

    // Lock in the true base stats
    chr.originalBaseStats = { ...chr.baseStats };

    // REQUIRED FIELDS FOR DECK + LIST + EQUIP
    chr.id = "chr_" + Date.now();
    chr.visible = true;
    chr.collapsed = false;
    chr.equipment = {};
    chr.finalStats = { ...chr.baseStats };

    // Save character
    CB2.characters.push(chr);
    cb2_swooshSave("characters", CB2.characters);

    cb2_log("Created character: " + chr.name);

    // Update both panels
    cb2_renderCharacterDeck();
    cb2_renderCharacterList();

    CB2.currentCharacterDraft = null;
}



function cb2_renderCharacterInventory(chr) {
    const invBox = document.getElementById(`cb2_panel_chrInventory_${chr.id}`);
    if (!invBox) return;

    const items = cb2_swooshLoad("cb2_items", []);

    invBox.innerHTML = items.map((it, idx) => `
        <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
            <span>${it.name}</span>
            <button class="cb2-inventory-equip"
                    data-item="${idx}"
                    data-char="${chr.id}"
                    style="padding:2px 6px; font-size:12px;">
                Equip
            </button>
        </div>
    `).join("");

    invBox.querySelectorAll(".cb2-inventory-equip").forEach(btn => {
        btn.onclick = () => {
            const itemIndex = parseInt(btn.getAttribute("data-item"), 10);
            const charId = btn.getAttribute("data-char");

            const charIndex = CB2.characters.findIndex(c => c.id == charId);
            if (charIndex === -1) return;

            cb2_equipItemToCharacter(itemIndex, charIndex);

            cb2_renderCharacterDeck();
        };
    });
}

// =============================================================
// function cb2_startCharacterDraft
// =============================================================
function cb2_startCharacterDraft() {
    const name = document.getElementById("cb2_input_newCharacterName")?.value.trim() || "";
    const cls  = document.getElementById("cb2_input_newCharacterClass")?.value;
    const lvl  = parseInt(document.getElementById("cb2_input_newCharacterLevel")?.value, 10) || 1;
    const race = document.getElementById("raceSelect")?.value.toLowerCase();

    if (!cls || !race) return;

    const base = cb2_getBaseStatsForRaceClass(race, cls);
    if (!base) return;

    const baseStats = {
        STR: base.STR,
        STA: base.STA,
        AGI: base.AGI,
        DEX: base.DEX,
        WIS: base.WIS,
        INT: base.INT,
        CHA: base.CHA,

        SV_FIRE: 0,
        SV_COLD: 0,
        SV_POISON: 0,
        SV_DISEASE: 0
    };

    const chr = {
        id: "draft_" + Date.now(),
        name,
        class: cls,
        race,
        level: lvl,

        baseStats,
        originalBaseStats: { ...baseStats },

        bonusPool: 25,

        equipment: {},
        finalStats: { ...baseStats },
        visible: true,
        collapsed: false
    };

    window.CB2.currentCharacterDraft = chr;
    cb2_renderCharacterCreatorStats(chr);
}

// Make sure it's global
window.cb2_startCharacterDraft = cb2_startCharacterDraft;

//
function cb2_saveInventoryItem(item) {
    const items = cb2_swooshLoad("cb2_items", []);
    items.push(item);
    cb2_swooshSave("cb2_items", items);
    cb2_log("Saved item: " + item.name);
}

//loop to editor back from preview

function cb2_loadItemIntoManualEditor(item) {

    const safeSet = (id, value) => {
        const el = document.getElementById(id);
        if (el) el.value = value;
    };

    // BASIC
    safeSet("cb2_manual_name", item.name || "");
    safeSet("cb2_manual_itemType", item.itemType || "Misc");

    // STATS
    safeSet("cb2_manual_str", item.stats?.str || 0);
    safeSet("cb2_manual_sta", item.stats?.sta || 0);
    safeSet("cb2_manual_agi", item.stats?.agi || 0);
    safeSet("cb2_manual_dex", item.stats?.dex || 0);
    safeSet("cb2_manual_int", item.stats?.int || 0);
    safeSet("cb2_manual_wis", item.stats?.wis || 0);
    safeSet("cb2_manual_cha", item.stats?.cha || 0);

    // VITALS
    safeSet("cb2_manual_hp", item.stats?.hp || 0);
    safeSet("cb2_manual_mana", item.stats?.mana || 0);
    safeSet("cb2_manual_end", item.stats?.end || 0);

    // RESISTS
    safeSet("cb2_manual_fire", item.resists?.fire || 0);
    safeSet("cb2_manual_cold", item.resists?.cold || 0);
    safeSet("cb2_manual_magic", item.resists?.magic || 0);
    safeSet("cb2_manual_disease", item.resists?.disease || 0);
    safeSet("cb2_manual_poison", item.resists?.poison || 0);

    // COMBAT
    safeSet("cb2_manual_dmg", item.dmg || 0);
    safeSet("cb2_manual_delay", item.delay || 0);
    safeSet("cb2_manual_ac", item.ac || 0);

    // SLOTS
    document.querySelectorAll("#cb2_panel_manualItem_slots input[type=checkbox]")
        .forEach(chk => chk.checked = item.slot?.includes(chk.value));

    // CLASSES
    document.querySelectorAll("#cb2_panel_manualItem_classes input[type=checkbox]")
        .forEach(chk => chk.checked = item.classes?.includes(chk.value));

    // RACES
    document.querySelectorAll("#cb2_panel_manualItem_races input[type=checkbox]")
        .forEach(chk => chk.checked = item.races?.includes(chk.value));

    // PRESERVE IMAGE
    window.CB2_manualEditorImage = item.image || null;
}

// resend to editor button from preview panel

document.getElementById("cb2_btn_sendToEditor").onclick = () => {
    if (!window.CB2_currentPreviewItem) {
        cb2_log("No preview item to send to editor.");
        return;
    }

    cb2_loadItemIntoManualEditor(window.CB2_currentPreviewItem);

    cb2_log("Item loaded into Manual Editor for editing.");

    // Open manual editor panel
    document.getElementById("cb2_panel_manualItemEntry_body").style.display = "block";

    // Scroll to manual editor
    document.getElementById("cb2_panel_manualItemEntry")
        .scrollIntoView({ behavior: "smooth" });
};

// token item system

document.getElementById("cb2_btn_toggleInventoryList").onclick = () => {
    const list = document.getElementById("cb2_tokenInventoryList");
    const btn = document.getElementById("cb2_btn_toggleInventoryList");

    if (list.style.display === "none") {
        list.style.display = "block";
        btn.textContent = "Hide Inventory List";
    } else {
        list.style.display = "none";
        btn.textContent = "Show Inventory List";
    }
};

// Load inventory items into the Token Workshop list
document.getElementById("cb2_btn_loadInventoryTokens").onclick = () => {

    const listBox = document.getElementById("cb2_tokenInventoryList");
    listBox.innerHTML = "";

    // Load the same inventory the character screen uses
    const items = cb2_swooshLoad("cb2_items", []);

    if (!items || items.length === 0) {
        listBox.innerHTML = "<div style='color:#888;'>No inventory items found.</div>";
        return;
    }

    items.forEach((item, idx) => {

        const row = document.createElement("div");
        row.style.marginBottom = "6px";

        row.innerHTML = `
            <span style="color:#0f0;">${item.name}</span>
            <button class="cb2_btn_createToken"
                    data-itemindex="${idx}"
                    style="margin-left:10px;">
                Create Token
            </button>
        `;

        listBox.appendChild(row);
    });

    cb2_log("Inventory loaded into Token Workshop.");
};


function cb2_generateTokenFromItem(item) {

    const token = [
        "CB2TOKEN",
        `NAME:${item.name}`,
        `IMG:${item.image ? item.image.replace("https://wiki.project1999.com/images/", "") : ""}`,
        `DMG:${item.dmg || 0}`,
        `DELAY:${item.delay || 0}`,
        `AC:${item.ac || 0}`,
        `STATS:${JSON.stringify(item.stats)}`,
        `RESISTS:${JSON.stringify(item.resists)}`,
        `SLOT:${item.slot.join(",")}`,
        `CLASS:${item.classes.join(",")}`,
        `RACE:${item.races.join(",")}`,
        "ENDTOKEN"
    ].join("|");

    return token;
}

document.addEventListener("click", e => {
    if (!e.target.classList.contains("cb2_btn_createToken")) return;

    const idx = parseInt(e.target.getAttribute("data-itemindex"), 10);

    // Load from the same place as character inventory + token workshop
    const items = cb2_swooshLoad("cb2_items", []);
    const item = items[idx];

    if (!item) {
        cb2_log("Token Error: Item not found.");
        return;
    }

    const token = cb2_generateTokenFromItem(item);

    cb2_log(
        "=========== TOKEN GENERATED ===========\n" +
        token +
        "\n========================================\n"
    );
});


//beta  >>

function cb2_decodeToken(token) {

    const parts = token.split("|");
    const obj = {
        id: "cb2_item_token_" + Date.now(),
        name: "",
        itemType: "Misc",
        stats: {},
        resists: {},
        dmg: 0,
        delay: 0,
        ac: 0,
        slot: [],
        classes: [],
        races: [],
        image: null,
        rawText: null,
        effect: null,
        effectType: null,
        equipped: false
    };

    for (let part of parts) {

        if (part.startsWith("NAME:"))
            obj.name = part.replace("NAME:", "");

        else if (part.startsWith("IMG:")) {
            const img = part.replace("IMG:", "");
            obj.image = img ? "https://wiki.project1999.com/images/" + img : null;
        }

        else if (part.startsWith("DMG:"))
            obj.dmg = parseInt(part.replace("DMG:", "")) || 0;

        else if (part.startsWith("DELAY:"))
            obj.delay = parseInt(part.replace("DELAY:", "")) || 0;

        else if (part.startsWith("AC:"))
            obj.ac = parseInt(part.replace("AC:", "")) || 0;

        else if (part.startsWith("STATS:"))
            obj.stats = JSON.parse(part.replace("STATS:", ""));

        else if (part.startsWith("RESISTS:"))
            obj.resists = JSON.parse(part.replace("RESISTS:", ""));

        else if (part.startsWith("SLOT:"))
            obj.slot = part.replace("SLOT:", "").split(",").filter(x => x);

        else if (part.startsWith("CLASS:"))
            obj.classes = part.replace("CLASS:", "").split(",").filter(x => x);

        else if (part.startsWith("RACE:"))
            obj.races = part.replace("RACE:", "").split(",").filter(x => x);
    }

    return obj;
}

document.getElementById("cb2_btn_importToken").onclick = () => {

    const token = document.getElementById("cb2_input_tokenImport").value.trim();
    if (!token) {
        cb2_log("No token entered.");
        return;
    }

    // Debug: Token received
    cb2_log(
        "=========== TOKEN RECEIVED ===========\n" +
        token +
        "\n=======================================\n"
    );

    // Decode token ‚Üí item (placeholder for now)
const decodedItem = cb2_decodeToken(token);

    // Debug: Token decoded
    cb2_log(
        "=========== TOKEN DECODED ============\n" +
        JSON.stringify(decodedItem, null, 2) +
        "\n=======================================\n"
    );

    // Send decoded item to preview (same pipeline as scraper)
    cb2_renderScrapedItemPreview(decodedItem);
    window.CB2_currentPreviewItem = decodedItem;

    cb2_log("Token imported and item sent to preview.");
};


// write to correct save file when save triggered

function cb2_writeItemsIntoSwoosh() {
    try {
        const items = CB2.items || [];
        window.ItemRegistry = items;

        const characters = CB2.characters || [];
        window.CB2_CharactersForSwoosh = characters;

        const tokens = CB2.tokens || [];
        window.CB2_TokensForSwoosh = tokens;

        cb2_log("[SYNC] CB2 data prepared for swoosh save.");
    } catch (e) {
        cb2_log("[SYNC ERROR] Failed to sync CB2 data into swoosh: " + e.message);
    }
}

// ===============================
// REFRESH / CLOSE WARNING
// ===============================
window.addEventListener("beforeunload", function (e) {
    // Custom message (not all browsers show it, but the warning still triggers)
    const message = "Warning: This page does NOT save any data. Refreshing will wipe all timers, notes, and history. Save your logs before leaving.";

    e.preventDefault();
    e.returnValue = message; // Required for Chrome/Edge
    return message;
});

//blanknoloadimage
document.addEventListener("error", function (e) {
    const elem = e.target;

    if (elem.tagName === "IMG") {
        elem.src = "";
        elem.alt = "‚ú®";
        elem.onerror = null;
    }
}, true);


// AUTO CLOSE ON START PANELS
document.addEventListener("DOMContentLoaded", () => {
    const panelsToCollapse = [
        "cb2_panel_manualItemEntry_body",
        "cb2_panel_root_body",
        "cb2_panel_characterList_body",
        "cb2_panel_characterDeck_body",
        "cb2_panel_tokenWorkshop_body",
        "cb2_panel_itemPreview_body",
        "p99_scraper_panel_body"
    ];

    panelsToCollapse.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = "none";
    });
});
__DBG("PAST end to script end 0101337");


__DBG("PAST end to tired");
</script>

</body>
</html>
